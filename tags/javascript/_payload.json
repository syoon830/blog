[{"data":1,"prerenderedAt":6732},["Reactive",2],{"content-query-y68BiRpcNm":3},[4,436,979,1321,1536,2366,2542,2933,3145,3519,3604,3854,4590,5138,5289,5571,5670,5833,6005,6213,6603,6651],{"_path":5,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":9,"description":10,"tags":11,"date":13,"body":14,"_type":431,"_id":432,"_source":433,"_file":434,"_extension":435},"/posts/2c99fd61-ec92-45ab-993c-7bd3c85dbfc8","posts",false,"","자바스크립트 - 20. 클로저","프로그래밍에서 클로저는 외부 함수에서 선언된 변수에 내부 함수가 접근할 수 있도록 '닫혀 있는' 환경을 만들어, 그 변수들이 외부 함수가 종료된 후에도 계속 유지될 수 있게 합니다. 즉, 내부 함수는 외부 함수의 지역 변수에 '닫혀 있는' 상태로 접근할 수 있으며, 이로 인해 해당 변수들은 외부 함수가 실행을 마친 이후에도 사라지지 않고 접근 가능한 상태로 남아 있습니다. 이처럼, 클로저는 데이터를 '닫아서(enclose)' 보존하고, 필요할 때 언제든지 해당 데이터를 사용할 수 있게 해주는 프로그래밍 구조입니다.",[12],"javascript","2024-03-01T00:00:00.000Z",{"type":15,"children":16,"toc":428},"root",[17,24,29,34,38,43,48,52,57,64,69,81,85,90,95,100,104,109,115,120,126,135,140,145,150,154,159,164,168,173,179,184,188,193,202,207,222,227,231,236,245,250,259,272,277,282,288,293,298,307,311,316,321,326,335,340,345,349,354,363,369,378,383,387,392,401,406,410,415,424],{"type":18,"tag":19,"props":20,"children":21},"element","p",{},[22],{"type":23,"value":10},"text",{"type":18,"tag":19,"props":25,"children":26},{},[27],{"type":23,"value":28},"\\n",{"type":18,"tag":19,"props":30,"children":31},{},[32],{"type":23,"value":33},"클로저는 실행 컨텍스트에 대한 사전 지식이 있으면 이해하기 어려운 개념은 아니다.",{"type":18,"tag":19,"props":35,"children":36},{},[37],{"type":23,"value":28},{"type":18,"tag":19,"props":39,"children":40},{},[41],{"type":23,"value":42},"MDN에서는 클로저에 대해 다음과 같이 정의하고 있다.",{"type":18,"tag":19,"props":44,"children":45},{},[46],{"type":23,"value":47},"“클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다”",{"type":18,"tag":19,"props":49,"children":50},{},[51],{"type":23,"value":28},{"type":18,"tag":19,"props":53,"children":54},{},[55],{"type":23,"value":56},"무슨 말인지 잘 모르겠는데 우선 먼저 이해해야할 핵심 키워드는 **“함수가 선언된 렉시컬 환경”**이다.",{"type":18,"tag":58,"props":59,"children":61},"h1",{"id":60},"렉시컬-스코프",[62],{"type":23,"value":63},"렉시컬 스코프",{"type":18,"tag":19,"props":65,"children":66},{},[67],{"type":23,"value":68},"자바스크립트 엔진은 함수를 어디서 호출했는지가 함수를 어디에 정의했는지에 따라 상위 스코프를 결정한다. 이를 렉시컬 스코프(정적 스코프)라 한다.",{"type":18,"tag":70,"props":71,"children":75},"pre",{"className":72,"code":74,"language":12,"meta":8},[73],"language-javascript","const x = 1;\n\nfunction foo() {\n    const x = 10;\n    bar();\n}\n\nfunction bar() {\n    console.log(x);\n}\n\nfoo(); // ?\nbar(); // ?\n",[76],{"type":18,"tag":77,"props":78,"children":79},"code",{"__ignoreMap":8},[80],{"type":23,"value":74},{"type":18,"tag":19,"props":82,"children":83},{},[84],{"type":23,"value":28},{"type":18,"tag":19,"props":86,"children":87},{},[88],{"type":23,"value":89},"“실행 컨텍스트”에서 살펴보았듯이 스코프의 실체는 실행 컨텍스트의 렉시컬 환경이다. 이 렉시컬 환경은 자신의 “외부 렉시컬 환경에 대한 참조”(파란색 동그라미 친거)를 통해 상위 렉시컬 환경과 연결된다. 이것이 바로 스코프 체인이다.",{"type":18,"tag":19,"props":91,"children":92},{},[93],{"type":23,"value":94},"따라서 “함수의 상위 스코프를 결정한다”는 것은 “렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조값을 결정한다”는 것과 같다.",{"type":18,"tag":96,"props":97,"children":99},"img",{"src":98},"/blog/images/7c41369b-1948-4250-90b4-8216a6d6ee86.png",[],{"type":18,"tag":19,"props":101,"children":102},{},[103],{"type":23,"value":28},{"type":18,"tag":19,"props":105,"children":106},{},[107],{"type":23,"value":108},"렉시컬 환경의 “외부 렉시컬 환경에 대한 참조”에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정된다. 이것이 바로 렉시컬 스코프다.",{"type":18,"tag":58,"props":110,"children":112},{"id":111},"함수-객체의-내부-슬롯",[113],{"type":23,"value":114},"함수 객체의 내부 슬롯",{"type":18,"tag":19,"props":116,"children":117},{},[118],{"type":23,"value":119},"함수는 자신의 내부 슬롯 [[Environment]]에 자신이 정의된 환경, 즉 상위 스코프 참조를 저장한다.",{"type":18,"tag":58,"props":121,"children":123},{"id":122},"클로저와-렉시컬-환경",[124],{"type":23,"value":125},"클로저와 렉시컬 환경",{"type":18,"tag":70,"props":127,"children":130},{"className":128,"code":129,"language":12,"meta":8},[73],"const x = 1;\n\n// 1\nfunction outer() {\n    const x = 10;\n    // 2\n    const inner = function() {\n        console.log(x);\n    }\n    return inner;\n}\n\n// 3\nconst innerFunc = outer();\n// 4\ninnerFunc();\n",[131],{"type":18,"tag":77,"props":132,"children":133},{"__ignoreMap":8},[134],{"type":23,"value":129},{"type":18,"tag":19,"props":136,"children":137},{},[138],{"type":23,"value":139},"outer 함수를 호출(3)하면 outer 함수는 중첩 함수 inner를 반환하고 생명 주기를 마감한다. 즉 outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거된다. 이러면 otuer에 x는 생명 주기를 마감하고 따라서 outer함수에 x는 더는 유효하지 않고 접근할 방법이 없어 보인다.",{"type":18,"tag":19,"props":141,"children":142},{},[143],{"type":23,"value":144},"근데 실행결과(4)를 보면 10이 호출되는걸 볼 수 있다. 마치 outer 함수에 x가 부활이라도 한 듯",{"type":18,"tag":19,"props":146,"children":147},{},[148],{"type":23,"value":149},"이처럼 외부 함수보다 중첨 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라고 부른다.",{"type":18,"tag":19,"props":151,"children":152},{},[153],{"type":23,"value":28},{"type":18,"tag":19,"props":155,"children":156},{},[157],{"type":23,"value":158},"outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거되지만 outer 함수의 렉시컬 환경까지 소멸하는 것은 아니다.",{"type":18,"tag":19,"props":160,"children":161},{},[162],{"type":23,"value":163},"outer 함수의 렉시컬 환경은 inner 함수의 [[Environment]] 내부 슬롯에 의해 참조되고 있고 inner 함수는 전역 변수 innerFunc에 의해 참조되고 있으므로 가비지 컬렉션의 대상이 되지 않기 때문이다. 가비지 컬렉터는 누군가 참조하고 있는 메로리 공간을 함부로 해제하지 않는다.",{"type":18,"tag":19,"props":165,"children":166},{},[167],{"type":23,"value":28},{"type":18,"tag":19,"props":169,"children":170},{},[171],{"type":23,"value":172},"자세한 동작 그림은 책에서",{"type":18,"tag":58,"props":174,"children":176},{"id":175},"클로저의-활용",[177],{"type":23,"value":178},"클로저의 활용",{"type":18,"tag":19,"props":180,"children":181},{},[182],{"type":23,"value":183},"클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다. 다시 말해, 상태가 의도치 않게 변경되지 않도록 상태를 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.",{"type":18,"tag":19,"props":185,"children":186},{},[187],{"type":23,"value":28},{"type":18,"tag":19,"props":189,"children":190},{},[191],{"type":23,"value":192},"다음과 같은 코드가 있다.",{"type":18,"tag":70,"props":194,"children":197},{"className":195,"code":196,"language":12,"meta":8},[73],"let num = 0;\n\nconst increase = function () {\n    return ++num;\n}\n\nconsole.log(increase()); // 1\nconsole.log(increase()); // 2\nconsole.log(increase()); // 3\n",[198],{"type":18,"tag":77,"props":199,"children":200},{"__ignoreMap":8},[201],{"type":23,"value":196},{"type":18,"tag":19,"props":203,"children":204},{},[205],{"type":23,"value":206},"이 코드는 좋지 않은 코드다.",{"type":18,"tag":208,"props":209,"children":210},"ol",{},[211,217],{"type":18,"tag":212,"props":213,"children":214},"li",{},[215],{"type":23,"value":216},"num은 increase 함수가 호출되기 전까지 변경되지 않고 유지되어야 한다.",{"type":18,"tag":212,"props":218,"children":219},{},[220],{"type":23,"value":221},"이를 위해 num 변수는 increase 함수만이 변경할 수 있어야 한다.",{"type":18,"tag":19,"props":223,"children":224},{},[225],{"type":23,"value":226},"하지만 전역 변수이기 때문에 누구나 접근하고 변경할 수 있다.",{"type":18,"tag":19,"props":228,"children":229},{},[230],{"type":23,"value":28},{"type":18,"tag":19,"props":232,"children":233},{},[234],{"type":23,"value":235},"전역 변수 num를 increase 함수의 지역 변수로 바꾸어 의도치 않는 상태 변경을 방지해보자.",{"type":18,"tag":70,"props":237,"children":240},{"className":238,"code":239,"language":12,"meta":8},[73],"const increase = function() {\n    let num = 0;\n    \n    return ++num;\n}\n\nconsole.log(increase()); // 1\nconsole.log(increase()); // 1\nconsole.log(increase()); // 1\n",[241],{"type":18,"tag":77,"props":242,"children":243},{"__ignoreMap":8},[244],{"type":23,"value":239},{"type":18,"tag":19,"props":246,"children":247},{},[248],{"type":23,"value":249},"num 변수가 안전하긴 하지만 함수가 호출 될 때마다 지역 변수 num은 다시 선언되고 0으로 초기화 되기 때문에 출력 결과는 언제나 1이다. 다시 말해 상태가 변경되기 이전 상태를 유지하지 못한다. 이전 상태를 유지할 수 있도록 클로저를 사용해보자.",{"type":18,"tag":70,"props":251,"children":254},{"className":252,"code":253,"language":12,"meta":8},[73],"const increase = (function() {\n    let num = 0;\n    \n    // 클로저\n    return function () {\n        return ++num;\n    }\n}())\n\nconsole.log(increase()); // 1\nconsole.log(increase()); // 2\nconsole.log(increase()); // 3\n",[255],{"type":18,"tag":77,"props":256,"children":257},{"__ignoreMap":8},[258],{"type":23,"value":253},{"type":18,"tag":19,"props":260,"children":261},{},[262,264,270],{"type":23,"value":263},"즉시 실행 함수가 실행되고, 즉시 실행 함수가 반환한 함수가 increase 변수에 할당된다. increase 변수에 할당된 함수는 자신이 정의된 위치에 의해 결정된 상위 스코프인 ",{"type":18,"tag":265,"props":266,"children":267},"strong",{},[268],{"type":23,"value":269},"즉시 실행 함수의 렉시컬 환경을 기억하는 클로저",{"type":23,"value":271},"다.",{"type":18,"tag":19,"props":273,"children":274},{},[275],{"type":23,"value":276},"즉시 실행 함수는 호출된 이후 소멸되지만 즉시 실행 함수가 반환한 클로저는 increase 변수에 할당되어 호출된다. 이때 즉시 실행 함수가 반환한 클로저는 자신이 정의된 위치에 의해 결정된 상위 스코프인 즉시 실행 함수의 렉시컬 환경을 기억하고 있다. 따라서 즉시 실행 함수가 반환한 클로저는 카운트 상태를 유지하기 위한 자유 변수 num을 언제 어디서 호출하든지 참조하고 변경할 수 있다.",{"type":18,"tag":19,"props":278,"children":279},{},[280],{"type":23,"value":281},"이처럼 클로저는 상태가 의도치 않게 변경되지 않도록 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하여 상태를 안전하게 변경하고 유지하기 위해 사용한다.",{"type":18,"tag":58,"props":283,"children":285},{"id":284},"캡슐화와-정보-은닉",[286],{"type":23,"value":287},"캡슐화와 정보 은닉",{"type":18,"tag":19,"props":289,"children":290},{},[291],{"type":23,"value":292},"캡슐화는 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것을 말한다. 캡슐화는 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는데 이를 정보 은닉이라 한다.",{"type":18,"tag":19,"props":294,"children":295},{},[296],{"type":23,"value":297},"정보 은닉은 외부에 공개할 필요가 없는 구현의 일부를 외부에 공개되지 않도록 감추어 적절치 못한 접근으로부터 객체의 상태가 변경되는 것을 방지해 정보를 보호하고, 객체 간의 상호 의존성, 즉 결합도를 낮추는 효과가 있다.",{"type":18,"tag":70,"props":299,"children":302},{"className":300,"code":301,"language":12,"meta":8},[73],"const Person(function() {\n    let _age = 0; // private\n    \n    function Person(name, age) {\n        this.name = name; // public\n        _age = age;\n    }\n    \n    Person.prototype.sayHi = function() {\n        console.log(`Hi! My name is ${this.name}. I am ${_age}`);\n    }\n    \n    return Person;\n}());\n\nconst me = new Person(\"Lee\", 20);\nme.sayHi(); // Hi! My name is Lee. I am 20\nconst you = new Person(\"Kim\", 30);\nyou.sayHi(); // Hi! My name is Lee. I am 30\n",[303],{"type":18,"tag":77,"props":304,"children":305},{"__ignoreMap":8},[306],{"type":23,"value":301},{"type":18,"tag":19,"props":308,"children":309},{},[310],{"type":23,"value":28},{"type":18,"tag":19,"props":312,"children":313},{},[314],{"type":23,"value":315},"위 패턴을 사용하면 public, private, protected 같은 접근 제한자를 제공하지 않느 자바스크립트에서도 정보 은닉이 가능한 것처럼 보인다.",{"type":18,"tag":19,"props":317,"children":318},{},[319],{"type":23,"value":320},"하지만 위 코드도 문제가 있다. Person 생성자 함수가 여러 개의 인스턴스를 생성할 경우 _age 변수의 상태가 유지 되지 않는다는 것이다.",{"type":18,"tag":19,"props":322,"children":323},{},[324],{"type":23,"value":325},"다시 me.sayHi()를 호출하면",{"type":18,"tag":70,"props":327,"children":330},{"className":328,"code":329,"language":12,"meta":8},[73],"me.sayHi(); // Hi! My name is Lee. I am 30\n",[331],{"type":18,"tag":77,"props":332,"children":333},{"__ignoreMap":8},[334],{"type":23,"value":329},{"type":18,"tag":19,"props":336,"children":337},{},[338],{"type":23,"value":339},"me의 age가 바뀐걸 볼수 있다.",{"type":18,"tag":19,"props":341,"children":342},{},[343],{"type":23,"value":344},"이처럼 자바스크립트는 정보 은닉을 완전하게 지원하지 않는다.",{"type":18,"tag":19,"props":346,"children":347},{},[348],{"type":23,"value":28},{"type":18,"tag":19,"props":350,"children":351},{},[352],{"type":23,"value":353},"! 현재 최신 문법에서는 #을 사용하여 private를 지원하고 있다",{"type":18,"tag":70,"props":355,"children":358},{"className":356,"code":357,"language":12,"meta":8},[73],"class Person {\n    #age = 0;\n}\n",[359],{"type":18,"tag":77,"props":360,"children":361},{"__ignoreMap":8},[362],{"type":23,"value":357},{"type":18,"tag":58,"props":364,"children":366},{"id":365},"자주-발생하는-실수",[367],{"type":23,"value":368},"자주 발생하는 실수",{"type":18,"tag":70,"props":370,"children":373},{"className":371,"code":372,"language":12,"meta":8},[73],"var funcs = [];\n\nfor (var i = 0; i \u003C 3; i++) {\n    funcs[i] = function() { return i };\n}\nfor (var j = 0; j \u003C funcs.length; j++) {\n    console.log(funcs[j]()); \n}\n\noutput:\n3\n3\n3\n",[374],{"type":18,"tag":77,"props":375,"children":376},{"__ignoreMap":8},[377],{"type":23,"value":372},{"type":18,"tag":19,"props":379,"children":380},{},[381],{"type":23,"value":382},"var는 함수 레벨 스코프만 갖기 때문에 전역 변수다.",{"type":18,"tag":19,"props":384,"children":385},{},[386],{"type":23,"value":28},{"type":18,"tag":19,"props":388,"children":389},{},[390],{"type":23,"value":391},"클로저를 사용해 보자",{"type":18,"tag":70,"props":393,"children":396},{"className":394,"code":395,"language":12,"meta":8},[73],"var funcs = [];\n\nfor (var i = 0; i \u003C 3; i++) {\n    funcs[i] = (function(id) {\n       return function() {\n        return id;\n       } \n    }(i));\n}\nfor (var j = 0; j \u003C funcs.length; j++) {\n    console.log(funcs[j]());\n}\n\noutput:\n0\n1\n2\n",[397],{"type":18,"tag":77,"props":398,"children":399},{"__ignoreMap":8},[400],{"type":23,"value":395},{"type":18,"tag":19,"props":402,"children":403},{},[404],{"type":23,"value":405},"자세한 동작 흐름은 교재 참고",{"type":18,"tag":19,"props":407,"children":408},{},[409],{"type":23,"value":28},{"type":18,"tag":19,"props":411,"children":412},{},[413],{"type":23,"value":414},"근데 let을 쓰면 깔끔하게 해결할수 있다.",{"type":18,"tag":70,"props":416,"children":419},{"className":417,"code":418,"language":12,"meta":8},[73],"var funcs = [];\n\nfor (let i = 0; i \u003C 3; i++) {\n    funcs[i] = function() { return i };\n}\nfor (let i = 0; i \u003C funcs.length; i++) {\n    console.log(funcs[i]()); \n}\n\noutput:\n0\n1\n2\n",[420],{"type":18,"tag":77,"props":421,"children":422},{"__ignoreMap":8},[423],{"type":23,"value":418},{"type":18,"tag":19,"props":425,"children":426},{},[427],{"type":23,"value":28},{"title":8,"searchDepth":429,"depth":429,"links":430},2,[],"markdown","content:posts:2c99fd61-ec92-45ab-993c-7bd3c85dbfc8.md","content","posts/2c99fd61-ec92-45ab-993c-7bd3c85dbfc8.md","md",{"_path":437,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":438,"description":439,"tags":440,"date":441,"body":442,"_type":431,"_id":977,"_source":433,"_file":978,"_extension":435},"/posts/c1c34454-3dfe-4bbf-bea0-97b3cfc73165","자바스크립트 - 19. 실행 컨텍스트","실행 컨텍스트는 자바스크립트의 동작 원리를 담고 있는 핵심 개념",[12],"2024-02-28T00:00:00.000Z",{"type":15,"children":443,"toc":975},[444,448,454,459,464,468,473,479,484,505,510,514,519,523,532,537,542,548,553,562,640,645,663,667,679,689,693,705,717,722,731,736,793,798,803,808,813,818,822,827,831,852,858,915,919,924,930,939,943,948,953,957,962,966,971],{"type":18,"tag":19,"props":445,"children":446},{},[447],{"type":23,"value":439},{"type":18,"tag":58,"props":449,"children":451},{"id":450},"소스코드-타입",[452],{"type":23,"value":453},"소스코드 타입",{"type":18,"tag":19,"props":455,"children":456},{},[457],{"type":23,"value":458},"4가지 타입으로 구분",{"type":18,"tag":19,"props":460,"children":461},{},[462],{"type":23,"value":463},"전역 코드, 함수 코드, eval 코드, 모듈 코드",{"type":18,"tag":19,"props":465,"children":466},{},[467],{"type":23,"value":28},{"type":18,"tag":19,"props":469,"children":470},{},[471],{"type":23,"value":472},"여기서 주의깊게 볼것은 전역 코드와 함수 코드, 전역 코드는 전역 실행 컨텍스트를 생성하고 함수 코드는 함수 실행 컨텍스트를 생성한다.",{"type":18,"tag":58,"props":474,"children":476},{"id":475},"소스코드의-평가와-실행",[477],{"type":23,"value":478},"소스코드의 평가와 실행",{"type":18,"tag":19,"props":480,"children":481},{},[482],{"type":23,"value":483},"모든 소스코드는 실행에 앞서 평가 과정을 거치며 코드를 실행하기 위한 준비를 한다.",{"type":18,"tag":19,"props":485,"children":486},{},[487,489,495,497,503],{"type":23,"value":488},"소스코드 평가 과정에서 ",{"type":18,"tag":77,"props":490,"children":492},{"className":491},[],[493],{"type":23,"value":494},"실행 컨텍스트를 생성",{"type":23,"value":496},"하고 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 ",{"type":18,"tag":77,"props":498,"children":500},{"className":499},[],[501],{"type":23,"value":502},"스코프(렉시컬 환경의 환경 레코드)",{"type":23,"value":504},"에 등록한다.",{"type":18,"tag":19,"props":506,"children":507},{},[508],{"type":23,"value":509},"평가 과정이 끝나면 소스코드가 순차적으로 실행. 즉 런타임이 시작된다. 이때 소스코드 실행(변수에 값을 할당 등)시 실행 컨텍스트가 관리하는 스코프에서 검색해서 취득하고 할당한다.",{"type":18,"tag":19,"props":511,"children":512},{},[513],{"type":23,"value":28},{"type":18,"tag":19,"props":515,"children":516},{},[517],{"type":23,"value":518},"그러니까 쉽게 자바스크립트 실행하면 소스코드를 한줄한줄 실행하기에 앞서 소스코드를 먼저 평가해 이때 실행컨텍스트 생성하고 여기 안에 렉시컬 환경이 구성되고, 이 렉시컬 환경에 변수나 함수 식별자 등록을 해. 그다음에 소스코드 실행 단계(소스코드 한줄한줄 실행, 즉 런타임)에서 실행컨텍스트 가져와서 렉시컬환경 안에 식별자 검색한다음 값을 할당해",{"type":18,"tag":19,"props":520,"children":521},{},[522],{"type":23,"value":28},{"type":18,"tag":70,"props":524,"children":527},{"className":525,"code":526,"language":12,"meta":8},[73],"var x;\nx = 1;\n",[528],{"type":18,"tag":77,"props":529,"children":530},{"__ignoreMap":8},[531],{"type":23,"value":526},{"type":18,"tag":19,"props":533,"children":534},{},[535],{"type":23,"value":536},"이런 코드가 있을때",{"type":18,"tag":19,"props":538,"children":539},{},[540],{"type":23,"value":541},"자바스크립트는 평가단계에서 전역 실행컨텍스트 생성하고 여기에 렉시컬 환경이 구성이 돼, 그리고 렉시컬 환경에 x 식별자 등록하고 undeinfed 할당(var 변수라서), 실행단계에서 전역 실행컨텍스트 안에 렉시컬 환경에 x 있는지 찾아서 x에 1 할당",{"type":18,"tag":58,"props":543,"children":545},{"id":544},"실행-컨텍스트의-역할",[546],{"type":23,"value":547},"실행 컨텍스트의 역할",{"type":18,"tag":19,"props":549,"children":550},{},[551],{"type":23,"value":552},"다음 코드는 자바스크립트 엔진이 어떻게 평가하고 실행할까?",{"type":18,"tag":70,"props":554,"children":557},{"className":555,"code":556,"language":12,"meta":8},[73],"const x = 1;\nconst y = 2;\n\nfunction foo(a) {\n    const x = 10;\n    const y = 20;\n    \n    console.log(a + x + y);\n}\n\nfoo(100);\n\nconsole.log(x + y);\n",[558],{"type":18,"tag":77,"props":559,"children":560},{"__ignoreMap":8},[561],{"type":23,"value":556},{"type":18,"tag":208,"props":563,"children":564},{},[565,581,596,611],{"type":18,"tag":212,"props":566,"children":567},{},[568,570,574,576,579],{"type":23,"value":569},"전역 코드 평가",{"type":18,"tag":571,"props":572,"children":573},"br",{},[],{"type":23,"value":575},"선언문만 먼저 실행",{"type":18,"tag":571,"props":577,"children":578},{},[],{"type":23,"value":580},"전역 변수(const x, y), 전역 함수(foo)가 실행 컨텍스트가 관리하는 전역 스코프에 등록 됨",{"type":18,"tag":212,"props":582,"children":583},{},[584,586,589,591,594],{"type":23,"value":585},"전역 코드 실행",{"type":18,"tag":571,"props":587,"children":588},{},[],{"type":23,"value":590},"전역 코드가 순차적으로 실행, 이때 전역 변수(const x, y)에 값이 할당되고 함수가 호출(foo(100))됨",{"type":18,"tag":571,"props":592,"children":593},{},[],{"type":23,"value":595},"순차적으로 실행되던 전역 코드의 실행을 일시 중단, 함수 내부로 진입",{"type":18,"tag":212,"props":597,"children":598},{},[599,601,604,606,609],{"type":23,"value":600},"함수 코드 평가",{"type":18,"tag":571,"props":602,"children":603},{},[],{"type":23,"value":605},"매개변수와 지역 선언문이 먼저 실행되고, 실행 컨텍스트가 관리하는 지역 스코프에 등록된다.",{"type":18,"tag":571,"props":607,"children":608},{},[],{"type":23,"value":610},"함수 내부에서 지역 변수처럼 사용할 수 있는 arguments 객체가 생성되어 지역 스코프에 등록되고 this 바인딩도 결정된다.",{"type":18,"tag":212,"props":612,"children":613},{},[614,616,619,621,624,626,629,631,634,636,639],{"type":23,"value":615},"함수 코드 실행",{"type":18,"tag":571,"props":617,"children":618},{},[],{"type":23,"value":620},"함수 코드가 순차적으로 실행되기 시작, 이때 매개변수와 지역 변수에 값이 할당되고 console.log 메서드가 호출된다.",{"type":18,"tag":571,"props":622,"children":623},{},[],{"type":23,"value":625},"console.log 메서드를 호출하기 위해 먼저 식별자인 console을 스코프 체인을 통해 검색한다.",{"type":18,"tag":571,"props":627,"children":628},{},[],{"type":23,"value":630},"a,x,y 식별자는 스코프 체인을 통해 검색한다.",{"type":18,"tag":571,"props":632,"children":633},{},[],{"type":23,"value":635},"console.log 실행이 종료되면 함수 코드 실행 과정이 종료되고 함수 호출 이전으로 되돌아가 전역 코드 실행을 계속한다.",{"type":18,"tag":571,"props":637,"children":638},{},[],{"type":23,"value":28},{"type":18,"tag":19,"props":641,"children":642},{},[643],{"type":23,"value":644},"함수 호출이 종료되면 함수 호출 이전으로 되돌아가기 위해 현재 실행중인 코드와 이전에 실행하던 코드를 구분하여 관리해야 한다. 이처럼 코드가 실행되려면 다음과 같이 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다.",{"type":18,"tag":208,"props":646,"children":647},{},[648,653,658],{"type":18,"tag":212,"props":649,"children":650},{},[651],{"type":23,"value":652},"선언에 의해 생성된 모든 식별자(변수, 함수, 클래스 등)를 스코프를 구분하여 등록하고 상태 변화(식별자에 바인딩된 값의 변화)를 지속적으로 관리할 수 있어야 한다.",{"type":18,"tag":212,"props":654,"children":655},{},[656],{"type":23,"value":657},"스코프는 중첩 관계에 의해 스코프 체인을 형성해야 한다. 즉, 스코프 체인을 통해 상위 스코프로 이동하여 식별자를 검색할 수 있어야 한다.",{"type":18,"tag":212,"props":659,"children":660},{},[661],{"type":23,"value":662},"현재 실행 중인 코드의 실행 순서를 변경(예를 들어, 함수 호출에 의한 실행 순서 변경)할 수 있어야 하며 다시 되돌아갈 수도 있어야 한다.",{"type":18,"tag":19,"props":664,"children":665},{},[666],{"type":23,"value":28},{"type":18,"tag":19,"props":668,"children":669},{},[670,672,677],{"type":23,"value":671},"이 모든 것을 관리하는 것이 바로 ",{"type":18,"tag":265,"props":673,"children":674},{},[675],{"type":23,"value":676},"실행 컨텍스트",{"type":23,"value":678},"다. 실행 컨텍스트는 소스코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.",{"type":18,"tag":19,"props":680,"children":681},{},[682,684],{"type":23,"value":683},"구체적으로 실행 컨텍스트는 ",{"type":18,"tag":265,"props":685,"children":686},{},[687],{"type":23,"value":688},"식별자를 등록하고 관리하는 스코프와 코드 실행 순서를 구현한 내부 메커니즘으로, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.",{"type":18,"tag":19,"props":690,"children":691},{},[692],{"type":23,"value":28},{"type":18,"tag":19,"props":694,"children":695},{},[696,698,703],{"type":23,"value":697},"식별자와 스코프는 실행 컨텍스트의 ",{"type":18,"tag":265,"props":699,"children":700},{},[701],{"type":23,"value":702},"렉시컬 환경",{"type":23,"value":704},"으로 관리하고",{"type":18,"tag":19,"props":706,"children":707},{},[708,710,715],{"type":23,"value":709},"코드 실행 순서는 ",{"type":18,"tag":265,"props":711,"children":712},{},[713],{"type":23,"value":714},"실행 컨텍스트 스택",{"type":23,"value":716},"으로 관리한다.",{"type":18,"tag":58,"props":718,"children":720},{"id":719},"실행-컨텍스트-스택",[721],{"type":23,"value":714},{"type":18,"tag":70,"props":723,"children":726},{"className":724,"code":725,"language":12,"meta":8},[73],"const x = 1;\n\nfunction foo() {\n    const y = 2;\n    \n    function bar() {\n        const z = 3;\n        console.log(x, y, z);\n    }\n    bar();\n}\nfoo();\n",[727],{"type":18,"tag":77,"props":728,"children":729},{"__ignoreMap":8},[730],{"type":23,"value":725},{"type":18,"tag":19,"props":732,"children":733},{},[734],{"type":23,"value":735},"자바스크립트 엔진은 먼저 전역 코드를 평가하여 전역 실행 컨텍스트를 생성한다. 그리고 함수가 호출되면 함수 코드를 평가하여 함수 실행 컨텍스트를 생성한다. 이때 생성된 실행 컨텍스트는 스택 자료구조로 관리된다.",{"type":18,"tag":208,"props":737,"children":738},{},[739,749,759,769,779],{"type":18,"tag":212,"props":740,"children":741},{},[742,744,747],{"type":23,"value":743},"전역 코드의 평가와 실행",{"type":18,"tag":571,"props":745,"children":746},{},[],{"type":23,"value":748},"전역 실행 컨텍스트를 생성하고, 스택에 푸시, 이때 x와 foo는 전역 실행 컨텍스트에 등록, 전역 코드가 실행되기 시작하여 x에 값이 할당되고 전역 함수 foo가 호출 됨",{"type":18,"tag":212,"props":750,"children":751},{},[752,754,757],{"type":23,"value":753},"foo 함수 코드의 평가와 실행",{"type":18,"tag":571,"props":755,"children":756},{},[],{"type":23,"value":758},"전역 코드의 실행은 일시 중단되고 코드의 제어권이 foo 함수 내부로 이동, 엔진은 foo 함수 내부의 함수 코드를 평가하여 foo 함수 실행 컨텍스트를 생성하고 스택에 푸시, 이때 y와 bar가 foo 함수 실행 컨텍스트에 등록 됨, 이후 foo 함수 코드가 실행되기 시작하여 y에 값이 할당되고 bar가 호출 됨.",{"type":18,"tag":212,"props":760,"children":761},{},[762,764,767],{"type":23,"value":763},"bar 함수 코드의 평가와 실행",{"type":18,"tag":571,"props":765,"children":766},{},[],{"type":23,"value":768},"foo 함수 코드의 실행은 일시 중단되고 코드의 제어권이 bar 함수 내부로 이동, 엔진은 bar 함수 내부의 함수 코드를 평가하여 bar 함수 실행 컨텍스트를 생성하고 스택에 푸시, 이때 z가 bar 함수 실행 컨텍스트에 등록 됨, 이후 bar 함수 코드가 실행되기 시작하며 x에 값이 할당되고 console.log 가 호출되고 bar 함수는 종료",{"type":18,"tag":212,"props":770,"children":771},{},[772,774,777],{"type":23,"value":773},"foo 함수 코드로 복귀",{"type":18,"tag":571,"props":775,"children":776},{},[],{"type":23,"value":778},"bar 함수가 종료되면 코드의 제어권이 foo 함수로 이동. bar 함수 실행 컨텍스트는 스택에서 제거, 그리고 foo 함수는 더 이상 실행할 코드가 없으므로 종료",{"type":18,"tag":212,"props":780,"children":781},{},[782,784,787,789,792],{"type":23,"value":783},"전역 코드로 복귀",{"type":18,"tag":571,"props":785,"children":786},{},[],{"type":23,"value":788},"foo 함수가 종료되면 코드의 제어권이 전역 코드로 이동. foo 함수 실행 컨텍스트는 스택에서 제거, 그리고 더 이상 실행할 코드가 남아 있지 않으므로 전역 실행 컨텍스트도 스택에서 제거",{"type":18,"tag":571,"props":790,"children":791},{},[],{"type":23,"value":28},{"type":18,"tag":19,"props":794,"children":795},{},[796],{"type":23,"value":797},"이처럼 실행 컨텍스트 스택은 코드의 실행 순서를 관리",{"type":18,"tag":58,"props":799,"children":801},{"id":800},"렉시컬-환경",[802],{"type":23,"value":702},{"type":18,"tag":19,"props":804,"children":805},{},[806],{"type":23,"value":807},"렉시컬 환경은 식별자와 식별자에 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트다.",{"type":18,"tag":19,"props":809,"children":810},{},[811],{"type":23,"value":812},"실행 컨텍스트 스택이 코드의 실행 순서를 관리한다면",{"type":18,"tag":19,"props":814,"children":815},{},[816],{"type":23,"value":817},"렉시컬 환경은 스코프와 식별자를 관리한다.",{"type":18,"tag":19,"props":819,"children":820},{},[821],{"type":23,"value":28},{"type":18,"tag":19,"props":823,"children":824},{},[825],{"type":23,"value":826},"렉시컬 환경은 키와 값을 갖는 객체 형태의 스코프를 생성하여 식별자를 키로 등록하고 식별자에 바인딩된 값을 관리한다. 즉, 렉시컬 환경은 스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할을 하는 렉시컬 스코프의 실체다.",{"type":18,"tag":19,"props":828,"children":829},{},[830],{"type":23,"value":28},{"type":18,"tag":19,"props":832,"children":833},{},[834,836,842,844,850],{"type":23,"value":835},"렉시컬 환경은 ",{"type":18,"tag":77,"props":837,"children":839},{"className":838},[],[840],{"type":23,"value":841},"환경레코드",{"type":23,"value":843},"와 ",{"type":18,"tag":77,"props":845,"children":847},{"className":846},[],[848],{"type":23,"value":849},"외부 렉시컬 환경에 대한 참조",{"type":23,"value":851}," 두 개의 컴포넌트로 구성된다.",{"type":18,"tag":58,"props":853,"children":855},{"id":854},"실행-컨텍스트의-생성과-식별자-검색-과정",[856],{"type":23,"value":857},"실행 컨텍스트의 생성과 식별자 검색 과정",{"type":18,"tag":208,"props":859,"children":860},{},[861,866],{"type":18,"tag":212,"props":862,"children":863},{},[864],{"type":23,"value":865},"전역 실행 컨텍스트 생성",{"type":18,"tag":212,"props":867,"children":868},{},[869,871],{"type":23,"value":870},"전역 렉시컬 환경 생성\n",{"type":18,"tag":208,"props":872,"children":873},{},[874,900,905],{"type":18,"tag":212,"props":875,"children":876},{},[877,879,885,887],{"type":23,"value":878},"전역 ",{"type":18,"tag":77,"props":880,"children":882},{"className":881},[],[883],{"type":23,"value":884},"환경 레코드",{"type":23,"value":886}," 생성\n",{"type":18,"tag":208,"props":888,"children":889},{},[890,895],{"type":18,"tag":212,"props":891,"children":892},{},[893],{"type":23,"value":894},"객체 환경 레코드 생성",{"type":18,"tag":212,"props":896,"children":897},{},[898],{"type":23,"value":899},"선언적 환경 레코드 생성",{"type":18,"tag":212,"props":901,"children":902},{},[903],{"type":23,"value":904},"this 바인딩",{"type":18,"tag":212,"props":906,"children":907},{},[908,913],{"type":18,"tag":77,"props":909,"children":911},{"className":910},[],[912],{"type":23,"value":849},{"type":23,"value":914}," 결정",{"type":18,"tag":96,"props":916,"children":918},{"src":917},"/blog/images/ca345bf9-261e-448d-8e2e-ca4e689ea546.png",[],{"type":18,"tag":19,"props":920,"children":921},{},[922],{"type":23,"value":923},"각 실행 과정에 대한 자세한 내용은 책 참고 (양이 엄청 많음 ㅠㅠ)",{"type":18,"tag":58,"props":925,"children":927},{"id":926},"실행-컨텍스트와-블록-레벨-스코프",[928],{"type":23,"value":929},"실행 컨텍스트와 블록 레벨 스코프",{"type":18,"tag":70,"props":931,"children":934},{"className":932,"code":933,"language":12,"meta":8},[73],"let x = 1;\n\nif (true) {\n    let x = 10;\n    console.log(x);\n}\nconsole.log(x);\n",[935],{"type":18,"tag":77,"props":936,"children":937},{"__ignoreMap":8},[938],{"type":23,"value":933},{"type":18,"tag":19,"props":940,"children":941},{},[942],{"type":23,"value":28},{"type":18,"tag":19,"props":944,"children":945},{},[946],{"type":23,"value":947},"if 문의 코드 블록 내에서 let 키워드로 변수가 선언 됨. 따라서 if 문의 코드 블록이 실행되면 if 문의 코드 블록을 위한 블록 레벨 스코프를 생성해야 함.",{"type":18,"tag":19,"props":949,"children":950},{},[951],{"type":23,"value":952},"이를 위해 선언적 환경 레코드(Declarative…)를 갖는 렉시컬 환경을 새롭게 생성",{"type":18,"tag":96,"props":954,"children":956},{"src":955},"/blog/images/7448db6d-6a97-4532-8b36-016fcf50aa5f.png",[],{"type":18,"tag":19,"props":958,"children":959},{},[960],{"type":23,"value":961},"기존에 렉시컬 환경을 교체",{"type":18,"tag":96,"props":963,"children":965},{"src":964},"/blog/images/1beea2ef-9ed4-4209-ae1a-a3603742faab.png",[],{"type":18,"tag":19,"props":967,"children":968},{},[969],{"type":23,"value":970},"코드 블록의 실행이 종료되면 다시 돌림",{"type":18,"tag":96,"props":972,"children":974},{"src":973},"/blog/images/067cf9dc-dcb0-4014-b64f-3cda10ea74cd.png",[],{"title":8,"searchDepth":429,"depth":429,"links":976},[],"content:posts:c1c34454-3dfe-4bbf-bea0-97b3cfc73165.md","posts/c1c34454-3dfe-4bbf-bea0-97b3cfc73165.md",{"_path":980,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":981,"description":982,"tags":983,"date":984,"body":985,"_type":431,"_id":1319,"_source":433,"_file":1320,"_extension":435},"/posts/62b25952-eab1-4faf-b3ec-9b0928301bb6","자바스크립트 - 18. this","this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수(self-referencing variable)다.",[12],"2024-02-26T00:00:00.000Z",{"type":15,"children":986,"toc":1313},[987,991,996,1002,1007,1014,1019,1024,1033,1037,1042,1051,1055,1060,1069,1073,1078,1123,1129,1134,1143,1148,1152,1156,1161,1170,1174,1179,1188,1192,1198,1203,1212,1218,1227,1231,1236,1240,1245,1254,1258,1263,1272,1276,1281,1290,1295,1304],{"type":18,"tag":19,"props":988,"children":989},{},[990],{"type":23,"value":982},{"type":18,"tag":19,"props":992,"children":993},{},[994],{"type":23,"value":995},"자바스크립트 this는 함수가 호출되는 방식에 따라 this에 바인딩될 값, 즉 this 바인딩이 동적으로 결정된다.",{"type":18,"tag":58,"props":997,"children":999},{"id":998},"함수-호출-방식과-this-바인딩",[1000],{"type":23,"value":1001},"함수 호출 방식과 this 바인딩",{"type":18,"tag":19,"props":1003,"children":1004},{},[1005],{"type":23,"value":1006},"렉시컬 스코프와 this 바인딩은 결정 시기가 다르다.",{"type":18,"tag":1008,"props":1009,"children":1011},"h2",{"id":1010},"일반-함수-호출",[1012],{"type":23,"value":1013},"일반 함수 호출",{"type":18,"tag":19,"props":1015,"children":1016},{},[1017],{"type":23,"value":1018},"기본적으로 this에는 전역 객체(global object)가 바인딩된다.",{"type":18,"tag":19,"props":1020,"children":1021},{},[1022],{"type":23,"value":1023},"전역 함수는 물론이고 중첩 함수를 일반 함수로 호출하면 함수 내부의 this에는 전역 객체가 바인딩된다.",{"type":18,"tag":70,"props":1025,"children":1028},{"className":1026,"code":1027,"language":12,"meta":8},[73],"function foo() {\n    console.log(\"foo's this: \", this); // window\n    function bar() {\n        console.log(\"bar's this: \", this); // window\n    }\n    bar();\n}\nfoo();\n",[1029],{"type":18,"tag":77,"props":1030,"children":1031},{"__ignoreMap":8},[1032],{"type":23,"value":1027},{"type":18,"tag":19,"props":1034,"children":1035},{},[1036],{"type":23,"value":28},{"type":18,"tag":19,"props":1038,"children":1039},{},[1040],{"type":23,"value":1041},"메서드(객체 안에 함수) 내에서 정의한 중첩 함수도 일반 함수로 호출되면 중첩 함수 내부의 this에는 전역 객체가 바인딩된다.",{"type":18,"tag":70,"props":1043,"children":1046},{"className":1044,"code":1045,"language":12,"meta":8},[73],"var value = 1;\n\nconst obj = {\n    value: 100,\n    foo() {\n        console.log(this); // {value: 100, foo: f}\n        consoel.log(this.value); // 100\n\n        function bar() {\n            console.log(this); // window\n            console.log(this.value); // 1\n        }\n        bar();\n    }\n}\n",[1047],{"type":18,"tag":77,"props":1048,"children":1049},{"__ignoreMap":8},[1050],{"type":23,"value":1045},{"type":18,"tag":19,"props":1052,"children":1053},{},[1054],{"type":23,"value":28},{"type":18,"tag":19,"props":1056,"children":1057},{},[1058],{"type":23,"value":1059},"콜백 함수가 일반 함수로 호출된다면 콜백 함수 내부의 this에도 전역 객체가 바인딩된다. 어떠한 함수라도 일반 함수로 호출되면 this에 전역 객체가 바인딩된다.",{"type":18,"tag":70,"props":1061,"children":1064},{"className":1062,"code":1063,"language":12,"meta":8},[73],"var value = 1;\n\nconst obj = {\n    value: 100,\n    foo() {\n        console.log(this); // {value: 100, foo: f}\n        setTimeout(function() {\n            console.log(this.value); // 1\n        })\n    }\n}\n",[1065],{"type":18,"tag":77,"props":1066,"children":1067},{"__ignoreMap":8},[1068],{"type":23,"value":1063},{"type":18,"tag":19,"props":1070,"children":1071},{},[1072],{"type":23,"value":28},{"type":18,"tag":19,"props":1074,"children":1075},{},[1076],{"type":23,"value":1077},"메서드 내부의 중첩 함수나 콜백 함수의 this 바인딩을 메서드의 this 바인딩과 일치시키기 위한 방법",{"type":18,"tag":208,"props":1079,"children":1080},{},[1081,1095,1109],{"type":18,"tag":212,"props":1082,"children":1083},{},[1084,1086],{"type":23,"value":1085},"this를 변수에 할당",{"type":18,"tag":70,"props":1087,"children":1090},{"className":1088,"code":1089,"language":12,"meta":8},[73],"var value = 1;\n\nconst obj = {\n    value: 100,\n    foo() {\n        var that = this;\n        setTimeout(function() {\n            console.log(that.value); // 100\n        })\n    }\n}\n",[1091],{"type":18,"tag":77,"props":1092,"children":1093},{"__ignoreMap":8},[1094],{"type":23,"value":1089},{"type":18,"tag":212,"props":1096,"children":1097},{},[1098,1100],{"type":23,"value":1099},"apply, call, bind",{"type":18,"tag":70,"props":1101,"children":1104},{"className":1102,"code":1103,"language":12,"meta":8},[73],"var value = 1;\n\nconst obj = {\n    value: 100,\n    foo() {\n        setTimeout(function() {\n            console.log(this.value); // 100\n        }.bind(this))\n    }\n}\n",[1105],{"type":18,"tag":77,"props":1106,"children":1107},{"__ignoreMap":8},[1108],{"type":23,"value":1103},{"type":18,"tag":212,"props":1110,"children":1111},{},[1112,1114],{"type":23,"value":1113},"화살표 함수",{"type":18,"tag":70,"props":1115,"children":1118},{"className":1116,"code":1117,"language":12,"meta":8},[73],"var value = 1;\n\nconst obj = {\n    value: 100,\n    foo() {\n        setTimeout(() => {\n            console.log(this.value); // 100\n        })\n    }\n}\n",[1119],{"type":18,"tag":77,"props":1120,"children":1121},{"__ignoreMap":8},[1122],{"type":23,"value":1117},{"type":18,"tag":1008,"props":1124,"children":1126},{"id":1125},"메서드-호출",[1127],{"type":23,"value":1128},"메서드 호출",{"type":18,"tag":19,"props":1130,"children":1131},{},[1132],{"type":23,"value":1133},"메서드 내부의 this에는 메서드를 호출한 객체, 즉 메서드를 호출할 때 메서드 이름 앞의 마침표(.) 연산자 앞에 기술한 객체가 바인딩된다. 주의할 것은 메서드 내부의 this는 메서드를 소유한 객체가 아닌 메서드를 호출한 객체에 바인딩된다는 것이다.",{"type":18,"tag":70,"props":1135,"children":1138},{"className":1136,"code":1137,"language":12,"meta":8},[73],"const person = {\n    name: 'Lee',\n    getName() {\n        return this.name;\n    }\n}\nconsole.log(person.getName());\n",[1139],{"type":18,"tag":77,"props":1140,"children":1141},{"__ignoreMap":8},[1142],{"type":23,"value":1137},{"type":18,"tag":19,"props":1144,"children":1145},{},[1146],{"type":23,"value":1147},"오해하면 안되는게 getName의 함수 객체는 person의 포함된게 아니라 독립적으로 존재하는 별도의 객체(메모리에 별도로)다. getName 프로퍼티가 함수 객체를 가리키고 있을 뿐이다.",{"type":18,"tag":96,"props":1149,"children":1151},{"src":1150},"/blog/images/4d07cbfb-5696-49de-baab-938cabed5271.png",[],{"type":18,"tag":19,"props":1153,"children":1154},{},[1155],{"type":23,"value":28},{"type":18,"tag":19,"props":1157,"children":1158},{},[1159],{"type":23,"value":1160},"따라서 getName 프로퍼티가 가리키는 함수 객체, 즉 getName 메서드는 다른 객체의 프로퍼티에 할당하는 것으로 다른 객체의 메서드가 될 수도 있고 일반 변수에 할당하여 일반 함수로 호출될 수도 있다.",{"type":18,"tag":70,"props":1162,"children":1165},{"className":1163,"code":1164,"language":12,"meta":8},[73],"const person = {\n  name: 'Lee',\n  getName() {\n    return this.name;\n  }\n}\nconst annotherPerson = {\n  name: 'kim'\n}\nannotherPerson.getName = person.getName;\nconsole.log(annotherPerson.getName()); // kim\n\nlet getName = person.getName;\nconsole.log(getName()); // ''\n",[1166],{"type":18,"tag":77,"props":1167,"children":1168},{"__ignoreMap":8},[1169],{"type":23,"value":1164},{"type":18,"tag":19,"props":1171,"children":1172},{},[1173],{"type":23,"value":28},{"type":18,"tag":19,"props":1175,"children":1176},{},[1177],{"type":23,"value":1178},"프로토타입 메서드 내부에서 사용된 this도 일반 메서드와 마찬가지로 해당 메서드를 호출한 객체에 바인딩된다.",{"type":18,"tag":70,"props":1180,"children":1183},{"className":1181,"code":1182,"language":12,"meta":8},[73],"function Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.getName = funciton() {\n    return this.name;\n};\n\nconst me = new Person('Lee');\n\nconsole.log(me.getName()); // Lee\n\nPerson.prototype.name = \"kim\";\nconsole.log(person.prototype.getName()); // kim\n",[1184],{"type":18,"tag":77,"props":1185,"children":1186},{"__ignoreMap":8},[1187],{"type":23,"value":1182},{"type":18,"tag":19,"props":1189,"children":1190},{},[1191],{"type":23,"value":28},{"type":18,"tag":1008,"props":1193,"children":1195},{"id":1194},"생성자-함수-호출",[1196],{"type":23,"value":1197},"생성자 함수 호출",{"type":18,"tag":19,"props":1199,"children":1200},{},[1201],{"type":23,"value":1202},"생성자 함수 내부의 this에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩된다.",{"type":18,"tag":70,"props":1204,"children":1207},{"className":1205,"code":1206,"language":12,"meta":8},[73],"function Circle(radius) {\n    this.radius = radius;\n    this.getDiameter = function() {\n        return 2 * this.radius;\n    }\n}\n\nconst circle1 = new Circle(5);\n\n// 만약 new 연산자와 함께 호출하지 않으면 생성자 함수로 동작하지 않는다. 일반적인 함수의 호출이다.\nconst circle2 = Circle(15); // 이때 this는 window이므로 window.radius = 15가 된다.\nconsole.log(radius); // 15\n",[1208],{"type":18,"tag":77,"props":1209,"children":1210},{"__ignoreMap":8},[1211],{"type":23,"value":1206},{"type":18,"tag":1008,"props":1213,"children":1215},{"id":1214},"funcitonprototypeapplycallbind-메서드에-의한-간접-호출",[1216],{"type":23,"value":1217},"Funciton.prototype.apply/call/bind 메서드에 의한 간접 호출",{"type":18,"tag":70,"props":1219,"children":1222},{"className":1220,"code":1221,"language":12,"meta":8},[73],"function getThisBinding() {\n    return this;\n}\nconst thisArg = { a: 1 };\n\nconsole.log(getThisBinding()); // window\n\nconsole.log(getThisBinding.call(thisArg)); // {a: 1};\nconsole.log(getThisBinding.apply(thisArg)); // {a: 1};\n",[1223],{"type":18,"tag":77,"props":1224,"children":1225},{"__ignoreMap":8},[1226],{"type":23,"value":1221},{"type":18,"tag":19,"props":1228,"children":1229},{},[1230],{"type":23,"value":28},{"type":18,"tag":19,"props":1232,"children":1233},{},[1234],{"type":23,"value":1235},"apply와 call 메서드의 본질적인 기능은 함수를 호출하는 것이다. apply와 call 메서드는 함수를 호출하면서 첫 번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩한다.",{"type":18,"tag":19,"props":1237,"children":1238},{},[1239],{"type":23,"value":28},{"type":18,"tag":19,"props":1241,"children":1242},{},[1243],{"type":23,"value":1244},"apply와 call은 인수를 전달하는 방식만 다를뿐 동일하게 동작한다.",{"type":18,"tag":70,"props":1246,"children":1249},{"className":1247,"code":1248,"language":12,"meta":8},[73],"function getThisBinding() {\n    console.log(arguments);\n    return this;\n}\n\nconst thisArg = {a: 1};\n\nconsole.log(getThisBinding.apply(thisArg, [1, 2, 3]);\nconsole.log(getThisBinding.call(thisArg, 1, 2, 3);\n",[1250],{"type":18,"tag":77,"props":1251,"children":1252},{"__ignoreMap":8},[1253],{"type":23,"value":1248},{"type":18,"tag":19,"props":1255,"children":1256},{},[1257],{"type":23,"value":28},{"type":18,"tag":19,"props":1259,"children":1260},{},[1261],{"type":23,"value":1262},"대표적인 용도는 arguments 객체와 같은 유사 배열 객체에 배열 메서드를 사용하는 경우다. arguments 객체는 배열이 아니기 때문에 Array.prototype.slice 같은 배열의 메서드를 사용할 수 없으나 apply와 call 메서드를 이용하면 가능하다.",{"type":18,"tag":70,"props":1264,"children":1267},{"className":1265,"code":1266,"language":12,"meta":8},[73],"function convertArgsToArray() {\n    const arr = Array.prototype.slice.call(arguments);\n\n    return arr;\n}\n",[1268],{"type":18,"tag":77,"props":1269,"children":1270},{"__ignoreMap":8},[1271],{"type":23,"value":1266},{"type":18,"tag":19,"props":1273,"children":1274},{},[1275],{"type":23,"value":28},{"type":18,"tag":19,"props":1277,"children":1278},{},[1279],{"type":23,"value":1280},"bind 메서드는 apply와 call 메서드와 달리 함수를 호출하지 않고 this로 사용할 객체만 전달한다.",{"type":18,"tag":70,"props":1282,"children":1285},{"className":1283,"code":1284,"language":12,"meta":8},[73],"function getThisBinding() {\n    return this;\n}\n\nconst thisArg = {a:1};\n\nconsole.log(getThisBinding.bind(thisArg)); // getThisBinding\nconsole.log(getThisBidning.bind(thisArg)()); // {a:1}\n",[1286],{"type":18,"tag":77,"props":1287,"children":1288},{"__ignoreMap":8},[1289],{"type":23,"value":1284},{"type":18,"tag":19,"props":1291,"children":1292},{},[1293],{"type":23,"value":1294},"bind 메서드는 메서드의 this와 메서드 내부의 중첩 함수 또는 콜백 함수의 this가 불일치하는 문제를 해결하기 위해 유용하게 사용된다.",{"type":18,"tag":70,"props":1296,"children":1299},{"className":1297,"code":1298,"language":12,"meta":8},[73],"const person = {\n    name: 'Lee',\n    foo(callback) {\n        setTimeout(callback, 100);\n    }\n}\nperson.foo(function () {\n    console.log(this); // window\n})\n",[1300],{"type":18,"tag":77,"props":1301,"children":1302},{"__ignoreMap":8},[1303],{"type":23,"value":1298},{"type":18,"tag":70,"props":1305,"children":1308},{"className":1306,"code":1307,"language":12,"meta":8},[73],"const person = {\n    name: 'Lee',\n    foo(callback) {\n        // callback 함수의 this는 여기 this야\n        // bind는 apply와 call과 달리 호출을 하지 않기 때문에 가능\n        setTimeout(callback.bind(this), 100);\n    }\n}\nperson.foo(function () {\n    console.log(this); // {name: 'Lee', foo: f}\n})\n",[1309],{"type":18,"tag":77,"props":1310,"children":1311},{"__ignoreMap":8},[1312],{"type":23,"value":1307},{"title":8,"searchDepth":429,"depth":429,"links":1314},[1315,1316,1317,1318],{"id":1010,"depth":429,"text":1013},{"id":1125,"depth":429,"text":1128},{"id":1194,"depth":429,"text":1197},{"id":1214,"depth":429,"text":1217},"content:posts:62b25952-eab1-4faf-b3ec-9b0928301bb6.md","posts/62b25952-eab1-4faf-b3ec-9b0928301bb6.md",{"_path":1322,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":1323,"description":1324,"tags":1325,"date":1326,"body":1327,"_type":431,"_id":1534,"_source":433,"_file":1535,"_extension":435},"/posts/4820d5e9-d25c-4a0e-b217-82873d3ea748","자바스크립트 - 17. 빌트인 객체","자바스크립트 객체는 크게 3개의 객체로 분류",[12],"2024-02-24T00:00:00.000Z",{"type":15,"children":1328,"toc":1531},[1329,1333,1352,1358,1363,1372,1378,1383,1392,1396,1401,1413,1417,1426,1432,1448,1457,1461,1466,1475,1480,1489,1493,1499,1508,1513,1517,1522],{"type":18,"tag":19,"props":1330,"children":1331},{},[1332],{"type":23,"value":1324},{"type":18,"tag":1334,"props":1335,"children":1336},"ul",{},[1337,1342,1347],{"type":18,"tag":212,"props":1338,"children":1339},{},[1340],{"type":23,"value":1341},"표준 빌트인 객체: ECMAScript 사양에 정의된 객체",{"type":18,"tag":212,"props":1343,"children":1344},{},[1345],{"type":23,"value":1346},"호스트 객체: ECMAScript 사양에 정의되어 있지 않지만 자바스크립트 실행 환경(브라우저 또는 Node.js 환경)에서 추가로 제공하는 객체",{"type":18,"tag":212,"props":1348,"children":1349},{},[1350],{"type":23,"value":1351},"사용자 정의 객체: 사용자가 직접 정의한 객체",{"type":18,"tag":58,"props":1353,"children":1355},{"id":1354},"표준-빌트인-객체",[1356],{"type":23,"value":1357},"표준 빌트인 객체",{"type":18,"tag":19,"props":1359,"children":1360},{},[1361],{"type":23,"value":1362},"Number는 인스턴스 없이 정적으로 호출할 수 있는 정적 메서드를 제공한다.",{"type":18,"tag":70,"props":1364,"children":1367},{"className":1365,"code":1366,"language":12,"meta":8},[73],"const numObj = new Number(1.5);\n\n// toFixed는 Number.prototype의 프로토타입 메서드다\nconsole.log(numObj.toFixed());\n\n// isInteger는 Number의 정적 메서드다.\nconsole.log(Number.isInteger(0.5));\n",[1368],{"type":18,"tag":77,"props":1369,"children":1370},{"__ignoreMap":8},[1371],{"type":23,"value":1366},{"type":18,"tag":58,"props":1373,"children":1375},{"id":1374},"원시값과-래퍼-객체",[1376],{"type":23,"value":1377},"원시값과 래퍼 객체",{"type":18,"tag":19,"props":1379,"children":1380},{},[1381],{"type":23,"value":1382},"문자열이나 숫자, 불리언 등의 원시값이 있는데도 문자열, 숫자, 불리언 객체를 생성하는 String, Number, Boolean 등의 표준 빌트인 생성자 함수가 존재하는 이유는 무엇일까?",{"type":18,"tag":70,"props":1384,"children":1387},{"className":1385,"code":1386,"language":12,"meta":8},[73],"const str = 'hello';\n\n// 원시 타입인 문자열이 프로퍼티와 메서드를 갖고 있는 객체처럼 동작한다.\nconsole.log(str.length); // 5\nconsole.log(str.toUpperCase()); // HELLO\n",[1388],{"type":18,"tag":77,"props":1389,"children":1390},{"__ignoreMap":8},[1391],{"type":23,"value":1386},{"type":18,"tag":19,"props":1393,"children":1394},{},[1395],{"type":23,"value":28},{"type":18,"tag":19,"props":1397,"children":1398},{},[1399],{"type":23,"value":1400},"이는 마침표 표기법으로 접근하면 자바스크립트 엔진이 일시적으로 원시값을 연관된 객체로 변환해 주기 때문이다. 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 돌린다.",{"type":18,"tag":19,"props":1402,"children":1403},{},[1404,1406,1411],{"type":23,"value":1405},"이처럼 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 ",{"type":18,"tag":265,"props":1407,"children":1408},{},[1409],{"type":23,"value":1410},"래퍼 객체",{"type":23,"value":1412},"라 한다.",{"type":18,"tag":19,"props":1414,"children":1415},{},[1416],{"type":23,"value":28},{"type":18,"tag":70,"props":1418,"children":1421},{"className":1419,"code":1420,"language":12,"meta":8},[73],"const str = 'hello';\n\n// 원시 타입인 문자열이 프로퍼티와 메서드를 갖고 있는 객체처럼 동작한다.\nconsole.log(str.length); // 5\nconsole.log(str.toUpperCase()); // HELLO\n\n// 래퍼 객체로 프로퍼티에 접근하거나 메서드를 호출한 후, 다시 원시값으로 되돌린다.\nconsole.log(typeof str); // string\n",[1422],{"type":18,"tag":77,"props":1423,"children":1424},{"__ignoreMap":8},[1425],{"type":23,"value":1420},{"type":18,"tag":58,"props":1427,"children":1429},{"id":1428},"전역-객체",[1430],{"type":23,"value":1431},"전역 객체",{"type":18,"tag":19,"props":1433,"children":1434},{},[1435,1437,1446],{"type":23,"value":1436},"어떤 객체보다도 먼저 생성되는 특수한 객체. 지칭하는 이름이 제각각. 브라우저 환경에서는 window, ",{"type":18,"tag":1438,"props":1439,"children":1443},"a",{"href":1440,"rel":1441},"http://node.sj/",[1442],"nofollow",[1444],{"type":23,"value":1445},"Node",{"type":23,"value":1447},".js 환경에서는 global",{"type":18,"tag":1449,"props":1450,"children":1451},"blockquote",{},[1452],{"type":18,"tag":19,"props":1453,"children":1454},{},[1455],{"type":23,"value":1456},"ES11부터는 통일된 globalThis 식별자를 사용한다.",{"type":18,"tag":19,"props":1458,"children":1459},{},[1460],{"type":23,"value":28},{"type":18,"tag":19,"props":1462,"children":1463},{},[1464],{"type":23,"value":1465},"var 키워드로 선언한 전역 변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역",{"type":18,"tag":70,"props":1467,"children":1470},{"className":1468,"code":1469,"language":12,"meta":8},[73],"// var 키워드로 선언한 전역 변수\nvar foo = 1;\nconsole.log(window.foo); // 1\n\n// bar는 전역 변수가 아니라 전역 객체의 프로퍼티다.\nbar = 2;\nconsole.log(window.bar); // 2\n\nfunction baz() {}\nconsole.log(window.baz());\n",[1471],{"type":18,"tag":77,"props":1472,"children":1473},{"__ignoreMap":8},[1474],{"type":23,"value":1469},{"type":18,"tag":19,"props":1476,"children":1477},{},[1478],{"type":23,"value":1479},"let이나 const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다. 즉, window.foo와 같이 접근할 수 없다. let이나 const 키워드로 선언한 전역 변수는 보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 레코드) 내에 존재하게 된다.",{"type":18,"tag":70,"props":1481,"children":1484},{"className":1482,"code":1483,"language":12,"meta":8},[73],"let foo = 123;\nconsole.log(window.foo); // undefined\n",[1485],{"type":18,"tag":77,"props":1486,"children":1487},{"__ignoreMap":8},[1488],{"type":23,"value":1483},{"type":18,"tag":19,"props":1490,"children":1491},{},[1492],{"type":23,"value":28},{"type":18,"tag":1008,"props":1494,"children":1496},{"id":1495},"암묵적-전역",[1497],{"type":23,"value":1498},"암묵적 전역",{"type":18,"tag":70,"props":1500,"children":1503},{"className":1501,"code":1502,"language":12,"meta":8},[73],"var x = 10;\n\nfunction foo() {\n    y = 20;\n}\n\nfoo();\nconsole.log(x + y); // 20\n",[1504],{"type":18,"tag":77,"props":1505,"children":1506},{"__ignoreMap":8},[1507],{"type":23,"value":1502},{"type":18,"tag":19,"props":1509,"children":1510},{},[1511],{"type":23,"value":1512},"y는 변수 선언 없이 단지 전역 객체의 프로퍼티로 추가되었을 뿐이다. 따라서 y는 변수가 아니다. y는 변수가 아니므로 변수 호이스팅이 발생하지 않는다.",{"type":18,"tag":19,"props":1514,"children":1515},{},[1516],{"type":23,"value":28},{"type":18,"tag":19,"props":1518,"children":1519},{},[1520],{"type":23,"value":1521},"y는 window의 객체의 프로퍼티이니 삭제가 가능하다. 전역 변수는 삭제 불가",{"type":18,"tag":70,"props":1523,"children":1526},{"className":1524,"code":1525,"language":12,"meta":8},[73],"var x = 10;\ny = 20; \nconsole.log(window.x); // 10\nconsole.log(window.y); // 20\ndelete x;\ndelete y;\nconsole.log(window.x); // 10\nconsole.log(window.y); // undefined\n",[1527],{"type":18,"tag":77,"props":1528,"children":1529},{"__ignoreMap":8},[1530],{"type":23,"value":1525},{"title":8,"searchDepth":429,"depth":429,"links":1532},[1533],{"id":1495,"depth":429,"text":1498},"content:posts:4820d5e9-d25c-4a0e-b217-82873d3ea748.md","posts/4820d5e9-d25c-4a0e-b217-82873d3ea748.md",{"_path":1537,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":1538,"description":8,"tags":1539,"date":1540,"body":1541,"_type":431,"_id":2364,"_source":433,"_file":2365,"_extension":435},"/posts/eefbc7dd-a0f6-4078-97f5-9b6f26a483f1","자바스크립트 - 16. 프로토타입",[12],"2024-02-23T00:00:00.000Z",{"type":15,"children":1542,"toc":2343},[1543,1552,1557,1562,1566,1570,1575,1580,1589,1598,1602,1608,1613,1618,1623,1628,1632,1637,1641,1652,1661,1665,1672,1676,1685,1695,1704,1713,1721,1731,1736,1745,1756,1766,1771,1775,1783,1787,1793,1798,1807,1816,1820,1828,1834,1843,1847,1853,1862,1867,1871,1876,1880,1888,1894,1899,1903,1908,1917,1921,1926,1935,1939,1944,1998,2002,2008,2014,2023,2029,2038,2044,2053,2059,2068,2073,2078,2083,2087,2091,2097,2106,2110,2115,2120,2126,2132,2141,2146,2150,2159,2165,2174,2178,2187,2191,2196,2202,2207,2216,2221,2230,2234,2239,2248,2252,2257,2266,2271,2277,2282,2286,2291,2300,2305,2310,2314,2318,2327,2331,2334,2339],{"type":18,"tag":70,"props":1544,"children":1547},{"className":1545,"code":1546,"language":12,"meta":8},[73],"function Circle(radius) {\n    this.radius = radius;\n    this.getArea = function() {\n        return Math.PI * this.radius ** 2;\n    }\n}\n\nconst circle1 = new Circle(1);\nconst circle2 = new Circle(2);\nconsole.log(circle1.getArea());\nconsole.log(circle2.getArea());\n",[1548],{"type":18,"tag":77,"props":1549,"children":1550},{"__ignoreMap":8},[1551],{"type":23,"value":1546},{"type":18,"tag":19,"props":1553,"children":1554},{},[1555],{"type":23,"value":1556},"radius 프로퍼티 값은 일반적으로 인스턴스마다 다르다.",{"type":18,"tag":19,"props":1558,"children":1559},{},[1560],{"type":23,"value":1561},"하지만 getArea 메서드는 모든 인스턴스가 동일한 내용의 메서드를 사용하므로 단 하나만 생성하여 모든 인스턴스가 공유해서 사용하는것이 바람직하다. (메모리를 불필요하게 낭비)",{"type":18,"tag":96,"props":1563,"children":1565},{"src":1564},"/blog/images/5635e786-fc02-4f7e-a3fa-df6d0c2dc43d.png",[],{"type":18,"tag":19,"props":1567,"children":1568},{},[1569],{"type":23,"value":28},{"type":18,"tag":19,"props":1571,"children":1572},{},[1573],{"type":23,"value":1574},"상속을 통해 불필요한 중복을 제거해 보자. 자바스크립트는 프로토타입을 기반으로 상속을 구현한다.",{"type":18,"tag":19,"props":1576,"children":1577},{},[1578],{"type":23,"value":1579},"! 여기서 상속의 개념이 ‘물려 받는다’ 보다는, 자식 객체가 부모 객체의 프로토타입을 참조하여 사용할 수 있다임",{"type":18,"tag":70,"props":1581,"children":1584},{"className":1582,"code":1583,"language":12,"meta":8},[73],"function Circle(radius) {\n    this.radius = radius;\n}\n\nCircle.prototype.getArea = function() {\n    return Math.PI * this.radius ** 2;\n}\n\nconst cirlce1 = new Circle(1);\nconst cirlce2 = new Circle(2);\n\nconsole.log(circle1.getArea());\nconsole.log(circle2.getArea());\n",[1585],{"type":18,"tag":77,"props":1586,"children":1587},{"__ignoreMap":8},[1588],{"type":23,"value":1583},{"type":18,"tag":70,"props":1590,"children":1593},{"className":1591,"code":1592,"language":12,"meta":8},[73],"function Person(name) {\n    this.name = name;\n}\n\nconst me = new Person('Lee');\n\nconsole.log(Person.prototype === me.__proto__); // true\n",[1594],{"type":18,"tag":77,"props":1595,"children":1596},{"__ignoreMap":8},[1597],{"type":23,"value":1592},{"type":18,"tag":96,"props":1599,"children":1601},{"src":1600},"/blog/images/76a0218f-62ef-4fd8-a3d7-e603e4e9cd3a.png",[],{"type":18,"tag":58,"props":1603,"children":1605},{"id":1604},"프로토타입-객체",[1606],{"type":23,"value":1607},"프로토타입 객체",{"type":18,"tag":19,"props":1609,"children":1610},{},[1611],{"type":23,"value":1612},"모든 객체는 [[Prototype]]이라는 내부 슬롯을 가진다.",{"type":18,"tag":19,"props":1614,"children":1615},{},[1616],{"type":23,"value":1617},"객체가 생성될때 객체 생성 방식에 따라 프로토타입이 결정되고 [[Prototype]]에 저장된다.",{"type":18,"tag":19,"props":1619,"children":1620},{},[1621],{"type":23,"value":1622},"예를 들어, 객체 리터럴에 의해 생성된 객체의 프로토타입은 Object.prototype이고",{"type":18,"tag":19,"props":1624,"children":1625},{},[1626],{"type":23,"value":1627},"생성자 함수에 의해 생성된 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체다.",{"type":18,"tag":19,"props":1629,"children":1630},{},[1631],{"type":23,"value":28},{"type":18,"tag":19,"props":1633,"children":1634},{},[1635],{"type":23,"value":1636},"모든 객체는 하나의 프로토타입을 갖는다. 그리고 모든 프로토타입은 생성자 함수와 연결되어 있다.",{"type":18,"tag":19,"props":1638,"children":1639},{},[1640],{"type":23,"value":28},{"type":18,"tag":1008,"props":1642,"children":1644},{"id":1643},"proto-접근자-프로퍼티",[1645,1650],{"type":18,"tag":265,"props":1646,"children":1647},{},[1648],{"type":23,"value":1649},"proto",{"type":23,"value":1651}," 접근자 프로퍼티",{"type":18,"tag":19,"props":1653,"children":1654},{},[1655,1659],{"type":18,"tag":265,"props":1656,"children":1657},{},[1658],{"type":23,"value":1649},{"type":23,"value":1660}," 접근자 프로퍼티를 통해 간접적으로 [[Prototype]] 내부 슬롯의 값에 접근할 수 있다.",{"type":18,"tag":19,"props":1662,"children":1663},{},[1664],{"type":23,"value":28},{"type":18,"tag":1666,"props":1667,"children":1669},"h3",{"id":1668},"__proto__는-접근자-프로퍼티다",[1670],{"type":23,"value":1671},"__proto__는 접근자 프로퍼티다.",{"type":18,"tag":96,"props":1673,"children":1675},{"src":1674},"/blog/images/ee1e5e25-307d-4560-b50c-641663b9125b.png",[],{"type":18,"tag":70,"props":1677,"children":1680},{"className":1678,"code":1679,"language":12,"meta":8},[73],"const obj = {};\nconst parent = { x: 1 };\nobj.__proto__; // get __proto__가 호출됨\nobj.__proto__ = parent; // set __proto__가 호출됨\n\nconsole.log(obj.x);\n",[1681],{"type":18,"tag":77,"props":1682,"children":1683},{"__ignoreMap":8},[1684],{"type":23,"value":1679},{"type":18,"tag":1666,"props":1686,"children":1688},{"id":1687},"proto-접근자-프로퍼티는-상속을-통해-사용된다",[1689,1693],{"type":18,"tag":265,"props":1690,"children":1691},{},[1692],{"type":23,"value":1649},{"type":23,"value":1694}," 접근자 프로퍼티는 상속을 통해 사용된다.",{"type":18,"tag":70,"props":1696,"children":1699},{"className":1697,"code":1698,"language":12,"meta":8},[73],"const person = { name: 'lee' };\n\n// person 객체는 __proto__ 프로퍼티를 소유하지 않는다.\nconsole.log(person.hasOwnProperty('__proto__')); // false\n\n// __proto__ 프로퍼티는 모든 객체의 프로토타입 객체인 Object.prototype의 접근자 프로퍼티다.\nconsole.log(Object.getOwnPropertyDescriptor(Object.prototype, '__proto'));\n// {get: f, set: f, ....}\n\n// 모든 객체는 Object.prototype의 접근자 프로퍼티 __proto__를 상속받아 사용할 수 있다.\nconsole.log({}.__proto__ === Object.prototype); // true\n",[1700],{"type":18,"tag":77,"props":1701,"children":1702},{"__ignoreMap":8},[1703],{"type":23,"value":1698},{"type":18,"tag":70,"props":1705,"children":1708},{"className":1706,"code":1707,"language":12,"meta":8},[73],"const parent = { x: 1 };\nfunction Person() {}\nconsole.log(parent.__proto__ === Object.prototype); // true\nconsole.log(Person.__proto__ === Function.prototype); // true\nconsole.log(Function.__proto__ === Function.prototype); // true\nconsole.log(Function.prototype.__proto__ === Object.prototype); // true\n",[1709],{"type":18,"tag":77,"props":1710,"children":1711},{"__ignoreMap":8},[1712],{"type":23,"value":1707},{"type":18,"tag":1449,"props":1714,"children":1715},{},[1716],{"type":18,"tag":19,"props":1717,"children":1718},{},[1719],{"type":23,"value":1720},"프로토타입 체인의 종점, 즉 프로토타입 체인의 최상위 객체는 Object.prototype이다.",{"type":18,"tag":1666,"props":1722,"children":1724},{"id":1723},"proto-접근자-프로퍼티를-통해-프로토타입에-접근하는-이유",[1725,1729],{"type":18,"tag":265,"props":1726,"children":1727},{},[1728],{"type":23,"value":1649},{"type":23,"value":1730}," 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유",{"type":18,"tag":19,"props":1732,"children":1733},{},[1734],{"type":23,"value":1735},"[[Prototype]] 내부 슬롯의 값, 즉 프로토타입에 접근하기 위해 접근자 프로퍼티를 사용하는 이유는 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해서다.",{"type":18,"tag":70,"props":1737,"children":1740},{"className":1738,"code":1739,"language":12,"meta":8},[73],"const parent = {};\nconst child = {};\n\nchild.__proto__ = parent;\nparent.__proto__ child; // TypeError: Cycle __proto__ value\n",[1741],{"type":18,"tag":77,"props":1742,"children":1743},{"__ignoreMap":8},[1744],{"type":23,"value":1739},{"type":18,"tag":19,"props":1746,"children":1747},{},[1748,1750,1754],{"type":23,"value":1749},"아무런 체크 없이 무조건적으로 프로토타입을 교체할 수 없도록 ",{"type":18,"tag":265,"props":1751,"children":1752},{},[1753],{"type":23,"value":1649},{"type":23,"value":1755}," 접근자 프로퍼티를 통해 프로토타입에 접근하고 교체하도록 구현되어 있다.",{"type":18,"tag":1666,"props":1757,"children":1759},{"id":1758},"proto-접근자-프로퍼티를-코드-내에서-직접-사용하는-것은-권장하지-않는다",[1760,1764],{"type":18,"tag":265,"props":1761,"children":1762},{},[1763],{"type":23,"value":1649},{"type":23,"value":1765}," 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 권장하지 않는다.",{"type":18,"tag":19,"props":1767,"children":1768},{},[1769],{"type":23,"value":1770},"Object.getPrototypeOf나 Object.setPrototypeOf 사용을 권장한다.",{"type":18,"tag":19,"props":1772,"children":1773},{},[1774],{"type":23,"value":28},{"type":18,"tag":1776,"props":1777,"children":1780},"aside",{"emogi":1778,"color":1779},"undefined","purple",[1781],{"type":23,"value":1782},"헐 몰랐어… javascript에서 prototype하고 [[prototype]]은 다른 개념이구나..\n아 ~ 생성자 함수에 의해 생성된 객체들은 [[Prototype]]을 통해 생성자 함수 prototype에 접근 가능하고…\n아~ person.greet()을 하면 person에는 greet 함수가 없으니까 프로토타입 체이닝을 통해 생성한 부모 함수로 가서 찾는거구나…",{"type":18,"tag":19,"props":1784,"children":1785},{},[1786],{"type":23,"value":28},{"type":18,"tag":1008,"props":1788,"children":1790},{"id":1789},"함수-객체의-prototype-프로퍼티",[1791],{"type":23,"value":1792},"함수 객체의 prototype 프로퍼티",{"type":18,"tag":19,"props":1794,"children":1795},{},[1796],{"type":23,"value":1797},"함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.",{"type":18,"tag":70,"props":1799,"children":1802},{"className":1800,"code":1801,"language":12,"meta":8},[73],"// 함수 객체는 prototype 프로퍼티를 소유한다.\n(function() {}).hasOwnProperty('prototype'); // true\n// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.\n({}).hasOwnProperty('prototype'); // false\n",[1803],{"type":18,"tag":77,"props":1804,"children":1805},{"__ignoreMap":8},[1806],{"type":23,"value":1801},{"type":18,"tag":70,"props":1808,"children":1811},{"className":1809,"code":1810,"language":12,"meta":8},[73],"// 화살표 함수는 prototype 프로퍼티를 소유하지 않음\nconst Person = name => {\n    this.name = name;\n}\n\nconsole.log(Person.hasOwnProperty('prototype')); // false\nconsole.log(Person.prototype); // undefined\n\nconst obj = {\n    foo() {}\n}\n\nconsole.log(obj.foo.hasOwnProperty('prototype')); // false\nconsole.log(obj.foo.prototype); // undefined\n",[1812],{"type":18,"tag":77,"props":1813,"children":1814},{"__ignoreMap":8},[1815],{"type":23,"value":1810},{"type":18,"tag":96,"props":1817,"children":1819},{"src":1818},"/blog/images/e10da6c3-936a-49f8-964d-5b3817c9ccf9.png",[],{"type":18,"tag":70,"props":1821,"children":1823},{"className":1822,"code":1592,"language":12,"meta":8},[73],[1824],{"type":18,"tag":77,"props":1825,"children":1826},{"__ignoreMap":8},[1827],{"type":23,"value":1592},{"type":18,"tag":1008,"props":1829,"children":1831},{"id":1830},"프로토타입의-constructor-프로퍼티와-생성자-함수",[1832],{"type":23,"value":1833},"프로토타입의 constructor 프로퍼티와 생성자 함수",{"type":18,"tag":70,"props":1835,"children":1838},{"className":1836,"code":1837,"language":12,"meta":8},[73],"function Person(name) {\n    this.name = name;\n}\nconst me = new Person('Lee');\n\nconsole.log(me.constructor === Person);\n",[1839],{"type":18,"tag":77,"props":1840,"children":1841},{"__ignoreMap":8},[1842],{"type":23,"value":1837},{"type":18,"tag":1844,"props":1845,"children":1846},"hr",{},[],{"type":18,"tag":58,"props":1848,"children":1850},{"id":1849},"리터럴-표기법에-의해-생성된-객체와-생성자-함수와-프로토타입",[1851],{"type":23,"value":1852},"리터럴 표기법에 의해 생성된 객체와 생성자 함수와 프로토타입",{"type":18,"tag":70,"props":1854,"children":1857},{"className":1855,"code":1856,"language":12,"meta":8},[73],"const obj = {};\nconst add = function (a,b) { return a + b };\nconst arr = [1, 2, 3]\nconst regexp = /is/ig;\n",[1858],{"type":18,"tag":77,"props":1859,"children":1860},{"__ignoreMap":8},[1861],{"type":23,"value":1856},{"type":18,"tag":19,"props":1863,"children":1864},{},[1865],{"type":23,"value":1866},"리터럴 표기법에 의해 생성된 객체는 생성자 함수에 의해 생성된 객체는 아니다. 하지만 큰 틀에서 생각해 보면 리터럴 표기법으로 생성한 객체도 생성자 함수로 생성한 객체와 본질적인 면에서는 큰 차이는 없다.",{"type":18,"tag":19,"props":1868,"children":1869},{},[1870],{"type":23,"value":28},{"type":18,"tag":19,"props":1872,"children":1873},{},[1874],{"type":23,"value":1875},"객체 리터럴에 의해 생성된 객체와 Object 생성자 함수에 의해 생성한 객체는 생성 과정에서 미묘한 차이가 있지만 결국 객체로서 동일한 특성을 갖는다. 함수 리터럴에 의해 생성한 함수와 Function 생성자 함수에 의해 생성한 함수는 생성 과정과 스코프, 클로저 등의 차이가 있지만 결국 함수로서 동일한 특성을 갖는다.",{"type":18,"tag":19,"props":1877,"children":1878},{},[1879],{"type":23,"value":28},{"type":18,"tag":19,"props":1881,"children":1882},{},[1883],{"type":18,"tag":265,"props":1884,"children":1885},{},[1886],{"type":23,"value":1887},"객체 리터럴이 평가 될때는 추상 연산 OrdinaryObjectCreate가 호출 되는데 자세한건 교재에",{"type":18,"tag":58,"props":1889,"children":1891},{"id":1890},"프로토타입의-생성-시점",[1892],{"type":23,"value":1893},"프로토타입의 생성 시점",{"type":18,"tag":19,"props":1895,"children":1896},{},[1897],{"type":23,"value":1898},"프로토타입은 생서자 함수가 생성되는 시점에 더불어 생성된다.",{"type":18,"tag":19,"props":1900,"children":1901},{},[1902],{"type":23,"value":28},{"type":18,"tag":19,"props":1904,"children":1905},{},[1906],{"type":23,"value":1907},"생성자 함수로서 호출할 수 있는 함수, 즉 constructor는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.",{"type":18,"tag":70,"props":1909,"children":1912},{"className":1910,"code":1911,"language":12,"meta":8},[73],"console.log(Person.prototype); // constructor: f\n\nfunction Person(name) {\n    this.name = name;\n}\n",[1913],{"type":18,"tag":77,"props":1914,"children":1915},{"__ignoreMap":8},[1916],{"type":23,"value":1911},{"type":18,"tag":19,"props":1918,"children":1919},{},[1920],{"type":23,"value":28},{"type":18,"tag":19,"props":1922,"children":1923},{},[1924],{"type":23,"value":1925},"생성자 함수로서 호출할 수 없는 함수, 즉 non-constructor는 프로토타입이 생성되지 않는다.",{"type":18,"tag":70,"props":1927,"children":1930},{"className":1928,"code":1929,"language":12,"meta":8},[73],"const Person = name => {\n    this.name = name;\n}\n\nconsole.log(Person.prototype); // undefined\n",[1931],{"type":18,"tag":77,"props":1932,"children":1933},{"__ignoreMap":8},[1934],{"type":23,"value":1929},{"type":18,"tag":19,"props":1936,"children":1937},{},[1938],{"type":23,"value":28},{"type":18,"tag":19,"props":1940,"children":1941},{},[1942],{"type":23,"value":1943},"함수 선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행된다고 했다. 평가되어 함수 객체가 될때 이때 프로토타입도 더불어 생성된다. 생성된 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩 된다.",{"type":18,"tag":1945,"props":1946,"children":1947},"details",{},[1948,1954,1956],{"type":18,"tag":1949,"props":1950,"children":1951},"summary",{},[1952],{"type":23,"value":1953},"chatgpt",{"type":23,"value":1955},"\n1. **Person 함수 객체 생성**: 자바스크립트 엔진은 **`Person`** 함수 선언을 평가하면서 **`Person`**이라는 이름의 함수 객체를 생성합니다.\n2. **Person.prototype 객체 생성**: 동시에 **`Person.prototype`** 객체도 생성됩니다. 이 객체는 기본적으로 **`constructor`** 프로퍼티를 가지고 있으며, 이 **`constructor`** 프로퍼티는 **`Person`** 함수 객체를 가리킵니다.\n3. **Person.prototype의 상속**: **`Person.prototype`** 객체는 **`Object.prototype`**을 상속합니다. 다시 말해, **`Person.prototype`**의 [[Prototype]] 내부 슬롯(또는 **`__proto__`** 프로퍼티)은 **`Object.prototype`** 객체를 가리킵니다. 이는 **`Person.prototype`**이 **`Object.prototype`**의 메소드와 프로퍼티에 접근할 수 있음을 의미합니다.\n4. **인스턴스 생성**: **`new Person('Lee')`**와 같이 **`Person`** 함수를 생성자로 사용하여 인스턴스를 생성할 때, 이 인스턴스는 **`Person.prototype`**을 상속받습니다. 즉, 생성된 객체의 [[Prototype]] 내부 슬롯(또는 **`__proto__`** 프로퍼티)는 **`Person.prototype`** 객체를 가리킵니다.\n",{"type":18,"tag":19,"props":1957,"children":1958},{},[1959,1961,1970,1972,1981,1983,1988,1990,1996],{"type":23,"value":1960},"따라서, ",{"type":18,"tag":265,"props":1962,"children":1963},{},[1964],{"type":18,"tag":77,"props":1965,"children":1967},{"className":1966},[],[1968],{"type":23,"value":1969},"Person",{"type":23,"value":1971}," 함수 객체와 ",{"type":18,"tag":265,"props":1973,"children":1974},{},[1975],{"type":18,"tag":77,"props":1976,"children":1978},{"className":1977},[],[1979],{"type":23,"value":1980},"Person.prototype",{"type":23,"value":1982}," 객체는 서로 다른 객체이며, **",{"type":18,"tag":77,"props":1984,"children":1986},{"className":1985},[],[1987],{"type":23,"value":1980},{"type":23,"value":1989},"**은 **",{"type":18,"tag":77,"props":1991,"children":1993},{"className":1992},[],[1994],{"type":23,"value":1995},"Object.prototype",{"type":23,"value":1997},"**을 상속받는 것이 맞습니다. 이러한 구조는 자바스크립트의 프로토타입 체인을 형성하며, 이 체인을 통해 객체는 상속된 프로퍼티와 메소드에 접근할 수 있습니다.",{"type":18,"tag":19,"props":1999,"children":2000},{},[2001],{"type":23,"value":28},{"type":18,"tag":58,"props":2003,"children":2005},{"id":2004},"객체-생성-방식과-프로토타입의-결정",[2006],{"type":23,"value":2007},"객체 생성 방식과 프로토타입의 결정",{"type":18,"tag":1008,"props":2009,"children":2011},{"id":2010},"객체-리터럴에-의해-생성된-객체의-프로토타입",[2012],{"type":23,"value":2013},"객체 리터럴에 의해 생성된 객체의 프로토타입",{"type":18,"tag":70,"props":2015,"children":2018},{"className":2016,"code":2017,"language":12,"meta":8},[73],"const obj = { x: 1 };\n\n// obj에는 constructor와 hasOwnProperty가 없는데 어떻게 동작하는걸까?\n// 그 이유는 obj는 Object.property 객체를 상속 받았기 때문이다.\nconsole.log(obj.constructor); // Object\nconsole.log(obj.hasOwnProperty('x')); \n",[2019],{"type":18,"tag":77,"props":2020,"children":2021},{"__ignoreMap":8},[2022],{"type":23,"value":2017},{"type":18,"tag":1008,"props":2024,"children":2026},{"id":2025},"object-생성자-함수에-의해-생성된-객체의-프로토타입",[2027],{"type":23,"value":2028},"Object 생성자 함수에 의해 생성된 객체의 프로토타입",{"type":18,"tag":70,"props":2030,"children":2033},{"className":2031,"code":2032,"language":12,"meta":8},[73],"const obj = new Object();\nobj.x = 1;\n\n// obj에는 constructor와 hasOwnProperty가 없는데 어떻게 동작하는걸까?\n// 그 이유는 obj는 Object.property 객체를 상속 받았기 때문이다.\nconsole.log(obj.constructor); // Object\nconsole.log(obj.hasOwnProperty('x')); \n",[2034],{"type":18,"tag":77,"props":2035,"children":2036},{"__ignoreMap":8},[2037],{"type":23,"value":2032},{"type":18,"tag":1008,"props":2039,"children":2041},{"id":2040},"생성자-함수에-의해-생성된-객체의-프로토타입",[2042],{"type":23,"value":2043},"생성자 함수에 의해 생성된 객체의 프로토타입",{"type":18,"tag":70,"props":2045,"children":2048},{"className":2046,"code":2047,"language":12,"meta":8},[73],"function Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.sayHello = function() {\n    console.log(this.name);\n}\n\nconst me = new Person('Lee');\nconst you = new Person('Kim');\n\nme.sayHell();\nyou.sayHell();\n",[2049],{"type":18,"tag":77,"props":2050,"children":2051},{"__ignoreMap":8},[2052],{"type":23,"value":2047},{"type":18,"tag":58,"props":2054,"children":2056},{"id":2055},"프로토타입-체인",[2057],{"type":23,"value":2058},"프로토타입 체인",{"type":18,"tag":70,"props":2060,"children":2063},{"className":2061,"code":2062,"language":12,"meta":8},[73],"function Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.sayHello = function() {\n    console.log(this.name);\n}\n\nconst me = new Person('Lee');\nconst you = new Person('Kim');\n\n// hasOwnProperty는 Object.prototype의 메서드다.\n// me 객체는 프로토타입 체인을 따라 hasOwnProperty 메서드를 검색하여 사용한다.\nconsole.log(me.hasOwnProperty('name'));\n",[2064],{"type":18,"tag":77,"props":2065,"children":2066},{"__ignoreMap":8},[2067],{"type":23,"value":2062},{"type":18,"tag":19,"props":2069,"children":2070},{},[2071],{"type":23,"value":2072},"me의 [[prototype]]은 Person.prototype이다.",{"type":18,"tag":19,"props":2074,"children":2075},{},[2076],{"type":23,"value":2077},"Person.prototype의 [[prototype]]은 Object.prototype이다. (hasOwnProperty를 사용할수 있는 이유)",{"type":18,"tag":19,"props":2079,"children":2080},{},[2081],{"type":23,"value":2082},"Person의 [[prototype]]은 Function.prototype이다.",{"type":18,"tag":96,"props":2084,"children":2086},{"src":2085},"/blog/images/e5b9f522-1c2f-41a3-b183-be1a29c3d14f.png",[],{"type":18,"tag":19,"props":2088,"children":2089},{},[2090],{"type":23,"value":28},{"type":18,"tag":58,"props":2092,"children":2094},{"id":2093},"오버라이딩과-프로퍼티-섀도잉",[2095],{"type":23,"value":2096},"오버라이딩과 프로퍼티 섀도잉",{"type":18,"tag":70,"props":2098,"children":2101},{"className":2099,"code":2100,"language":12,"meta":8},[73],"const Person = (function() {\n    // 생성자 함수\n    function Person(name) {\n        this.name = name;\n    }\n    \n    // 프로토타입 메서드\n    Person.prototype.sayHello = function() {\n        console.log(`Hi! My name is ${this.name}`);\n    }\n    \n    // 생성자 함수를 반환\n    return Person;\n}());\n\nconst me = new Person(\"Lee\");\n\n// 인스턴스 메서드\nme.sayHello = function () {\n    console.log(`Hey! My name is ${this.name}`);\n}\n\n// 인스턴스 메서드가 호출된다. 프로토타입 메서드는 인스턴스 메서드에 의해 가려진다.\nme.sayHello(); // Hey! ...\n",[2102],{"type":18,"tag":77,"props":2103,"children":2104},{"__ignoreMap":8},[2105],{"type":23,"value":2100},{"type":18,"tag":19,"props":2107,"children":2108},{},[2109],{"type":23,"value":28},{"type":18,"tag":19,"props":2111,"children":2112},{},[2113],{"type":23,"value":2114},"프로토타입이 소유한 프로퍼티(메서드 포함)를 프로토타입 프로퍼티, 인스턴스가 소유한 프로퍼티를 인스턴스 프로퍼티라고 부른다.",{"type":18,"tag":19,"props":2116,"children":2117},{},[2118],{"type":23,"value":2119},"프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가하면 프로토타입 체인을 따라 프로토타입 프로퍼티를 검색하여 프로토타입 프로퍼티를 덮어쓰는 것이 아니라 인스턴스 프로퍼티로 추가한다. 이때 인스턴스 메서드 sayHello는 프로토타입 메서드 sayHello를 오버라이딩했고 프로토타입 메서드 sayHello는 가려진다. 이처럼 상속 관계에 의해 프로퍼티가 가려지는 현상을 프로퍼티 섀도잉이라 한다.",{"type":18,"tag":58,"props":2121,"children":2123},{"id":2122},"프로토타입-교체",[2124],{"type":23,"value":2125},"프로토타입 교체",{"type":18,"tag":1008,"props":2127,"children":2129},{"id":2128},"생성자-함수에-의한-프로토타입의-교체",[2130],{"type":23,"value":2131},"생성자 함수에 의한 프로토타입의 교체",{"type":18,"tag":70,"props":2133,"children":2136},{"className":2134,"code":2135,"language":12,"meta":8},[73],"const Person = (function() {\n    function Person(name) {\n        this.name = name;\n    }\n    \n    // 1. 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교채\n    Person.prototype = {\n        sayHello() {\n            console.log(`Hi! My name is ${this.name}`);\n        }\n    }\n    \n    return Person;\n}());\n\nconst me = new Person('Lee');\n\n// 프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 연결이 파괴된다.\nconsole.log(me.constructor === Person); // false\n// 프로토타입 체인을 따라 Object.prototype의 constructor 프로퍼티가 검색된다.\nconsole.log(me.constructor === Object); // true\n",[2137],{"type":18,"tag":77,"props":2138,"children":2139},{"__ignoreMap":8},[2140],{"type":23,"value":2135},{"type":18,"tag":19,"props":2142,"children":2143},{},[2144],{"type":23,"value":2145},"Person.prototype을 객체 리터럴을 할당. 이는 Person 생성자 함수가 생성할 객체의 프로토타입을 객체 리터럴로 교체한 것.",{"type":18,"tag":96,"props":2147,"children":2149},{"src":2148},"/blog/images/74314be3-a7cf-436e-b27d-b7a914b998a4.png",[],{"type":18,"tag":70,"props":2151,"children":2154},{"className":2152,"code":2153,"language":12,"meta":8},[73],"const Person = (function() {\n    function Person(name) {\n        this.name = name;\n    }\n    \n    Person.prototype = {\n        constructor: Person,\n        sayHello() {\n            console.log(`Hi! My name is ${this.name}`);\n        }\n    }\n    \n    return Person;\n}());\n\nconst me = new Person('Lee');\n\nconsole.log(me.constructor === Person); // true\nconsole.log(me.constructor === Object); // false\n",[2155],{"type":18,"tag":77,"props":2156,"children":2157},{"__ignoreMap":8},[2158],{"type":23,"value":2153},{"type":18,"tag":1008,"props":2160,"children":2162},{"id":2161},"인스턴스에-의한-프로토타입의-교체",[2163],{"type":23,"value":2164},"인스턴스에 의한 프로토타입의 교체",{"type":18,"tag":70,"props":2166,"children":2169},{"className":2167,"code":2168,"language":12,"meta":8},[73],"function Person(name) {\n    this.name = name;\n}\n\nconst me = new Person('Lee');\n\nconst parent = {\n    sayHello() {\n        console.log(`Hi! My name is ${this.name}`);\n    }\n}\n\n// me 객체의 프로토타입을 parent 객체로 교체한다.\nObject.setPrototypeOf(me, parent);\n// me.__proto__ = parent; 와 동일하게 동작\n\nme.sayHello();\n\nconsole.log(me.constructor === Person); // false\nconsole.log(me.constructor === Object); // true\n",[2170],{"type":18,"tag":77,"props":2171,"children":2172},{"__ignoreMap":8},[2173],{"type":23,"value":2168},{"type":18,"tag":96,"props":2175,"children":2177},{"src":2176},"/blog/images/e702deb5-fcfa-487f-9b08-985d7dee2908.png",[],{"type":18,"tag":70,"props":2179,"children":2182},{"className":2180,"code":2181,"language":12,"meta":8},[73],"function Person(name) {\n    this.name = name;\n}\n\nconst me = new Person('Lee');\n\nconst parent = {\n    constructor: Person,\n    sayHello() {\n        console.log(`Hi! My name is ${this.name}`);\n    }\n}\n\nPerson.prototype = parent;\n\nObject.setPrototypeOf(me, parent);\n\nme.sayHello();\n\nconsole.log(me.constructor === Person); // true\nconsole.log(me.constructor === Object); // false\n\nconsole.log(Person.prototype === Object.getPrototypeOf(me)); // true\n",[2183],{"type":18,"tag":77,"props":2184,"children":2185},{"__ignoreMap":8},[2186],{"type":23,"value":2181},{"type":18,"tag":19,"props":2188,"children":2189},{},[2190],{"type":23,"value":28},{"type":18,"tag":19,"props":2192,"children":2193},{},[2194],{"type":23,"value":2195},"결론: 프로토타입은 직접 교체하지 않는 것이 좋다. 상속 관계를 인위적으로 설정하려면 “직접 상속”에서 살펴볼 Object.create가 더 편리하고 안전하다. 또한 ES6에서 도입된 클래스를 사용하면 간편하고 직관적으로 상속관계를 구현할 수 있다.",{"type":18,"tag":58,"props":2197,"children":2199},{"id":2198},"instanceof-연산자",[2200],{"type":23,"value":2201},"instanceof 연산자",{"type":18,"tag":19,"props":2203,"children":2204},{},[2205],{"type":23,"value":2206},"우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변의 객체의 프로토타입 체인 상에 존재하면 true로 평가되고, 그렇지 않은 경우에는 false로 평가된다.",{"type":18,"tag":70,"props":2208,"children":2211},{"className":2209,"code":2210,"language":12,"meta":8},[73],"function Person(name) {\n    this.name = name;\n}\n\nconst me = new Person('Lee');\n\nconsole.log(me instanceof Person); // true\nconsole.log(me instanceof Object); // true\n",[2212],{"type":18,"tag":77,"props":2213,"children":2214},{"__ignoreMap":8},[2215],{"type":23,"value":2210},{"type":18,"tag":19,"props":2217,"children":2218},{},[2219],{"type":23,"value":2220},"instanceof 연산자가 어떻게 동작하는지 이해하기 위해 프로토타입을 교체해 보자",{"type":18,"tag":70,"props":2222,"children":2225},{"className":2223,"code":2224,"language":12,"meta":8},[73],"function Person(name) {\n    this.name = name;\n}\n\nconst me = new Person('Lee');\n\nconst parent = {};\n\nObject.setPrototypeOf(me, parent);\n\n// Person.prototype이 me 객체의 프로토타입 체인 상에 존재하지 않기 때문에 false로 평가\nconsole.log(me instanceof Person); // false\n// Object.prototype이 me 객체의 프로토타입 체인 상에 존재하므로 true로 평가\nconsole.log(me instanceof Object); // true\n",[2226],{"type":18,"tag":77,"props":2227,"children":2228},{"__ignoreMap":8},[2229],{"type":23,"value":2224},{"type":18,"tag":19,"props":2231,"children":2232},{},[2233],{"type":23,"value":28},{"type":18,"tag":19,"props":2235,"children":2236},{},[2237],{"type":23,"value":2238},"프로토타입으로 교체한 parent 객체를 Person 생성자 함수의 prototype 프로퍼티에 바인딩하면 me instanceof Person은 true로 평가될 것이다.",{"type":18,"tag":70,"props":2240,"children":2243},{"className":2241,"code":2242,"language":12,"meta":8},[73],"function Person(name) {\n    this.name = name;\n}\n\nconst me = new Person('Lee');\n\nconst parent = {};\n\nObject.setPrototypeOf(me, parent);\n\nPerson.prototype = parent;\n// Person.prototype이 me 객체의 프로토타입 체인 상에 존재하므로 true로 평가\nconsole.log(me instanceof Person); // true\n// Object.prototype이 me 객체의 프로토타입 체인 상에 존재하므로 true로 평가\nconsole.log(me instanceof Object); // true\n",[2244],{"type":18,"tag":77,"props":2245,"children":2246},{"__ignoreMap":8},[2247],{"type":23,"value":2242},{"type":18,"tag":19,"props":2249,"children":2250},{},[2251],{"type":23,"value":28},{"type":18,"tag":19,"props":2253,"children":2254},{},[2255],{"type":23,"value":2256},"생성자 함수에 의해 프로토타입이 교체되어 constructor 프로퍼티와 생성자 함수 간의 연결이 파괴되어도 생성자 함수의 prototype 프로퍼티와 프로토타입 간의 연결은 파괴되지 않으므로 instanceof는 아무런 영향을 받지 않는다.",{"type":18,"tag":70,"props":2258,"children":2261},{"className":2259,"code":2260,"language":12,"meta":8},[73],"const Person = (function() {\n    function Person(name) {\n        this.name = name;\n    }\n    \n    Person.prototype = {\n        sayHello() {\n            console.log(`Hi! My name is ${this.name}`);\n        }\n    }\n    \n    return Person;\n}());\n\nconst me = new Person('Lee');\n\n// constructor 프로퍼티와 생성자 함수 간의 연결이 파괴되어도 instanceof는 아무런 영향을 받지 않는다.\nconsole.log(me.constructor === Person); // false\n\nconsole.log(me instanceof Person); // true\nconsole.log(me instanceof Object); // true\n",[2262],{"type":18,"tag":77,"props":2263,"children":2264},{"__ignoreMap":8},[2265],{"type":23,"value":2260},{"type":18,"tag":58,"props":2267,"children":2269},{"id":2268},"직접상속",[2270],{"type":23,"value":2268},{"type":18,"tag":1008,"props":2272,"children":2274},{"id":2273},"objectcreate에-의한-직접-상속",[2275],{"type":23,"value":2276},"Object.create에 의한 직접 상속",{"type":18,"tag":19,"props":2278,"children":2279},{},[2280],{"type":23,"value":2281},"Object.create 메서드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다.",{"type":18,"tag":19,"props":2283,"children":2284},{},[2285],{"type":23,"value":28},{"type":18,"tag":19,"props":2287,"children":2288},{},[2289],{"type":23,"value":2290},"Object.create 단계별 동작",{"type":18,"tag":70,"props":2292,"children":2295},{"className":2293,"code":2294,"language":12,"meta":8},[73],"// obj의 프로토타입은 null이다.\nlet obj = Object.create(null);\n// Object의 메서드들을 사용하지 못한다.\nconsole.log(obj.toString()); // TypeError\n\n// obj -> Object.prototype -> null\n// obj = {} 동일\nobj = Object.create(Object.prototype);\n\nconst myProto = { x: 10 };\n\n// obj -> myProto -> Object.prototype -> null\nobj = Object.create(myProto);\n\nfunction Person(name) {\n    this.name = name;\n}\n// obj -> Person.prototype -> Object.prototype -> null\nobj = Object.create(Person.prototype);\n",[2296],{"type":18,"tag":77,"props":2297,"children":2298},{"__ignoreMap":8},[2299],{"type":23,"value":2294},{"type":18,"tag":19,"props":2301,"children":2302},{},[2303],{"type":23,"value":2304},"위 코드는 과정을 보여주려고 null 부터 넣은거지 그냥 Object.create(myProto) 혹은 Object.create(Person) 바로 사용하면 됨",{"type":18,"tag":19,"props":2306,"children":2307},{},[2308],{"type":23,"value":2309},"프로토타입 체인은 종점은 null이다.",{"type":18,"tag":19,"props":2311,"children":2312},{},[2313],{"type":23,"value":28},{"type":18,"tag":19,"props":2315,"children":2316},{},[2317],{"type":23,"value":28},{"type":18,"tag":70,"props":2319,"children":2322},{"className":2320,"code":2321,"language":12,"meta":8},[73],"const obj = Object.create(null);\nobj.a = 1;\n\nconsole.log(obj.a); // 1\nconsole.log(obj.hasOwnProperty('a')); // TypeError\n\nconsole.log(Object.hasOwnProperty(obj, 'a')); // true\n",[2323],{"type":18,"tag":77,"props":2324,"children":2325},{"__ignoreMap":8},[2326],{"type":23,"value":2321},{"type":18,"tag":19,"props":2328,"children":2329},{},[2330],{"type":23,"value":28},{"type":18,"tag":1844,"props":2332,"children":2333},{},[],{"type":18,"tag":19,"props":2335,"children":2336},{},[2337],{"type":23,"value":2338},"정적프로퍼티/메서드 부터 계속",{"type":18,"tag":19,"props":2340,"children":2341},{},[2342],{"type":23,"value":28},{"title":8,"searchDepth":429,"depth":429,"links":2344},[2345,2356,2357,2358,2359,2360,2361,2362,2363],{"id":1643,"depth":429,"text":2346,"children":2347},"proto 접근자 프로퍼티",[2348,2350,2352,2354],{"id":1668,"depth":2349,"text":1671},3,{"id":1687,"depth":2349,"text":2351},"proto 접근자 프로퍼티는 상속을 통해 사용된다.",{"id":1723,"depth":2349,"text":2353},"proto 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유",{"id":1758,"depth":2349,"text":2355},"proto 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 권장하지 않는다.",{"id":1789,"depth":429,"text":1792},{"id":1830,"depth":429,"text":1833},{"id":2010,"depth":429,"text":2013},{"id":2025,"depth":429,"text":2028},{"id":2040,"depth":429,"text":2043},{"id":2128,"depth":429,"text":2131},{"id":2161,"depth":429,"text":2164},{"id":2273,"depth":429,"text":2276},"content:posts:eefbc7dd-a0f6-4078-97f5-9b6f26a483f1.md","posts/eefbc7dd-a0f6-4078-97f5-9b6f26a483f1.md",{"_path":2367,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":2368,"description":2369,"tags":2370,"date":2371,"body":2372,"_type":431,"_id":2540,"_source":433,"_file":2541,"_extension":435},"/posts/395ca83a-7b04-4f59-962a-1bc8cc05d1aa","자바스크립트 - 15. 함수와 일급 객체","일급 객체 조건",[12],"2024-02-22T00:00:00.000Z",{"type":15,"children":2373,"toc":2530},[2374,2378,2401,2405,2414,2418,2423,2427,2433,2438,2444,2449,2458,2464,2469,2475,2480,2486,2491,2496,2504,2509,2515,2520,2525],{"type":18,"tag":19,"props":2375,"children":2376},{},[2377],{"type":23,"value":2369},{"type":18,"tag":208,"props":2379,"children":2380},{},[2381,2386,2391,2396],{"type":18,"tag":212,"props":2382,"children":2383},{},[2384],{"type":23,"value":2385},"무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.",{"type":18,"tag":212,"props":2387,"children":2388},{},[2389],{"type":23,"value":2390},"변수나 자료구조(객체, 배열 등)에 저장할 수 있다.",{"type":18,"tag":212,"props":2392,"children":2393},{},[2394],{"type":23,"value":2395},"함수의 매개변수에 전달할 수 있다.",{"type":18,"tag":212,"props":2397,"children":2398},{},[2399],{"type":23,"value":2400},"함수의 반환값으로 사용할 수 있다.",{"type":18,"tag":19,"props":2402,"children":2403},{},[2404],{"type":23,"value":28},{"type":18,"tag":70,"props":2406,"children":2409},{"className":2407,"code":2408,"language":12,"meta":8},[73],"// 1. 함수는 무명의 리터럴로 생성할 수 있다.\n// 2. 함수는 변수에 저장할 수 있다.\n// 런타임(할당 단계)에 함수 리터럴이 평가되어 함수 객체가 생성되고 변수에 할당된다.\nconst increase = function (num) {\n    return ++num;\n}\n\nconst decrease = function (num) {\n    return --num;\n}\n\n// 2. 함수는 객체에 저장할 수 있다.\nconst predicates = {increase, decrease};\n\n// 3. 함수의 매개변수에 전달할 수 있다.\n// 4. 함수의 반환값으로 사용할 수 있다.\nfunction makeCount(predicate) {\n    let num = 0;\n    return funtion () {\n        num = predicate(num);\n        return num;\n    }\n}\n\n// 3. 함수는 매개변수에게 함수를 전달할 수 있따.\nconst increaser = makeCounter(predicates.increase);\nincreaser();\nincreaser();\n",[2410],{"type":18,"tag":77,"props":2411,"children":2412},{"__ignoreMap":8},[2413],{"type":23,"value":2408},{"type":18,"tag":19,"props":2415,"children":2416},{},[2417],{"type":23,"value":28},{"type":18,"tag":19,"props":2419,"children":2420},{},[2421],{"type":23,"value":2422},"함수가 일급 객체라는 것은 함수를 객체와 동일하게 사용할 수 있다는 의미다. 객체는 값이므로 함수는 값과 동일하게 취급할 수 있다. 따라서 함수는 값을 사용할 수 있는 곳이라면 어디서든지 리터럴로 정의할 수 있으며 런타임에 함수 객체로 평가된다.",{"type":18,"tag":19,"props":2424,"children":2425},{},[2426],{"type":23,"value":28},{"type":18,"tag":1008,"props":2428,"children":2430},{"id":2429},"함수-객체의-프로퍼티",[2431],{"type":23,"value":2432},"함수 객체의 프로퍼티",{"type":18,"tag":19,"props":2434,"children":2435},{},[2436],{"type":23,"value":2437},"함수는 객체다. 따라서 함수도 프로퍼티를 가질 수 있다.",{"type":18,"tag":1666,"props":2439,"children":2441},{"id":2440},"arguments-프로퍼티",[2442],{"type":23,"value":2443},"arguments 프로퍼티",{"type":18,"tag":19,"props":2445,"children":2446},{},[2447],{"type":23,"value":2448},"매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용",{"type":18,"tag":70,"props":2450,"children":2453},{"className":2451,"code":2452,"language":12,"meta":8},[73],"function sum() {\n    const array = Array.prototype.slice.call(arguments);\n    ...\n}\n\nsum(1,2);\nsum(1,2,3);\n\n// ES6에 rest 파라미터 사용하면 됨\nfunction sum(...args) {\n    return args.reduce...\n}\n",[2454],{"type":18,"tag":77,"props":2455,"children":2456},{"__ignoreMap":8},[2457],{"type":23,"value":2452},{"type":18,"tag":1666,"props":2459,"children":2461},{"id":2460},"caller-프로퍼티",[2462],{"type":23,"value":2463},"caller 프로퍼티",{"type":18,"tag":19,"props":2465,"children":2466},{},[2467],{"type":23,"value":2468},"비표준 프로퍼티. 알 필요 없음",{"type":18,"tag":1666,"props":2470,"children":2472},{"id":2471},"length-프로퍼티",[2473],{"type":23,"value":2474},"length 프로퍼티",{"type":18,"tag":19,"props":2476,"children":2477},{},[2478],{"type":23,"value":2479},"매개변수 개수",{"type":18,"tag":1666,"props":2481,"children":2483},{"id":2482},"name-프로퍼티",[2484],{"type":23,"value":2485},"name 프로퍼티",{"type":18,"tag":19,"props":2487,"children":2488},{},[2489],{"type":23,"value":2490},"함수 이름",{"type":18,"tag":19,"props":2492,"children":2493},{},[2494],{"type":23,"value":2495},"ES6이전까지는 비표준 ES6에서 정식 표준",{"type":18,"tag":1666,"props":2497,"children":2498},{"id":1643},[2499,2503],{"type":18,"tag":265,"props":2500,"children":2501},{},[2502],{"type":23,"value":1649},{"type":23,"value":1651},{"type":18,"tag":19,"props":2505,"children":2506},{},[2507],{"type":23,"value":2508},"[[Prototype]]이라는 내부 슬롯에 간접적으로 접근하기 위한 프로퍼티",{"type":18,"tag":1666,"props":2510,"children":2512},{"id":2511},"prototype-프로퍼티",[2513],{"type":23,"value":2514},"prototype 프로퍼티",{"type":18,"tag":19,"props":2516,"children":2517},{},[2518],{"type":23,"value":2519},"생성자 함수로 호출할 수 있는 함수 객체, 즉 constructor만이 소유하는 프로퍼티",{"type":18,"tag":19,"props":2521,"children":2522},{},[2523],{"type":23,"value":2524},"일반 객체와 생성자 함수로 호출할 수 없는 non-constructor에는 prototype 프로퍼티가 없다.",{"type":18,"tag":19,"props":2526,"children":2527},{},[2528],{"type":23,"value":2529},"(이전 14. 생성자 함수에 의한 객체 생성 참고)",{"title":8,"searchDepth":429,"depth":429,"links":2531},[2532],{"id":2429,"depth":429,"text":2432,"children":2533},[2534,2535,2536,2537,2538,2539],{"id":2440,"depth":2349,"text":2443},{"id":2460,"depth":2349,"text":2463},{"id":2471,"depth":2349,"text":2474},{"id":2482,"depth":2349,"text":2485},{"id":1643,"depth":2349,"text":2346},{"id":2511,"depth":2349,"text":2514},"content:posts:395ca83a-7b04-4f59-962a-1bc8cc05d1aa.md","posts/395ca83a-7b04-4f59-962a-1bc8cc05d1aa.md",{"_path":2543,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":2544,"description":2545,"tags":2546,"date":2547,"body":2548,"_type":431,"_id":2931,"_source":433,"_file":2932,"_extension":435},"/posts/7ada091c-3330-42a3-9990-528ebddc39eb","자바스크립트 - 14. 생성자 함수에 의한 객체 생성","뒤에서 this 배울꺼지만 this 바인딩은 함수 호출 방식에 따라 동적으로 결정",[12],"2024-02-21T00:00:00.000Z",{"type":15,"children":2549,"toc":2927},[2550,2554,2563,2567,2572,2580,2584,2590,2599,2604,2608,2613,2617,2625,2651,2660,2668,2681,2690,2698,2706,2715,2720,2729,2733,2738,2747,2751,2757,2762,2771,2775,2780,2785,2790,2795,2799,2804,2809,2818,2822,2827,2832,2837,2841,2846,2850,2856,2861,2866,2875,2879,2885,2890,2895,2900,2905,2910,2919,2923],{"type":18,"tag":19,"props":2551,"children":2552},{},[2553],{"type":23,"value":2545},{"type":18,"tag":70,"props":2555,"children":2558},{"className":2556,"code":2557,"language":12,"meta":8},[73],"function foo() {\n    console.log(this)\n}\n\nfoo(); // window\n\nconst obj = { foo };\n\nobj.foo(); // obj\n\nconst inst = new Foo(); // inst\n",[2559],{"type":18,"tag":77,"props":2560,"children":2561},{"__ignoreMap":8},[2562],{"type":23,"value":2557},{"type":18,"tag":19,"props":2564,"children":2565},{},[2566],{"type":23,"value":28},{"type":18,"tag":19,"props":2568,"children":2569},{},[2570],{"type":23,"value":2571},"생성자 함수는 이름 그대로 객체(인스턴스)를 생성하는 함수다.",{"type":18,"tag":19,"props":2573,"children":2574},{},[2575],{"type":18,"tag":265,"props":2576,"children":2577},{},[2578],{"type":23,"value":2579},"new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다.",{"type":18,"tag":19,"props":2581,"children":2582},{},[2583],{"type":23,"value":28},{"type":18,"tag":58,"props":2585,"children":2587},{"id":2586},"생성자-함수의-인스턴스-생성-과정",[2588],{"type":23,"value":2589},"생성자 함수의 인스턴스 생성 과정",{"type":18,"tag":70,"props":2591,"children":2594},{"className":2592,"code":2593,"language":12,"meta":8},[73],"function Circle(radius) {\n    // 인스턴스 초기화\n    this.radius = radius;\n    this.getDiameter = function() {\n        return 2 * this.radius;\n    }\n}\n",[2595],{"type":18,"tag":77,"props":2596,"children":2597},{"__ignoreMap":8},[2598],{"type":23,"value":2593},{"type":18,"tag":19,"props":2600,"children":2601},{},[2602],{"type":23,"value":2603},"생성자 함수 내부의 코드를 살펴보면 this에 프로퍼티를 추가하고 필요에 따라 전달된 인수를 프로퍼티의 초기값으로서 할당하여 인스턴스를 초기화한다. 하지만 인스턴스를 생성하고 반환하는 코드는 보이지 않는다.",{"type":18,"tag":19,"props":2605,"children":2606},{},[2607],{"type":23,"value":28},{"type":18,"tag":19,"props":2609,"children":2610},{},[2611],{"type":23,"value":2612},"자바스크립트 엔진은 암묵적인 처리를 통해 인스턴스를 생성하고 반환한다. new 연산자와 함께 생성자 함수를 호출하면 자바스크립트 엔진은 다음과 같은 과정을 거친다.",{"type":18,"tag":19,"props":2614,"children":2615},{},[2616],{"type":23,"value":28},{"type":18,"tag":208,"props":2618,"children":2619},{},[2620],{"type":18,"tag":212,"props":2621,"children":2622},{},[2623],{"type":23,"value":2624},"인스턴스 생성과 this 바인딩",{"type":18,"tag":1334,"props":2626,"children":2627},{},[2628,2633,2646],{"type":18,"tag":212,"props":2629,"children":2630},{},[2631],{"type":23,"value":2632},"암묵적으로 빈 객체가 생성된다. 이 객체가 바로(아직 완성X) 생성자 함수가 생성한 인스턴스",{"type":18,"tag":212,"props":2634,"children":2635},{},[2636,2638],{"type":23,"value":2637},"이 인스턴스는 this에 바인딩된다.\n",{"type":18,"tag":1334,"props":2639,"children":2640},{},[2641],{"type":18,"tag":212,"props":2642,"children":2643},{},[2644],{"type":23,"value":2645},"바인딩이란 식별자와 값을 연결하는 과정을 의미한다. 예를 들어, 변수 선언은 변수 이름(식별자)과 확보된 메모리 공간의 주소를 바인딩하는 것이다. this 바인딩은 this와 this가 가리킬 객체를 바인딩하는 것이다.",{"type":18,"tag":212,"props":2647,"children":2648},{},[2649],{"type":23,"value":2650},"함수 몸체의 코드가 한 줄씩 실행되는 런타임 이전에 실행된다.",{"type":18,"tag":70,"props":2652,"children":2655},{"className":2653,"code":2654,"language":12,"meta":8},[73],"function Circle(radius) {\n    // 1. 암묵적으로 인스턴스가 생성되고 this에 바인딩 된다.\n    console.log(this); // Circle {}\n\n    this.radius = radius;\n    this.getDiameter = function() {\n        return 2 * this.radius;\n    }\n}\n",[2656],{"type":18,"tag":77,"props":2657,"children":2658},{"__ignoreMap":8},[2659],{"type":23,"value":2654},{"type":18,"tag":208,"props":2661,"children":2662},{},[2663],{"type":18,"tag":212,"props":2664,"children":2665},{},[2666],{"type":23,"value":2667},"인스턴스 초기화",{"type":18,"tag":1334,"props":2669,"children":2670},{},[2671,2676],{"type":18,"tag":212,"props":2672,"children":2673},{},[2674],{"type":23,"value":2675},"생성자 함수에 기술되어 있는 코드가 한 줄씩 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다.",{"type":18,"tag":212,"props":2677,"children":2678},{},[2679],{"type":23,"value":2680},"즉, this에 바인딩되어 있는 인스턴스에 프로퍼티나 메서드를 추가",{"type":18,"tag":70,"props":2682,"children":2685},{"className":2683,"code":2684,"language":12,"meta":8},[73],"function Circle(radius) {\n\n    // 2. this에 바인딩되어 있는 인스턴스를 초기화한다.\n    this.radius = radius;\n    this.getDiameter = function() {\n        return 2 * this.radius;\n    }\n}\n",[2686],{"type":18,"tag":77,"props":2687,"children":2688},{"__ignoreMap":8},[2689],{"type":23,"value":2684},{"type":18,"tag":208,"props":2691,"children":2692},{},[2693],{"type":18,"tag":212,"props":2694,"children":2695},{},[2696],{"type":23,"value":2697},"인스턴스 반환",{"type":18,"tag":1334,"props":2699,"children":2700},{},[2701],{"type":18,"tag":212,"props":2702,"children":2703},{},[2704],{"type":23,"value":2705},"생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.",{"type":18,"tag":70,"props":2707,"children":2710},{"className":2708,"code":2709,"language":12,"meta":8},[73],"function Circle(radius) {\n\n    this.radius = radius;\n    this.getDiameter = function() {\n        return 2 * this.radius;\n    }\n    // 3. 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.\n}\n\n// 인스턴스 생성. Circle 생성자 함수는 암묵적으로 this를 반환한다.\nconst circle = new Circle(1);\nconsole.log(cirlce); // Circle{...}\n",[2711],{"type":18,"tag":77,"props":2712,"children":2713},{"__ignoreMap":8},[2714],{"type":23,"value":2709},{"type":18,"tag":19,"props":2716,"children":2717},{},[2718],{"type":23,"value":2719},"만약 this가 아닌 다른 객체를 명시적으로 반환하면 this가 반환되지 못하고 return 문에 명시한 객체가 반환된다.",{"type":18,"tag":70,"props":2721,"children":2724},{"className":2722,"code":2723,"language":12,"meta":8},[73],"function Circle(radius) {\n\n    this.radius = radius;\n    this.getDiameter = function() {\n        return 2 * this.radius;\n    }\n\n    return {}\n}\n\n// 인스턴스 생성. Circle 생성자 함수는 암묵적으로 this를 반환한다.\nconst circle = new Circle(1);\nconsole.log(circle); // {}\n",[2725],{"type":18,"tag":77,"props":2726,"children":2727},{"__ignoreMap":8},[2728],{"type":23,"value":2723},{"type":18,"tag":19,"props":2730,"children":2731},{},[2732],{"type":23,"value":28},{"type":18,"tag":19,"props":2734,"children":2735},{},[2736],{"type":23,"value":2737},"하지만 명시적으로 원시 값을 반환하면 원시 값 반환은 무시되고 암묵적으로 this가 반환된다.",{"type":18,"tag":70,"props":2739,"children":2742},{"className":2740,"code":2741,"language":12,"meta":8},[73],"function Circle(radius) {\n\n    this.radius = radius;\n    this.getDiameter = function() {\n        return 2 * this.radius;\n    }\n\n    return 100;\n}\n\n// 인스턴스 생성. Circle 생성자 함수는 암묵적으로 this를 반환한다.\nconst circle = new Circle(1);\nconsole.log(circle); // Circle {}\n",[2743],{"type":18,"tag":77,"props":2744,"children":2745},{"__ignoreMap":8},[2746],{"type":23,"value":2741},{"type":18,"tag":19,"props":2748,"children":2749},{},[2750],{"type":23,"value":28},{"type":18,"tag":58,"props":2752,"children":2754},{"id":2753},"내부-메서드-call과-constructor",[2755],{"type":23,"value":2756},"내부 메서드 [[Call]]과 [[Constructor]]",{"type":18,"tag":19,"props":2758,"children":2759},{},[2760],{"type":23,"value":2761},"함수는 객체다. 그래서 일반 객체가 가지고 있는 내부 슬롯과 내부 메서드를 모두 가지고 있다.",{"type":18,"tag":70,"props":2763,"children":2766},{"className":2764,"code":2765,"language":12,"meta":8},[73],"function foo() {}\n\n// 함수는 객체이므로 프로퍼티를 소유할 수 있다.\nfoo.prop = 10;\n\n// 함수는 객체이므로 메서드를 소유할 수 있다.\nfoo.method = function() {\n    console.log(this.prop);\n}\n\nfoo.method(); // 10\n",[2767],{"type":18,"tag":77,"props":2768,"children":2769},{"__ignoreMap":8},[2770],{"type":23,"value":2765},{"type":18,"tag":19,"props":2772,"children":2773},{},[2774],{"type":23,"value":28},{"type":18,"tag":19,"props":2776,"children":2777},{},[2778],{"type":23,"value":2779},"하지만 함수만에 특징이 있으니 함수는 호출할 수 있다.",{"type":18,"tag":19,"props":2781,"children":2782},{},[2783],{"type":23,"value":2784},"그래서 함수 객체만 가지고 있는 내부 슬롯과 내부 메서드를 추가로 가지고 있다.",{"type":18,"tag":19,"props":2786,"children":2787},{},[2788],{"type":23,"value":2789},"[[Environment]], [[FormalParameters]] 내부슬롯과",{"type":18,"tag":19,"props":2791,"children":2792},{},[2793],{"type":23,"value":2794},"[[Call]], [[Construct]] 내부 메서드",{"type":18,"tag":19,"props":2796,"children":2797},{},[2798],{"type":23,"value":28},{"type":18,"tag":19,"props":2800,"children":2801},{},[2802],{"type":23,"value":2803},"함수가 일반 함수로서 호출되면 함수 객체의 내부 메서드 [[Call]]이 호출되고",{"type":18,"tag":19,"props":2805,"children":2806},{},[2807],{"type":23,"value":2808},"new 연산자와 함께 생성자 함수로서 호출되면 내부 메서드 [[Construct]]가 호출된다.",{"type":18,"tag":70,"props":2810,"children":2813},{"className":2811,"code":2812,"language":12,"meta":8},[73],"function foo() {}\n\n// 일반적인 함수로서 호출: [[Call]]이 호출된다.\nfoo();\n\n// 생성자 함수로서 호출: [[Constructor]]가 호출된다.\nnew foo();\n",[2814],{"type":18,"tag":77,"props":2815,"children":2816},{"__ignoreMap":8},[2817],{"type":23,"value":2812},{"type":18,"tag":19,"props":2819,"children":2820},{},[2821],{"type":23,"value":28},{"type":18,"tag":19,"props":2823,"children":2824},{},[2825],{"type":23,"value":2826},"[[Call]]을 갖는 함수 객체를 callable",{"type":18,"tag":19,"props":2828,"children":2829},{},[2830],{"type":23,"value":2831},"[[Construct]]를 갖는 함수 객체를 contructor",{"type":18,"tag":19,"props":2833,"children":2834},{},[2835],{"type":23,"value":2836},"[[Construct]]를 갖지 않는 함수 객체를 non-contructor",{"type":18,"tag":19,"props":2838,"children":2839},{},[2840],{"type":23,"value":28},{"type":18,"tag":19,"props":2842,"children":2843},{},[2844],{"type":23,"value":2845},"모든 함수는 callable이다. 하지만 모든 함수는 constructor아니면 non-constructor이다.",{"type":18,"tag":19,"props":2847,"children":2848},{},[2849],{"type":23,"value":28},{"type":18,"tag":1008,"props":2851,"children":2853},{"id":2852},"constructor와-non-constructor-구분",[2854],{"type":23,"value":2855},"constructor와 non-constructor 구분",{"type":18,"tag":19,"props":2857,"children":2858},{},[2859],{"type":23,"value":2860},"constructor 함수 선언문, 함수 표현식, 클래스(클래스도 함수다)",{"type":18,"tag":19,"props":2862,"children":2863},{},[2864],{"type":23,"value":2865},"non-constructor: 메서드(ES6 메서드 축약 표현), 화살표 함수",{"type":18,"tag":70,"props":2867,"children":2870},{"className":2868,"code":2869,"language":12,"meta":8},[73],"function foo() {};\nconst bar = function() {};\n\nconst baz = {\n    x: function() {}\n}\n\nnew foo(); // -> foo {}\nnew bar(); // -> bar {}\nnew baz.x; // -> x {}\n\nconst arrow = () => {};\n\nnew arrow(); // TypeError: arrow is not a constructor\n\nconst obj = {\n    x() {}\n}\n\nnew obj.x; // TypeError: obj.x is not a constructor\n",[2871],{"type":18,"tag":77,"props":2872,"children":2873},{"__ignoreMap":8},[2874],{"type":23,"value":2869},{"type":18,"tag":19,"props":2876,"children":2877},{},[2878],{"type":23,"value":28},{"type":18,"tag":1008,"props":2880,"children":2882},{"id":2881},"newtarget",[2883],{"type":23,"value":2884},"new.target",{"type":18,"tag":19,"props":2886,"children":2887},{},[2888],{"type":23,"value":2889},"생성자 함수가 new 연산자 없이 호출되는 것을 방지하기 위한 프로퍼티",{"type":18,"tag":19,"props":2891,"children":2892},{},[2893],{"type":23,"value":2894},"new.target은 this와 유사하게 constructor인 모든 함수 내부에서 암묵적인 지역 변수와 같이 사용되며 메타 프로퍼티라고 부른다.",{"type":18,"tag":19,"props":2896,"children":2897},{},[2898],{"type":23,"value":2899},"new.target을 사용하면 new 연산자와 함께 생성자 함수로서 호출되었는지 확인할 수 있다.",{"type":18,"tag":19,"props":2901,"children":2902},{},[2903],{"type":23,"value":2904},"new 연산자와 함께 생성자 함수로서 호출되면 함수 내부의 new.target은 함수 자신을 가리킨다.",{"type":18,"tag":19,"props":2906,"children":2907},{},[2908],{"type":23,"value":2909},"new 연산자 없이 일반 함수로서 호출된 함수 내부의 new.target은 undefined다.",{"type":18,"tag":70,"props":2911,"children":2914},{"className":2912,"code":2913,"language":12,"meta":8},[73],"function Circle(radius){\n    if (!new.target) {\n        return new Cricle(radius);\n    }\n    ....\n}\n\nconst circle = Circle(5);\n",[2915],{"type":18,"tag":77,"props":2916,"children":2917},{"__ignoreMap":8},[2918],{"type":23,"value":2913},{"type":18,"tag":19,"props":2920,"children":2921},{},[2922],{"type":23,"value":28},{"type":18,"tag":19,"props":2924,"children":2925},{},[2926],{"type":23,"value":28},{"title":8,"searchDepth":429,"depth":429,"links":2928},[2929,2930],{"id":2852,"depth":429,"text":2855},{"id":2881,"depth":429,"text":2884},"content:posts:7ada091c-3330-42a3-9990-528ebddc39eb.md","posts/7ada091c-3330-42a3-9990-528ebddc39eb.md",{"_path":2934,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":2935,"description":8,"tags":2936,"date":2937,"body":2938,"_type":431,"_id":3143,"_source":433,"_file":3144,"_extension":435},"/posts/63c3dae1-1565-48b5-8b41-a2862e03e82f","자바스크립트 - 13. 프로퍼티 어트리뷰트",[12],"2024-02-20T00:00:00.000Z",{"type":15,"children":2939,"toc":3139},[2940,2946,2959,2963,2975,2980,2989,2995,3000,3005,3009,3014,3023,3029,3035,3040,3045,3050,3055,3064,3070,3075,3080,3084,3088,3097,3100,3104,3109,3118,3124,3129,3134],{"type":18,"tag":58,"props":2941,"children":2943},{"id":2942},"내부-슬롯-내부-메서드",[2944],{"type":23,"value":2945},"내부 슬롯, 내부 메서드",{"type":18,"tag":1334,"props":2947,"children":2948},{},[2949,2954],{"type":18,"tag":212,"props":2950,"children":2951},{},[2952],{"type":23,"value":2953},"ECMAScript 사양에 등장하는 이중 대괄호",{"type":18,"tag":212,"props":2955,"children":2956},{},[2957],{"type":23,"value":2958},"개발자가 직접 접근할 수 있도록 외부로 공개된 객체의 프로퍼티는 아님 (간접적으로 접근할 수 있는 수단을 제공하기는 함)",{"type":18,"tag":19,"props":2960,"children":2961},{},[2962],{"type":23,"value":28},{"type":18,"tag":19,"props":2964,"children":2965},{},[2966,2968,2973],{"type":23,"value":2967},"모든 ",{"type":18,"tag":265,"props":2969,"children":2970},{},[2971],{"type":23,"value":2972},"객체",{"type":23,"value":2974},"는 [[Prototype]] 내부 슬롯을 갖는다.",{"type":18,"tag":19,"props":2976,"children":2977},{},[2978],{"type":23,"value":2979},"원칙적으로 접근할 수 없지만 __proto__를 통해 간접적으로 접근할 수 있다.",{"type":18,"tag":70,"props":2981,"children":2984},{"className":2982,"code":2983,"language":12,"meta":8},[73],"const o = {};\no.[[Prototype]]\no.__proto__\n",[2985],{"type":18,"tag":77,"props":2986,"children":2987},{"__ignoreMap":8},[2988],{"type":23,"value":2983},{"type":18,"tag":58,"props":2990,"children":2992},{"id":2991},"프로퍼티-어트리뷰트-프로퍼티-디스크립터-객체",[2993],{"type":23,"value":2994},"프로퍼티 어트리뷰트, 프로퍼티 디스크립터 객체",{"type":18,"tag":19,"props":2996,"children":2997},{},[2998],{"type":23,"value":2999},"자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.",{"type":18,"tag":19,"props":3001,"children":3002},{},[3003],{"type":23,"value":3004},"프로퍼티 어트리뷰트는 자바스크립트 엔진이 관리하는 내부 상태 값(meta-property)인 내부 슬롯 [[Value]],[[Writeable]],[[Enumerable]],[[Configurable]]이다.",{"type":18,"tag":19,"props":3006,"children":3007},{},[3008],{"type":23,"value":28},{"type":18,"tag":19,"props":3010,"children":3011},{},[3012],{"type":23,"value":3013},"직접 접근할 수 없지만, 메서드를 사용하여 간접적으로 확인할 수 있다.",{"type":18,"tag":70,"props":3015,"children":3018},{"className":3016,"code":3017,"language":12,"meta":8},[73],"const person = {\n    name: 'Lee'\n}\n\nperson.age = 20;\n\nconsole.log(Object.getOwnPropertyDescriptor(person, 'name'));\n\nconsole.log(Object.getOwnPropertyDescriptors(person));\n",[3019],{"type":18,"tag":77,"props":3020,"children":3021},{"__ignoreMap":8},[3022],{"type":23,"value":3017},{"type":18,"tag":58,"props":3024,"children":3026},{"id":3025},"데이터-프로퍼티-접근자-프로퍼티",[3027],{"type":23,"value":3028},"데이터 프로퍼티, 접근자 프로퍼티",{"type":18,"tag":1008,"props":3030,"children":3032},{"id":3031},"데이터-프로퍼티",[3033],{"type":23,"value":3034},"데이터 프로퍼티",{"type":18,"tag":19,"props":3036,"children":3037},{},[3038],{"type":23,"value":3039},"[[Value]]",{"type":18,"tag":19,"props":3041,"children":3042},{},[3043],{"type":23,"value":3044},"[[Writable]]",{"type":18,"tag":19,"props":3046,"children":3047},{},[3048],{"type":23,"value":3049},"[[Enumerable]]",{"type":18,"tag":19,"props":3051,"children":3052},{},[3053],{"type":23,"value":3054},"[[Configurable]]",{"type":18,"tag":70,"props":3056,"children":3059},{"className":3057,"code":3058,"language":12,"meta":8},[73],"const person = {\n    name: 'Lee'\n}\n\nconsole.log(Object.getOwnPropertyDescriptors(person));\n",[3060],{"type":18,"tag":77,"props":3061,"children":3062},{"__ignoreMap":8},[3063],{"type":23,"value":3058},{"type":18,"tag":1008,"props":3065,"children":3067},{"id":3066},"접근자-프로퍼티",[3068],{"type":23,"value":3069},"접근자 프로퍼티",{"type":18,"tag":19,"props":3071,"children":3072},{},[3073],{"type":23,"value":3074},"[[Get]]",{"type":18,"tag":19,"props":3076,"children":3077},{},[3078],{"type":23,"value":3079},"[[Set]]",{"type":18,"tag":19,"props":3081,"children":3082},{},[3083],{"type":23,"value":3049},{"type":18,"tag":19,"props":3085,"children":3086},{},[3087],{"type":23,"value":3054},{"type":18,"tag":70,"props":3089,"children":3092},{"className":3090,"code":3091,"language":12,"meta":8},[73]," const person = {\n    firtName: 'Ungmo',\n    lastName: 'Lee',\n\n    get fullName() {\n      return `${this.firtName} ${this.lastName}`;\n    },\n    set fullName(name) {\n      [this.firtName, this.lastName] = name.split(' ');\n    }\n  }\n  console.log(Object.getOwnPropertyDescriptor(person, 'fullName'));\n",[3093],{"type":18,"tag":77,"props":3094,"children":3095},{"__ignoreMap":8},[3096],{"type":23,"value":3091},{"type":18,"tag":1844,"props":3098,"children":3099},{},[],{"type":18,"tag":19,"props":3101,"children":3102},{},[3103],{"type":23,"value":28},{"type":18,"tag":19,"props":3105,"children":3106},{},[3107],{"type":23,"value":3108},"그러니까 객체 프로퍼티 변경이나 삭제 안되게 하고 싶거나 for..in문이나 Object.key에 안나오게 하고싶게 생성할때",{"type":18,"tag":70,"props":3110,"children":3113},{"className":3111,"code":3112,"language":12,"meta":8},[73],"Object.defineProperty(person, 'firstname', {\n    value: 'Seungyoon',\n    writable: false,\n    enumerable: false,\n    configurable: false\n});\n\nperson.name = 'test'; // writable이 false라 변경되지 않는다.\n\nconsole.log(Object.keys(person)); // []\n\ndelete person.firstname; // configutable이 false라 삭제되지 않느다.\n\nconsole.log(person.name); // Seungyoon\n",[3114],{"type":18,"tag":77,"props":3115,"children":3116},{"__ignoreMap":8},[3117],{"type":23,"value":3112},{"type":18,"tag":58,"props":3119,"children":3121},{"id":3120},"객체-변경-방지",[3122],{"type":23,"value":3123},"객체 변경 방지",{"type":18,"tag":19,"props":3125,"children":3126},{},[3127],{"type":23,"value":3128},"Object.preventExtensions",{"type":18,"tag":19,"props":3130,"children":3131},{},[3132],{"type":23,"value":3133},"Object.seal",{"type":18,"tag":19,"props":3135,"children":3136},{},[3137],{"type":23,"value":3138},"Object.freeze",{"title":8,"searchDepth":429,"depth":429,"links":3140},[3141,3142],{"id":3031,"depth":429,"text":3034},{"id":3066,"depth":429,"text":3069},"content:posts:63c3dae1-1565-48b5-8b41-a2862e03e82f.md","posts/63c3dae1-1565-48b5-8b41-a2862e03e82f.md",{"_path":3146,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":3147,"description":8,"tags":3148,"date":3149,"body":3150,"_type":431,"_id":3517,"_source":433,"_file":3518,"_extension":435},"/posts/2c7bdebd-8baa-46a1-b05b-61bda16d93f4","자바스크립트 - 12. let, const 키워드와 블록 레벨 스코프",[12],"2024-02-19T00:00:00.000Z",{"type":15,"children":3151,"toc":3504},[3152,3158,3164,3172,3181,3187,3195,3204,3213,3219,3228,3234,3240,3249,3255,3264,3269,3297,3306,3310,3344,3353,3359,3380,3389,3395,3401,3410,3416,3425,3431,3440,3446,3467,3476,3488,3492,3500],{"type":18,"tag":58,"props":3153,"children":3155},{"id":3154},"var-키워드의-문제점",[3156],{"type":23,"value":3157},"var 키워드의 문제점",{"type":18,"tag":1008,"props":3159,"children":3161},{"id":3160},"_1-변수-중복-선언-허용",[3162],{"type":23,"value":3163},"1. 변수 중복 선언 허용",{"type":18,"tag":1334,"props":3165,"children":3166},{},[3167],{"type":18,"tag":212,"props":3168,"children":3169},{},[3170],{"type":23,"value":3171},"이미 선언된 변수의 값이 변경되는 부작용 발생",{"type":18,"tag":70,"props":3173,"children":3176},{"className":3174,"code":3175,"language":12,"meta":8},[73],"var x = 1;\nvar y = 1;\n\n// var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다.\n// 초기화문이 있는 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.\nvar x = 100;\n// 초기화가 없는 변수 선언문은 무시된다.\nvar y;\n\nconsole.log(x); // 100\nconsole.log(y); // 1\n",[3177],{"type":18,"tag":77,"props":3178,"children":3179},{"__ignoreMap":8},[3180],{"type":23,"value":3175},{"type":18,"tag":1008,"props":3182,"children":3184},{"id":3183},"_2-함수-레벨-스코프",[3185],{"type":23,"value":3186},"2. 함수 레벨 스코프",{"type":18,"tag":1334,"props":3188,"children":3189},{},[3190],{"type":18,"tag":212,"props":3191,"children":3192},{},[3193],{"type":23,"value":3194},"오로지 함수의 코드 블록만을 지역 스코프로 인정한다.",{"type":18,"tag":70,"props":3196,"children":3199},{"className":3197,"code":3198,"language":12,"meta":8},[73],"var x = 1;\n\nif (true) {\n    var x = 10;\n}\nconsole.log(x); // 10\n",[3200],{"type":18,"tag":77,"props":3201,"children":3202},{"__ignoreMap":8},[3203],{"type":23,"value":3198},{"type":18,"tag":70,"props":3205,"children":3208},{"className":3206,"code":3207,"language":12,"meta":8},[73],"var i = 10;\n\nfor (var i = 0; i \u003C 5; i++) {\n    console.log(i); // 0 1 2 3 4 5\n}\nconsole.log(i); // 5\n",[3209],{"type":18,"tag":77,"props":3210,"children":3211},{"__ignoreMap":8},[3212],{"type":23,"value":3207},{"type":18,"tag":1008,"props":3214,"children":3216},{"id":3215},"_3-변수-호이스팅",[3217],{"type":23,"value":3218},"3. 변수 호이스팅",{"type":18,"tag":70,"props":3220,"children":3223},{"className":3221,"code":3222,"language":12,"meta":8},[73],"console.log(foo);\n\nfoo = 123;\n\nconsole.log(foo);\n\nvar foo;\n",[3224],{"type":18,"tag":77,"props":3225,"children":3226},{"__ignoreMap":8},[3227],{"type":23,"value":3222},{"type":18,"tag":58,"props":3229,"children":3231},{"id":3230},"let-키워드",[3232],{"type":23,"value":3233},"let 키워드",{"type":18,"tag":1008,"props":3235,"children":3237},{"id":3236},"_1-변수-중복-선언-금지",[3238],{"type":23,"value":3239},"1. 변수 중복 선언 금지",{"type":18,"tag":70,"props":3241,"children":3244},{"className":3242,"code":3243,"language":12,"meta":8},[73],"var foo = 123;\nvar foo = 456;\n\nlet bar = 123;\nlet bar = 123; // SyntaxError\n",[3245],{"type":18,"tag":77,"props":3246,"children":3247},{"__ignoreMap":8},[3248],{"type":23,"value":3243},{"type":18,"tag":1008,"props":3250,"children":3252},{"id":3251},"_2-블록-레벨-스코프",[3253],{"type":23,"value":3254},"2. 블록 레벨 스코프",{"type":18,"tag":70,"props":3256,"children":3259},{"className":3257,"code":3258,"language":12,"meta":8},[73],"let foo = 1;\n\n{\n    let foo = 2;\n    let bar = 3;\n}\nconsole.log(foo); // 1\nconsole.log(bar); // ReferenceError\n",[3260],{"type":18,"tag":77,"props":3261,"children":3262},{"__ignoreMap":8},[3263],{"type":23,"value":3258},{"type":18,"tag":1008,"props":3265,"children":3267},{"id":3266},"_3-변수-호이스팅-1",[3268],{"type":23,"value":3218},{"type":18,"tag":1334,"props":3270,"children":3271},{},[3272,3277],{"type":18,"tag":212,"props":3273,"children":3274},{},[3275],{"type":23,"value":3276},"var 키워드는 런타임 이전에 선언 단계와 초기화 단계가 한번에 진행됨",{"type":18,"tag":212,"props":3278,"children":3279},{},[3280,3282],{"type":23,"value":3281},"let 키워드는 런타임 이전에 선언 단계와 초기화 단계가 분리되어 진행\n",{"type":18,"tag":1334,"props":3283,"children":3284},{},[3285],{"type":18,"tag":212,"props":3286,"children":3287},{},[3288,3290,3295],{"type":23,"value":3289},"let 키워드로 선언한 변수는 스코프의 시작 지점부터 초기화 단계 시작 지점(변수 선언문)까지 변수를 참조할 수 없다. ",{"type":18,"tag":265,"props":3291,"children":3292},{},[3293],{"type":23,"value":3294},"스코프의 시작 지점부터 초기화 시작 시작 지점",{"type":23,"value":3296},"까지 변수를 참조할 수 없는 구간을 일시적 사각지대(TDZ)라고 부른다.",{"type":18,"tag":70,"props":3298,"children":3301},{"className":3299,"code":3300,"language":12,"meta":8},[73],"console.log(foo); // ReferenceError\nlet foo;\n",[3302],{"type":18,"tag":77,"props":3303,"children":3304},{"__ignoreMap":8},[3305],{"type":23,"value":3300},{"type":18,"tag":19,"props":3307,"children":3308},{},[3309],{"type":23,"value":28},{"type":18,"tag":1334,"props":3311,"children":3312},{},[3313,3318,3323],{"type":18,"tag":212,"props":3314,"children":3315},{},[3316],{"type":23,"value":3317},"let 키워드는 호이스팅이 발생하지 않는 것처럼 보인다. 하지만 그렇지 않다. 아래 코드를 보면 호이스팅이 발생하지 않는다면 1이 출력 되어야 하는데 참조 에러가 발생한다.",{"type":18,"tag":212,"props":3319,"children":3320},{},[3321],{"type":23,"value":3322},"자바스크립트는 모든 선언을 호이스팅한다. (단, let, const class를 사용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작한다.)",{"type":18,"tag":212,"props":3324,"children":3325},{},[3326,3328,3334,3336,3342],{"type":23,"value":3327},"간단히 말해서, **",{"type":18,"tag":77,"props":3329,"children":3331},{"className":3330},[],[3332],{"type":23,"value":3333},"let",{"type":23,"value":3335},"**과 **",{"type":18,"tag":77,"props":3337,"children":3339},{"className":3338},[],[3340],{"type":23,"value":3341},"const",{"type":23,"value":3343},"**는 선언된 블록 스코프 내에서 선언 지점 이전에는 \"존재하지 않는 것\"처럼 취급됩니다. 이 구간을 TDZ라고 합니다.",{"type":18,"tag":70,"props":3345,"children":3348},{"className":3346,"code":3347,"language":12,"meta":8},[73],"let foo = 1;\n{\n    console.log(foo); // TDZ\n    let foo = 2; // 초기화 시작 지점\n}\n",[3349],{"type":18,"tag":77,"props":3350,"children":3351},{"__ignoreMap":8},[3352],{"type":23,"value":3347},{"type":18,"tag":1008,"props":3354,"children":3356},{"id":3355},"_4-전역-객체와-let",[3357],{"type":23,"value":3358},"4. 전역 객체와 let",{"type":18,"tag":1334,"props":3360,"children":3361},{},[3362,3367],{"type":18,"tag":212,"props":3363,"children":3364},{},[3365],{"type":23,"value":3366},"전역으로 선언한 var는 window 객체에 프로퍼티가 된다.",{"type":18,"tag":212,"props":3368,"children":3369},{},[3370,3372],{"type":23,"value":3371},"let 키워드로 선언한 전연 변수는 window 객체에 프로퍼티가 아니다.\n",{"type":18,"tag":1334,"props":3373,"children":3374},{},[3375],{"type":18,"tag":212,"props":3376,"children":3377},{},[3378],{"type":23,"value":3379},"let 전역 변수는 보이지 않는 개념적인 블록내에 존재한다.",{"type":18,"tag":70,"props":3381,"children":3384},{"className":3382,"code":3383,"language":12,"meta":8},[73],"var x = 1;\ny = 2;\n\nfunction foo(){}\n\nconsole.log(window.x);\nconsole.log(window.y);\nconsole.log(window.foo);\n\n-------\n\nlet x = 1;\nconsole.log(window.x); // undefined\n",[3385],{"type":18,"tag":77,"props":3386,"children":3387},{"__ignoreMap":8},[3388],{"type":23,"value":3383},{"type":18,"tag":58,"props":3390,"children":3392},{"id":3391},"const-키워드",[3393],{"type":23,"value":3394},"const 키워드",{"type":18,"tag":1008,"props":3396,"children":3398},{"id":3397},"_1-선언과-초기화",[3399],{"type":23,"value":3400},"1. 선언과 초기화",{"type":18,"tag":70,"props":3402,"children":3405},{"className":3403,"code":3404,"language":12,"meta":8},[73],"const foo = 1;\n\nconst foo; // SyntaxError\n",[3406],{"type":18,"tag":77,"props":3407,"children":3408},{"__ignoreMap":8},[3409],{"type":23,"value":3404},{"type":18,"tag":1008,"props":3411,"children":3413},{"id":3412},"_2-재할당-금지",[3414],{"type":23,"value":3415},"2. 재할당 금지",{"type":18,"tag":70,"props":3417,"children":3420},{"className":3418,"code":3419,"language":12,"meta":8},[73],"const foo = 1;\nfoo = 2; // TypeError\n",[3421],{"type":18,"tag":77,"props":3422,"children":3423},{"__ignoreMap":8},[3424],{"type":23,"value":3419},{"type":18,"tag":1008,"props":3426,"children":3428},{"id":3427},"_3-상수",[3429],{"type":23,"value":3430},"3. 상수",{"type":18,"tag":70,"props":3432,"children":3435},{"className":3433,"code":3434,"language":12,"meta":8},[73],"const TAX_RATE = 0.1;\n\nlet preTaxPrice = 100;\n\nlet afterTaxPrice = preTaxPrice + (preTaxPrice * TAX_RATE);\n",[3436],{"type":18,"tag":77,"props":3437,"children":3438},{"__ignoreMap":8},[3439],{"type":23,"value":3434},{"type":18,"tag":1008,"props":3441,"children":3443},{"id":3442},"_4-const-키워드와-객체",[3444],{"type":23,"value":3445},"4. const 키워드와 객체",{"type":18,"tag":1334,"props":3447,"children":3448},{},[3449],{"type":18,"tag":212,"props":3450,"children":3451},{},[3452,3454],{"type":23,"value":3453},"const 키워드로 선언된 변수에 원시 값을 할당한 경우 값을 변경할 수 없다. 하지만 객체를 할당한 경우 값을 변경할 수 있다.\n",{"type":18,"tag":1334,"props":3455,"children":3456},{},[3457,3462],{"type":18,"tag":212,"props":3458,"children":3459},{},[3460],{"type":23,"value":3461},"그 이유는 원시 값은 변경 불가능한 값이지만",{"type":18,"tag":212,"props":3463,"children":3464},{},[3465],{"type":23,"value":3466},"객체는 변경 가능한 값이기 때문에 재할당 없이 직접 변경이 가능하다.",{"type":18,"tag":70,"props":3468,"children":3471},{"className":3469,"code":3470,"language":12,"meta":8},[73],"const person = {\n    name: 'Lee'\n};\n\nperson.name = 'kim';\n\nconsole.log(person.name); // kim\n",[3472],{"type":18,"tag":77,"props":3473,"children":3474},{"__ignoreMap":8},[3475],{"type":23,"value":3470},{"type":18,"tag":19,"props":3477,"children":3478},{},[3479,3481,3486],{"type":23,"value":3480},"const는 재할당을 금지할 뿐 “",{"type":18,"tag":265,"props":3482,"children":3483},{},[3484],{"type":23,"value":3485},"불변",{"type":23,"value":3487},"”을 의미하지는 않는다.",{"type":18,"tag":19,"props":3489,"children":3490},{},[3491],{"type":23,"value":28},{"type":18,"tag":19,"props":3493,"children":3494},{},[3495],{"type":18,"tag":265,"props":3496,"children":3497},{},[3498],{"type":23,"value":3499},"결론: ES6를 사용한다면 var를 쓸 이유는 없다.",{"type":18,"tag":19,"props":3501,"children":3502},{},[3503],{"type":23,"value":28},{"title":8,"searchDepth":429,"depth":429,"links":3505},[3506,3507,3508,3509,3510,3511,3512,3513,3514,3515,3516],{"id":3160,"depth":429,"text":3163},{"id":3183,"depth":429,"text":3186},{"id":3215,"depth":429,"text":3218},{"id":3236,"depth":429,"text":3239},{"id":3251,"depth":429,"text":3254},{"id":3266,"depth":429,"text":3218},{"id":3355,"depth":429,"text":3358},{"id":3397,"depth":429,"text":3400},{"id":3412,"depth":429,"text":3415},{"id":3427,"depth":429,"text":3430},{"id":3442,"depth":429,"text":3445},"content:posts:2c7bdebd-8baa-46a1-b05b-61bda16d93f4.md","posts/2c7bdebd-8baa-46a1-b05b-61bda16d93f4.md",{"_path":3520,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":3521,"description":3522,"tags":3523,"date":3524,"body":3525,"_type":431,"_id":3602,"_source":433,"_file":3603,"_extension":435},"/posts/bd0acd00-ce9b-41ec-9a85-ef3e1d671c1c","자바스크립트 - 11. 전역 변수의 문제점","함수 내부에서 선언한 변수는 함수가 호출된 직후에 함수 몸체의 코드가 한 줄씩 순차적으로 실행되기 이전에 자바스크립트 엔진에 의해 먼저 실행된다.",[12],"2024-02-18T00:00:00.000Z",{"type":15,"children":3526,"toc":3600},[3527,3531,3535,3544,3548,3553,3558,3563,3568,3572,3581,3586,3591,3595],{"type":18,"tag":19,"props":3528,"children":3529},{},[3530],{"type":23,"value":3522},{"type":18,"tag":19,"props":3532,"children":3533},{},[3534],{"type":23,"value":28},{"type":18,"tag":70,"props":3536,"children":3539},{"className":3537,"code":3538,"language":12,"meta":8},[73],"function foo() {\n    var x = 'local';\n    console.log(x); // local\n    return x;\n}\n\nfoo();\n",[3540],{"type":18,"tag":77,"props":3541,"children":3542},{"__ignoreMap":8},[3543],{"type":23,"value":3538},{"type":18,"tag":19,"props":3545,"children":3546},{},[3547],{"type":23,"value":28},{"type":18,"tag":19,"props":3549,"children":3550},{},[3551],{"type":23,"value":3552},"foo() 호출하면 안에 코드가 한줄 씩 실행되기 전 자바스크립트 엔진은 x 변수를 선언하고 undefined로 할당한다.",{"type":18,"tag":19,"props":3554,"children":3555},{},[3556],{"type":23,"value":3557},"그후 함수안에 코드들이 한줄 한줄 실행 되면서 x 변수에 local이 할당된다.",{"type":18,"tag":19,"props":3559,"children":3560},{},[3561],{"type":23,"value":3562},"그리고 함수가 종료하면 x 변수도 소멸되어 생명 주기가 종료된다.",{"type":18,"tag":19,"props":3564,"children":3565},{},[3566],{"type":23,"value":3567},"즉, 지역 변수의 생명 주기는 함수의 생명 주기와 일치한다.",{"type":18,"tag":19,"props":3569,"children":3570},{},[3571],{"type":23,"value":28},{"type":18,"tag":70,"props":3573,"children":3576},{"className":3574,"code":3575,"language":12,"meta":8},[73],"var x = 'global';\nfunction foo() {\n    console.log(x); // undefined\n    var x = 'local';\n}\nfoo();\n",[3577],{"type":18,"tag":77,"props":3578,"children":3579},{"__ignoreMap":8},[3580],{"type":23,"value":3575},{"type":18,"tag":19,"props":3582,"children":3583},{},[3584],{"type":23,"value":3585},"위 코드를 보면 global이 출력될거 같지만 undefined로 출력된다. 그 이유는 지역 변수는 함수 전체에서 유효하기 때문이다. 변수 할당문이 실행되기 전에 undefined로 할당되었기 때문에 undefined가 출력 되는 것이다.",{"type":18,"tag":19,"props":3587,"children":3588},{},[3589],{"type":23,"value":3590},"호이스팅은 스코프를 단위로 동작한다.",{"type":18,"tag":19,"props":3592,"children":3593},{},[3594],{"type":23,"value":28},{"type":18,"tag":19,"props":3596,"children":3597},{},[3598],{"type":23,"value":3599},"전역 객체: 코드가 실행되기 이전 단게에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체. 브라우저에서는 window, Nodejs에서는 global 객체를 의미. 전역 객체는 빌트인 객체와 호스트 객체, 그리고 var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.",{"title":8,"searchDepth":429,"depth":429,"links":3601},[],"content:posts:bd0acd00-ce9b-41ec-9a85-ef3e1d671c1c.md","posts/bd0acd00-ce9b-41ec-9a85-ef3e1d671c1c.md",{"_path":3605,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":3606,"description":3607,"tags":3608,"date":3609,"body":3610,"_type":431,"_id":3852,"_source":433,"_file":3853,"_extension":435},"/posts/dd772cec-2501-4d07-b897-2626c54be01e","자바스크립트 - 10. 스코프","스코프 (유효범위)",[12],"2024-02-17T00:00:00.000Z",{"type":15,"children":3611,"toc":3850},[3612,3618,3622,3626,3631,3636,3640,3645,3649,3654,3658,3663,3669,3674,3682,3688,3699,3707,3712,3718,3723,3732,3736,3741,3745,3749,3758,3762,3767,3780,3784,3789,3793,3798,3841,3846],{"type":18,"tag":58,"props":3613,"children":3615},{"id":3614},"스코프란",[3616],{"type":23,"value":3617},"스코프란?",{"type":18,"tag":19,"props":3619,"children":3620},{},[3621],{"type":23,"value":3607},{"type":18,"tag":19,"props":3623,"children":3624},{},[3625],{"type":23,"value":28},{"type":18,"tag":19,"props":3627,"children":3628},{},[3629],{"type":23,"value":3630},"모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정 된다.",{"type":18,"tag":19,"props":3632,"children":3633},{},[3634],{"type":23,"value":3635},"이를 스코프라 한다. 즉, 스코프는 식별자가 유효한 범위다.",{"type":18,"tag":19,"props":3637,"children":3638},{},[3639],{"type":23,"value":28},{"type":18,"tag":19,"props":3641,"children":3642},{},[3643],{"type":23,"value":3644},"자바스크립트 엔진은 이름이 같은 두 개의 변수 중에서 어떤 변수를 참조해야 할 것인지를 결정한다. 이를 식별자 결정이라 한다. 스코프란 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙이라고도 할 수 있다.",{"type":18,"tag":19,"props":3646,"children":3647},{},[3648],{"type":23,"value":28},{"type":18,"tag":19,"props":3650,"children":3651},{},[3652],{"type":23,"value":3653},"스코프란 개념이 없다면 같은 이름을 갖는 변수는 충돌을 일으키므로 프로그램 전체에서 하나밖에 사용할 수 없다.",{"type":18,"tag":19,"props":3655,"children":3656},{},[3657],{"type":23,"value":28},{"type":18,"tag":1776,"props":3659,"children":3660},{"emogi":1778,"color":1779},[3661],{"type":23,"value":3662},"코드가 어디서 실행되며 주변에 어떤 코드가 있는지를 “렉시컬 환경(lexical environment)”이라고 부른다.",{"type":18,"tag":58,"props":3664,"children":3666},{"id":3665},"스코프의-종류",[3667],{"type":23,"value":3668},"스코프의 종류",{"type":18,"tag":19,"props":3670,"children":3671},{},[3672],{"type":23,"value":3673},"변수는 자신이 선언된 위치에 의해 자신이 유효한 범위인 스코프가 결정된다.",{"type":18,"tag":1334,"props":3675,"children":3676},{},[3677],{"type":18,"tag":212,"props":3678,"children":3679},{},[3680],{"type":23,"value":3681},"전역 스코프, 지역 스코프",{"type":18,"tag":58,"props":3683,"children":3685},{"id":3684},"스코프-체인",[3686],{"type":23,"value":3687},"스코프 체인",{"type":18,"tag":19,"props":3689,"children":3690},{},[3691,3693,3697],{"type":23,"value":3692},"모든 스코프는 계층적으로 연결된다. 모든 지역 스코프의 최상위는 전역 스코프다. 이렇게 스코프가 계층적으로 연결된 것을 ",{"type":18,"tag":265,"props":3694,"children":3695},{},[3696],{"type":23,"value":3687},{"type":23,"value":3698},"이라 한다.",{"type":18,"tag":1334,"props":3700,"children":3701},{},[3702],{"type":18,"tag":212,"props":3703,"children":3704},{},[3705],{"type":23,"value":3706},"예를 들어 a라는 변수를 어떤 스코프에서 호출할 때 해당 스코프에 a가 없으면 스코프 체인을 통해 상위 스코프로 이동하여 검색을 한다.",{"type":18,"tag":1776,"props":3708,"children":3709},{"emogi":1778,"color":1779},[3710],{"type":23,"value":3711},"스코프 체인은 실행 컨텍스트의 렉시컬 환경을 단방향을 연결(chaining)한 것이다. 전역 렉시컬 환경은 코드가 로드되면 곧바로 생성되고 함수의 렉시컬 환경은 함수가 호출되면 곧바로 생성된다.",{"type":18,"tag":58,"props":3713,"children":3715},{"id":3714},"함수-레벨-스코프",[3716],{"type":23,"value":3717},"함수 레벨 스코프",{"type":18,"tag":19,"props":3719,"children":3720},{},[3721],{"type":23,"value":3722},"var 키워드를 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정",{"type":18,"tag":70,"props":3724,"children":3727},{"className":3725,"code":3726,"language":12,"meta":8},[73],"var x = 1;\nif (true) {\n    var x = 10;\n}\n\nconsole.log(x); // 10\n\nfunction test() {\n    var x = 20;\n    console.log(x); // 20\n}\nconsole.log(x); // 10;\n",[3728],{"type":18,"tag":77,"props":3729,"children":3730},{"__ignoreMap":8},[3731],{"type":23,"value":3726},{"type":18,"tag":19,"props":3733,"children":3734},{},[3735],{"type":23,"value":28},{"type":18,"tag":19,"props":3737,"children":3738},{},[3739],{"type":23,"value":3740},"let, const는 블록 레벨 스코프를 지원한다.",{"type":18,"tag":19,"props":3742,"children":3743},{},[3744],{"type":23,"value":28},{"type":18,"tag":58,"props":3746,"children":3747},{"id":60},[3748],{"type":23,"value":63},{"type":18,"tag":70,"props":3750,"children":3753},{"className":3751,"code":3752,"language":12,"meta":8},[73],"var x = 1;\n\nfunction foo() {\n    var x = 10;\n    bar();\n}\n\nfunction bar() {\n    console.log(x);\n}\n\nfoo(); //\nbar(); //\n",[3754],{"type":18,"tag":77,"props":3755,"children":3756},{"__ignoreMap":8},[3757],{"type":23,"value":3752},{"type":18,"tag":19,"props":3759,"children":3760},{},[3761],{"type":23,"value":28},{"type":18,"tag":19,"props":3763,"children":3764},{},[3765],{"type":23,"value":3766},"프로그래밍 언어는 일반적으로 2가지 방식 중 한 가지 방식으로 함수의 상위 스코프를 결정",{"type":18,"tag":208,"props":3768,"children":3769},{},[3770,3775],{"type":18,"tag":212,"props":3771,"children":3772},{},[3773],{"type":23,"value":3774},"함수를 어디서 호출 했는지 (동적 스코프)",{"type":18,"tag":212,"props":3776,"children":3777},{},[3778],{"type":23,"value":3779},"함수를 어디서 정의 했는지 (정적 스코프, 렉시컬 스코프)",{"type":18,"tag":19,"props":3781,"children":3782},{},[3783],{"type":23,"value":28},{"type":18,"tag":19,"props":3785,"children":3786},{},[3787],{"type":23,"value":3788},"자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.",{"type":18,"tag":19,"props":3790,"children":3791},{},[3792],{"type":23,"value":28},{"type":18,"tag":19,"props":3794,"children":3795},{},[3796],{"type":23,"value":3797},"동적 스코프(dynamic scoping)를 사용하는 프로그래밍 언어는 상대적으로 드뭅니다. 대부분의 현대 프로그래밍 언어는 정적 스코프(lexical scoping)를 사용합니다. 그러나 여전히 동적 스코프를 사용하거나 지원하는 언어들이 있습니다:",{"type":18,"tag":208,"props":3799,"children":3800},{},[3801,3811,3821,3831],{"type":18,"tag":212,"props":3802,"children":3803},{},[3804,3809],{"type":18,"tag":265,"props":3805,"children":3806},{},[3807],{"type":23,"value":3808},"Bash 스크립팅 언어",{"type":23,"value":3810},": Bash와 같은 쉘 스크립팅 언어는 동적 스코프를 사용합니다. 예를 들어, 함수 내에서 선언된 변수는 그 함수가 호출된 컨텍스트에 따라 다른 값을 가질 수 있습니다.",{"type":18,"tag":212,"props":3812,"children":3813},{},[3814,3819],{"type":18,"tag":265,"props":3815,"children":3816},{},[3817],{"type":23,"value":3818},"Emacs Lisp",{"type":23,"value":3820},": Emacs 텍스트 에디터의 확장 언어인 Emacs Lisp는 기본적으로 동적 스코프를 사용하지만, 정적 스코프도 선택적으로 사용할 수 있습니다.",{"type":18,"tag":212,"props":3822,"children":3823},{},[3824,3829],{"type":18,"tag":265,"props":3825,"children":3826},{},[3827],{"type":23,"value":3828},"Perl",{"type":23,"value":3830},": Perl은 기본적으로 정적 스코프를 사용하지만, 특별한 키워드와 문법을 사용하여 동적 스코프를 사용할 수 있습니다.",{"type":18,"tag":212,"props":3832,"children":3833},{},[3834,3839],{"type":18,"tag":265,"props":3835,"children":3836},{},[3837],{"type":23,"value":3838},"Common Lisp",{"type":23,"value":3840},": Common Lisp는 동적 스코프와 정적 스코프를 모두 지원합니다. 프로그래머는 변수를 선언할 때 스코프 유형을 선택할 수 있습니다.",{"type":18,"tag":19,"props":3842,"children":3843},{},[3844],{"type":23,"value":3845},"동적 스코프는 실행 시점에 변수의 바인딩이 결정되며, 이는 호출 스택의 컨텍스트에 따라 달라집니다. 반면, 정적 스코프(lexical scoping)는 코드를 작성하는 시점에서 변수의 범위가 결정되며, 함수나 블록의 위치에 의존합니다. 동적 스코프는 특정 유형의 문제를 해결하는 데 유용할 수 있지만, 프로그램의 동작을 예측하고 이해하기 어렵게 만들 수 있기 때문에 현대 언어에서는 일반적으로 정적 스코프가 선호됩니다.",{"type":18,"tag":19,"props":3847,"children":3848},{},[3849],{"type":23,"value":28},{"title":8,"searchDepth":429,"depth":429,"links":3851},[],"content:posts:dd772cec-2501-4d07-b897-2626c54be01e.md","posts/dd772cec-2501-4d07-b897-2626c54be01e.md",{"_path":3855,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":3856,"description":8,"tags":3857,"date":3858,"body":3859,"_type":431,"_id":4588,"_source":433,"_file":4589,"_extension":435},"/posts/96c9d4b7-fef3-492c-aedb-b53a58deebb1","자바스크립트 - 9. 함수",[12],"2024-02-16T00:00:00.000Z",{"type":15,"children":3860,"toc":4574},[3861,3867,3872,3881,3886,3906,3911,3916,3920,3925,3930,3934,3946,3950,3956,3961,3967,3980,3989,3993,4003,4008,4017,4022,4026,4047,4059,4063,4068,4081,4085,4090,4099,4111,4119,4123,4128,4133,4142,4146,4154,4158,4167,4172,4185,4194,4198,4210,4214,4224,4228,4234,4243,4247,4252,4257,4261,4267,4276,4281,4286,4291,4295,4300,4318,4322,4327,4331,4336,4365,4369,4374,4378,4384,4393,4397,4402,4406,4419,4432,4436,4442,4448,4457,4463,4468,4473,4478,4483,4502,4507,4512,4517,4522,4531,4540,4546,4551,4556,4565],{"type":18,"tag":1008,"props":3862,"children":3864},{"id":3863},"함수-리터럴",[3865],{"type":23,"value":3866},"함수 리터럴",{"type":18,"tag":19,"props":3868,"children":3869},{},[3870],{"type":23,"value":3871},"함수 리터럴은 function 키워드, 함수 이름, 매개 변수 목록, 함수 몸체로 구성된다.",{"type":18,"tag":70,"props":3873,"children":3876},{"className":3874,"code":3875,"language":12,"meta":8},[73],"var f = function add(x, y) {\n    return x + y;\n}\n",[3877],{"type":18,"tag":77,"props":3878,"children":3879},{"__ignoreMap":8},[3880],{"type":23,"value":3875},{"type":18,"tag":19,"props":3882,"children":3883},{},[3884],{"type":23,"value":3885},"함수이름: add",{"type":18,"tag":1334,"props":3887,"children":3888},{},[3889,3901],{"type":18,"tag":212,"props":3890,"children":3891},{},[3892,3894,3899],{"type":23,"value":3893},"함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자 (",{"type":18,"tag":265,"props":3895,"children":3896},{},[3897],{"type":23,"value":3898},"중요",{"type":23,"value":3900},"!)",{"type":18,"tag":212,"props":3902,"children":3903},{},[3904],{"type":23,"value":3905},"함수 이름은 생략할 수 있다. 이름이 있는 함수를 기명 함수, 이름이 없는 함수를 무명/익명 함수라 한다.",{"type":18,"tag":19,"props":3907,"children":3908},{},[3909],{"type":23,"value":3910},"매개변수: x, y",{"type":18,"tag":19,"props":3912,"children":3913},{},[3914],{"type":23,"value":3915},"몸체: return x + y;",{"type":18,"tag":19,"props":3917,"children":3918},{},[3919],{"type":23,"value":28},{"type":18,"tag":19,"props":3921,"children":3922},{},[3923],{"type":23,"value":3924},"리터럴: 사람이 이해할 수 있는 문자나 약속된 기호를 사용해 값을 생성하는 표기 방식, 즉 리터럴은 값을 생성하기 위한 표기법 (용어 계속 숙지)",{"type":18,"tag":19,"props":3926,"children":3927},{},[3928],{"type":23,"value":3929},"함수 리터럴도 평가되어 값을 생성하며, 이 값은 객체다.",{"type":18,"tag":19,"props":3931,"children":3932},{},[3933],{"type":23,"value":28},{"type":18,"tag":19,"props":3935,"children":3936},{},[3937,3939,3944],{"type":23,"value":3938},"즉, ",{"type":18,"tag":265,"props":3940,"children":3941},{},[3942],{"type":23,"value":3943},"함수는 객체다!",{"type":23,"value":3945}," (다른 프로그래밍 언어와 구별되는 자바스크립트의 중요한 특징)",{"type":18,"tag":19,"props":3947,"children":3948},{},[3949],{"type":23,"value":28},{"type":18,"tag":58,"props":3951,"children":3953},{"id":3952},"함수-정의",[3954],{"type":23,"value":3955},"함수 정의",{"type":18,"tag":1776,"props":3957,"children":3958},{"emogi":1778,"color":1779},[3959],{"type":23,"value":3960},"변수 선언과 함수 정의\n변수는 선언(declaration)한다고 했지만 함수는 정의(definition)한다고 표현했다.\n함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다.\n따라서 ECMAScript 사양에서도 변수에는 선언(variable declration), 함수에는 정의(function definition)라고 표현한다.",{"type":18,"tag":1008,"props":3962,"children":3964},{"id":3963},"함수-선언문-표현식이-아닌-문",[3965],{"type":23,"value":3966},"함수 선언문 (표현식이 아닌 문)",{"type":18,"tag":1334,"props":3968,"children":3969},{},[3970,3975],{"type":18,"tag":212,"props":3971,"children":3972},{},[3973],{"type":23,"value":3974},"함수 선언문은 함수리터럴과 형태가 동일하다.",{"type":18,"tag":212,"props":3976,"children":3977},{},[3978],{"type":23,"value":3979},"단, 함수 선언문은 함수 이름 생략 불가",{"type":18,"tag":70,"props":3981,"children":3984},{"className":3982,"code":3983,"language":12,"meta":8},[73],"// 함수 선언문\nfunction add(x, y) {\n    return x + y;\n}\n",[3985],{"type":18,"tag":77,"props":3986,"children":3987},{"__ignoreMap":8},[3988],{"type":23,"value":3983},{"type":18,"tag":19,"props":3990,"children":3991},{},[3992],{"type":23,"value":28},{"type":18,"tag":19,"props":3994,"children":3995},{},[3996,3998],{"type":23,"value":3997},"함수 선언문은 ",{"type":18,"tag":265,"props":3999,"children":4000},{},[4001],{"type":23,"value":4002},"표현식이 아닌 문",{"type":18,"tag":19,"props":4004,"children":4005},{},[4006],{"type":23,"value":4007},"표현식이 아닌 문은 변수에 할당할 수 없다고 했는데",{"type":18,"tag":70,"props":4009,"children":4012},{"className":4010,"code":4011,"language":12,"meta":8},[73],"var add = function add(x, y) {\n    return x + y;\n}\n",[4013],{"type":18,"tag":77,"props":4014,"children":4015},{"__ignoreMap":8},[4016],{"type":23,"value":4011},{"type":18,"tag":19,"props":4018,"children":4019},{},[4020],{"type":23,"value":4021},"하지만 위 코드를 보면 함수 선언문이 변수에 할당되는 것처럼 보인다.",{"type":18,"tag":19,"props":4023,"children":4024},{},[4025],{"type":23,"value":28},{"type":18,"tag":19,"props":4027,"children":4028},{},[4029,4031,4037,4039,4045],{"type":23,"value":4030},"이는 자바스크립트 엔진이 코드의 문맥에 따라 ",{"type":18,"tag":77,"props":4032,"children":4034},{"className":4033},[],[4035],{"type":23,"value":4036},"함수 선언문",{"type":23,"value":4038},"으로 해석하거나 ",{"type":18,"tag":77,"props":4040,"children":4042},{"className":4041},[],[4043],{"type":23,"value":4044},"함수 리터럴 표현식",{"type":23,"value":4046},"으로 해석하는 경우가 있기 때문. 코드 문맥에 따라 해석이 달라짐",{"type":18,"tag":19,"props":4048,"children":4049},{},[4050,4052,4057],{"type":23,"value":4051},"위와 같은 경우는 표현식인 문인 ",{"type":18,"tag":77,"props":4053,"children":4055},{"className":4054},[],[4056],{"type":23,"value":4044},{"type":23,"value":4058},"으로 해석 되었기 때문에 가능",{"type":18,"tag":19,"props":4060,"children":4061},{},[4062],{"type":23,"value":28},{"type":18,"tag":19,"props":4064,"children":4065},{},[4066],{"type":23,"value":4067},"기명 함수 리터럴은 중의적인 코드다.",{"type":18,"tag":208,"props":4069,"children":4070},{},[4071,4076],{"type":18,"tag":212,"props":4072,"children":4073},{},[4074],{"type":23,"value":4075},"단독으로 사용하면 함수 선언문으로 해석",{"type":18,"tag":212,"props":4077,"children":4078},{},[4079],{"type":23,"value":4080},"값으로 평가되어야 하는 문맥 (할당, 피연산자)에서는 함수 리터럴 표현식으로 해석",{"type":18,"tag":19,"props":4082,"children":4083},{},[4084],{"type":23,"value":28},{"type":18,"tag":19,"props":4086,"children":4087},{},[4088],{"type":23,"value":4089},"아래 코드를 보자",{"type":18,"tag":70,"props":4091,"children":4094},{"className":4092,"code":4093,"language":12,"meta":8},[73],"**//** 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석\nfunction foo() {\n    console.log('foo');\n}\n\nfoo(); // foo\n\n// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석\n// 그룹연산자()안에 피연산자 함수 리터럴은 함수 리터럴 표현식으로 해석\n(function bar() { console.log('bar')});\nbar(); // RefefenceError: bar is not defined\n",[4095],{"type":18,"tag":77,"props":4096,"children":4097},{"__ignoreMap":8},[4098],{"type":23,"value":4093},{"type":18,"tag":19,"props":4100,"children":4101},{},[4102,4104,4109],{"type":23,"value":4103},"bar()를 왜 호출을 못할까? 그 이유는 ",{"type":18,"tag":77,"props":4105,"children":4107},{"className":4106},[],[4108],{"type":23,"value":4044},{"type":23,"value":4110},"으로 해석되기 때문이다. 위 함수 리터럴에서 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자라고 했다. 그래서 함수 내부가 아닌 외부에서는 호출이 불가능한 것이다.",{"type":18,"tag":1449,"props":4112,"children":4113},{},[4114],{"type":18,"tag":19,"props":4115,"children":4116},{},[4117],{"type":23,"value":4118},"함수 리터럴과 함수 리터럴 표현식 헷갈리지 말기",{"type":18,"tag":19,"props":4120,"children":4121},{},[4122],{"type":23,"value":28},{"type":18,"tag":19,"props":4124,"children":4125},{},[4126],{"type":23,"value":4127},"위 예제에서 함수 선언문으로 정의된 함수는 foo라는 이름으로 호출할 수 있었다. foo는 함수 몸체 내부에서만 유효한 식별자인데 그러면 foo()는 어떻게 호출이 가능한걸까? 그 이유는 자바스크립트 엔진이 암묵적으로 식별자를 생성하기 때문이다.",{"type":18,"tag":19,"props":4129,"children":4130},{},[4131],{"type":23,"value":4132},"즉 자바스크립트 엔진은 함수 선언문을 해석해 함수 객체를 생성한다.",{"type":18,"tag":70,"props":4134,"children":4137},{"className":4135,"code":4136,"language":12,"meta":8},[73],"function foo() {\n    console.log('foo');\n}\n\n// 자바스크립트 엔진이 암묵적으로 아래와 같이 생성한다. (아래와 같이 동작하는건 알수 없으나 식별자가 생성된다는 것을 보여주기 위한 예제)\nvar foo = function foo() {\n    console.log('foo');\n}\n\n// 그래서 함수 표현식은 함수 이름 생략이 불가능하구나?\n",[4138],{"type":18,"tag":77,"props":4139,"children":4140},{"__ignoreMap":8},[4141],{"type":23,"value":4136},{"type":18,"tag":19,"props":4143,"children":4144},{},[4145],{"type":23,"value":28},{"type":18,"tag":19,"props":4147,"children":4148},{},[4149],{"type":18,"tag":265,"props":4150,"children":4151},{},[4152],{"type":23,"value":4153},"함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다!",{"type":18,"tag":19,"props":4155,"children":4156},{},[4157],{"type":23,"value":28},{"type":18,"tag":70,"props":4159,"children":4162},{"className":4160,"code":4161,"language":12,"meta":8},[73],"var foo = function bar(n) {\n    bar(); // 함수이름은 함수 몸체 내에서만 사용 가능\n}\n",[4163],{"type":18,"tag":77,"props":4164,"children":4165},{"__ignoreMap":8},[4166],{"type":23,"value":4161},{"type":18,"tag":19,"props":4168,"children":4169},{},[4170],{"type":23,"value":4171},"용어 구분",{"type":18,"tag":1334,"props":4173,"children":4174},{},[4175,4180],{"type":18,"tag":212,"props":4176,"children":4177},{},[4178],{"type":23,"value":4179},"식별자: foo",{"type":18,"tag":212,"props":4181,"children":4182},{},[4183],{"type":23,"value":4184},"함수이름 bar",{"type":18,"tag":70,"props":4186,"children":4189},{"className":4187,"code":4188,"language":12,"meta":8},[73],"var foo = function () {}\n",[4190],{"type":18,"tag":77,"props":4191,"children":4192},{"__ignoreMap":8},[4193],{"type":23,"value":4188},{"type":18,"tag":19,"props":4195,"children":4196},{},[4197],{"type":23,"value":4171},{"type":18,"tag":1334,"props":4199,"children":4200},{},[4201,4205],{"type":18,"tag":212,"props":4202,"children":4203},{},[4204],{"type":23,"value":4179},{"type":18,"tag":212,"props":4206,"children":4207},{},[4208],{"type":23,"value":4209},"함수이름: 없음 (익명함수)",{"type":18,"tag":19,"props":4211,"children":4212},{},[4213],{"type":23,"value":28},{"type":18,"tag":19,"props":4215,"children":4216},{},[4217],{"type":18,"tag":1438,"props":4218,"children":4221},{"href":4219,"rel":4220},"https://chat.openai.com/share/512948d1-1316-4bba-afaf-42e41498d5c8",[1442],[4222],{"type":23,"value":4223},"bookmark",{"type":18,"tag":19,"props":4225,"children":4226},{},[4227],{"type":23,"value":28},{"type":18,"tag":1008,"props":4229,"children":4231},{"id":4230},"함수-표현식표현식인-문",[4232],{"type":23,"value":4233},"함수 표현식(표현식인 문)",{"type":18,"tag":70,"props":4235,"children":4238},{"className":4236,"code":4237,"language":12,"meta":8},[73],"var add = function(x, y) {\n    return x + y;\n}\n",[4239],{"type":18,"tag":77,"props":4240,"children":4241},{"__ignoreMap":8},[4242],{"type":23,"value":4237},{"type":18,"tag":19,"props":4244,"children":4245},{},[4246],{"type":23,"value":28},{"type":18,"tag":19,"props":4248,"children":4249},{},[4250],{"type":23,"value":4251},"자바스크립트는 함수는 일급 객체다.",{"type":18,"tag":19,"props":4253,"children":4254},{},[4255],{"type":23,"value":4256},"함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이러한 함수 정의 방식을 함수 표현식(function expression)이라 한다.",{"type":18,"tag":19,"props":4258,"children":4259},{},[4260],{"type":23,"value":28},{"type":18,"tag":1008,"props":4262,"children":4264},{"id":4263},"함수-생성-시점과-함수-호이스팅",[4265],{"type":23,"value":4266},"함수 생성 시점과 함수 호이스팅",{"type":18,"tag":70,"props":4268,"children":4271},{"className":4269,"code":4270,"language":12,"meta":8},[73],"// 함수 참조\nconsole.log(add); // f add(a, b)\nconsole.log(sub); // undefined\n\n// 함수 호출\nconsole.log(add(2, 5)); // 7\nconsole.log(sub(2, 5)); // TypeError: sub is not a function\n\n// 함수 선언문\nfunction add(a, b) {\n    return a + b;\n}\n\n// 함수 표현식\nvar sub = function(a, b) {\n    return a - b;\n}\n\n",[4272],{"type":18,"tag":77,"props":4273,"children":4274},{"__ignoreMap":8},[4275],{"type":23,"value":4270},{"type":18,"tag":19,"props":4277,"children":4278},{},[4279],{"type":23,"value":4280},"함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다.",{"type":18,"tag":19,"props":4282,"children":4283},{},[4284],{"type":23,"value":4285},"함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다.",{"type":18,"tag":19,"props":4287,"children":4288},{},[4289],{"type":23,"value":4290},"이는 각 함수의 생성 시점이 다르기 때문이다.",{"type":18,"tag":19,"props":4292,"children":4293},{},[4294],{"type":23,"value":28},{"type":18,"tag":19,"props":4296,"children":4297},{},[4298],{"type":23,"value":4299},"함수선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행된다.",{"type":18,"tag":208,"props":4301,"children":4302},{},[4303,4308,4313],{"type":18,"tag":212,"props":4304,"children":4305},{},[4306],{"type":23,"value":4307},"함수 객체 생성",{"type":18,"tag":212,"props":4309,"children":4310},{},[4311],{"type":23,"value":4312},"함수 이름과 동일한 이름의 식별자 생성",{"type":18,"tag":212,"props":4314,"children":4315},{},[4316],{"type":23,"value":4317},"함수 객체를 식별자에 할당",{"type":18,"tag":19,"props":4319,"children":4320},{},[4321],{"type":23,"value":28},{"type":18,"tag":19,"props":4323,"children":4324},{},[4325],{"type":23,"value":4326},"이처럼 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅이라 한다.",{"type":18,"tag":19,"props":4328,"children":4329},{},[4330],{"type":23,"value":28},{"type":18,"tag":19,"props":4332,"children":4333},{},[4334],{"type":23,"value":4335},"함수 호이스팅과 변수 호이스팅 차이",{"type":18,"tag":208,"props":4337,"children":4338},{},[4339,4352],{"type":18,"tag":212,"props":4340,"children":4341},{},[4342,4344],{"type":23,"value":4343},"변수 호이스팅은 undefined로 초기화\n",{"type":18,"tag":208,"props":4345,"children":4346},{},[4347],{"type":18,"tag":212,"props":4348,"children":4349},{},[4350],{"type":23,"value":4351},"변수 호이스팅은 선언 이전에 호출하면 undefined로 평가 됨",{"type":18,"tag":212,"props":4353,"children":4354},{},[4355,4357],{"type":23,"value":4356},"함수 호이스팅은 함수 객체로 초기화\n",{"type":18,"tag":208,"props":4358,"children":4359},{},[4360],{"type":18,"tag":212,"props":4361,"children":4362},{},[4363],{"type":23,"value":4364},"함수 호이스팅은 함수 선언문 이전에 호출하면 호출이 가능",{"type":18,"tag":19,"props":4366,"children":4367},{},[4368],{"type":23,"value":28},{"type":18,"tag":19,"props":4370,"children":4371},{},[4372],{"type":23,"value":4373},"함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.",{"type":18,"tag":19,"props":4375,"children":4376},{},[4377],{"type":23,"value":28},{"type":18,"tag":1666,"props":4379,"children":4381},{"id":4380},"참조에-의한-전달과-외부-상태의-변경",[4382],{"type":23,"value":4383},"참조에 의한 전달과 외부 상태의 변경",{"type":18,"tag":70,"props":4385,"children":4388},{"className":4386,"code":4387,"language":12,"meta":8},[73],"function test(primitive, obj) {\n    primitive += 100;\n    obj.name = 'kim';\n}\n\nvar num = 100;\nvar person = {\n    name: 'lee';\n};\n\nconsole.log(num); // 100;\nconsole.log(person.name); // lee;\n\ntest(num, person);\n\nconsole.log(num); // 100\nconsole.log(person.name); // kim\n",[4389],{"type":18,"tag":77,"props":4390,"children":4391},{"__ignoreMap":8},[4392],{"type":23,"value":4387},{"type":18,"tag":19,"props":4394,"children":4395},{},[4396],{"type":23,"value":28},{"type":18,"tag":19,"props":4398,"children":4399},{},[4400],{"type":23,"value":4401},"함수 외부에서 함수 몸체 내부로 전달한 참조 값에 의해 원본 객체가 변경되는 부수 효과가 발생",{"type":18,"tag":19,"props":4403,"children":4404},{},[4405],{"type":23,"value":28},{"type":18,"tag":1334,"props":4407,"children":4408},{},[4409,4414],{"type":18,"tag":212,"props":4410,"children":4411},{},[4412],{"type":23,"value":4413},"객체의 변경을 추적하려면 옵저버 패턴 등을 통해 객체를 참조를 공유하는 모든 이들에게 변경 사실을 통지하고 이에 대처하는 추가 대응이 필요",{"type":18,"tag":212,"props":4415,"children":4416},{},[4417],{"type":23,"value":4418},"객체를 불변 객체로 만들어 사용하는것도 하나의 방법",{"type":18,"tag":19,"props":4420,"children":4421},{},[4422,4424,4430],{"type":23,"value":4423},"외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수를 ",{"type":18,"tag":77,"props":4425,"children":4427},{"className":4426},[],[4428],{"type":23,"value":4429},"순수 함수",{"type":23,"value":4431}," 라 한다.",{"type":18,"tag":19,"props":4433,"children":4434},{},[4435],{"type":23,"value":28},{"type":18,"tag":1008,"props":4437,"children":4439},{"id":4438},"다양한-함수의-형태",[4440],{"type":23,"value":4441},"다양한 함수의 형태",{"type":18,"tag":1666,"props":4443,"children":4445},{"id":4444},"즉시-실행-함수",[4446],{"type":23,"value":4447},"즉시 실행 함수",{"type":18,"tag":70,"props":4449,"children":4452},{"className":4450,"code":4451,"language":12,"meta":8},[73],"(function() {}());\n// 그룹 연산자()로 함수를 묶은 이유는 먼저 함수 리터럴을 평가해서 함수 객체를 생성하기 위해서다.\n\n// 따라서 먼저 함수 리터럴을 평가해서 함수 객체를 생성할 수 있다면 그룹 연산자 이외의 연산자를 사용해도 좋다.\n(function(){})();\n!function(){}()\n+function(){}()\n",[4453],{"type":18,"tag":77,"props":4454,"children":4455},{"__ignoreMap":8},[4456],{"type":23,"value":4451},{"type":18,"tag":1666,"props":4458,"children":4460},{"id":4459},"중첩-함수",[4461],{"type":23,"value":4462},"중첩 함수",{"type":18,"tag":19,"props":4464,"children":4465},{},[4466],{"type":23,"value":4467},"함수 내부에 정의된 함수를 중첩 함수 또는 내부 함수라 한다.",{"type":18,"tag":19,"props":4469,"children":4470},{},[4471],{"type":23,"value":4472},"중첩 함수를 포함하는 함수를 외부 함수라 부른다.",{"type":18,"tag":19,"props":4474,"children":4475},{},[4476],{"type":23,"value":4477},"일반적으로 중첩 함수는 자신을 포함하는 외부 함수를 돕는 헬퍼 함수의 역할을 한다.",{"type":18,"tag":1666,"props":4479,"children":4481},{"id":4480},"콜백함수",[4482],{"type":23,"value":4480},{"type":18,"tag":19,"props":4484,"children":4485},{},[4486,4488,4493,4495,4500],{"type":23,"value":4487},"함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 ",{"type":18,"tag":265,"props":4489,"children":4490},{},[4491],{"type":23,"value":4492},"콜백 함수",{"type":23,"value":4494},"라고 하며, 매개 변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 ",{"type":18,"tag":265,"props":4496,"children":4497},{},[4498],{"type":23,"value":4499},"고차 함수",{"type":23,"value":4501},"라고 한다.",{"type":18,"tag":19,"props":4503,"children":4504},{},[4505],{"type":23,"value":4506},"콜백함수도 고차 함수에 전달되어 헬퍼 함수의 역할을 한다.",{"type":18,"tag":19,"props":4508,"children":4509},{},[4510],{"type":23,"value":4511},"고차 함수는 콜백 함수를 자신의 일부분으로 합성한다.",{"type":18,"tag":19,"props":4513,"children":4514},{},[4515],{"type":23,"value":4516},"고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다.",{"type":18,"tag":19,"props":4518,"children":4519},{},[4520],{"type":23,"value":4521},"콜백 함수는 고차 함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.",{"type":18,"tag":70,"props":4523,"children":4526},{"className":4524,"code":4525,"language":12,"meta":8},[73],"// 고차함수\nfunction repeat(n, f) {\n    for (var i = 0; i \u003C n; i++) {\n        // 콜백 함수\n        f(i);\n    }\n}\n\nvar logAll = function(i) {\n    console.log(i);\n}\n",[4527],{"type":18,"tag":77,"props":4528,"children":4529},{"__ignoreMap":8},[4530],{"type":23,"value":4525},{"type":18,"tag":70,"props":4532,"children":4535},{"className":4533,"code":4534,"language":12,"meta":8},[73],"// 고차 함수 map\n[1, 2, 3].map(function (item) {});\n",[4536],{"type":18,"tag":77,"props":4537,"children":4538},{"__ignoreMap":8},[4539],{"type":23,"value":4534},{"type":18,"tag":1666,"props":4541,"children":4543},{"id":4542},"순수-함수와-비순수-함수",[4544],{"type":23,"value":4545},"순수 함수와 비순수 함수",{"type":18,"tag":19,"props":4547,"children":4548},{},[4549],{"type":23,"value":4550},"어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수 효과가 없는 함수를 순수 함수라 하고",{"type":18,"tag":19,"props":4552,"children":4553},{},[4554],{"type":23,"value":4555},"외부 상태에 의존하거나 외부 상태를 변경하는, 즉 부수 효과가 있는 함수를 비순수 함수라고 한다.",{"type":18,"tag":70,"props":4557,"children":4560},{"className":4558,"code":4559,"language":12,"meta":8},[73],"var count = 0;\n\n// 순수 함수 increase는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.\nfunction increase(n) {\n    return ++n;\n}\n// 순수 함수가 반환한 결과값을 변수에 재할당해서 상태를 변경\ncount = increase(count);\nconsole.log(count); // 1;\n",[4561],{"type":18,"tag":77,"props":4562,"children":4563},{"__ignoreMap":8},[4564],{"type":23,"value":4559},{"type":18,"tag":70,"props":4566,"children":4569},{"className":4567,"code":4568,"language":12,"meta":8},[73],"var count = 0;\n\n// 비순수 함수\nfunction increase() {\n    return ++count; // 외부 상태에 의존하며 외부 상태를 변경한다.\n}\n\n// 비순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려워진다.\nincrease(count);\nconsole.log(count); // 1;\n",[4570],{"type":18,"tag":77,"props":4571,"children":4572},{"__ignoreMap":8},[4573],{"type":23,"value":4568},{"title":8,"searchDepth":429,"depth":429,"links":4575},[4576,4577,4578,4579,4582],{"id":3863,"depth":429,"text":3866},{"id":3963,"depth":429,"text":3966},{"id":4230,"depth":429,"text":4233},{"id":4263,"depth":429,"text":4266,"children":4580},[4581],{"id":4380,"depth":2349,"text":4383},{"id":4438,"depth":429,"text":4441,"children":4583},[4584,4585,4586,4587],{"id":4444,"depth":2349,"text":4447},{"id":4459,"depth":2349,"text":4462},{"id":4480,"depth":2349,"text":4480},{"id":4542,"depth":2349,"text":4545},"content:posts:96c9d4b7-fef3-492c-aedb-b53a58deebb1.md","posts/96c9d4b7-fef3-492c-aedb-b53a58deebb1.md",{"_path":4591,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":4592,"description":4593,"tags":4594,"date":4595,"body":4596,"_type":431,"_id":5136,"_source":433,"_file":5137,"_extension":435},"/posts/8285cee9-dfcd-4a53-8b73-3ae542a267a9","자바스크립트 - 8. 원시 값과 객체의 비교","데이터 타입은 크게 원시 타입과 객체 타입으로 구분",[12],"2024-02-15T00:00:00.000Z",{"type":15,"children":4597,"toc":5126},[4598,4617,4621,4633,4645,4649,4777,4900,4904,4909,4915,4920,4929,4934,4939,4943,4948,4952,4958,4967,4975,4979,4988,4992,4998,5003,5012,5023,5027,5032,5041,5045,5049,5054,5058,5063,5076,5082,5091,5095,5100,5104,5107,5115],{"type":18,"tag":19,"props":4599,"children":4600},{},[4601,4603,4608,4610,4615],{"type":23,"value":4602},"데이터 타입은 크게 ",{"type":18,"tag":265,"props":4604,"children":4605},{},[4606],{"type":23,"value":4607},"원시 타입",{"type":23,"value":4609},"과 ",{"type":18,"tag":265,"props":4611,"children":4612},{},[4613],{"type":23,"value":4614},"객체 타입",{"type":23,"value":4616},"으로 구분",{"type":18,"tag":19,"props":4618,"children":4619},{},[4620],{"type":23,"value":28},{"type":18,"tag":19,"props":4622,"children":4623},{},[4624,4626,4631],{"type":23,"value":4625},"원시값은 식별자 메모리 주소에 ",{"type":18,"tag":265,"props":4627,"children":4628},{},[4629],{"type":23,"value":4630},"값",{"type":23,"value":4632},"이 저장되어있고",{"type":18,"tag":19,"props":4634,"children":4635},{},[4636,4638,4643],{"type":23,"value":4637},"객체는 식별자 메모리 주소에 해당 ",{"type":18,"tag":265,"props":4639,"children":4640},{},[4641],{"type":23,"value":4642},"객체 메모리 주소",{"type":23,"value":4644},"가 저장되어 있다",{"type":18,"tag":19,"props":4646,"children":4647},{},[4648],{"type":23,"value":28},{"type":18,"tag":1945,"props":4650,"children":4651},{},[4652,4657,4673,4743,4772],{"type":18,"tag":1949,"props":4653,"children":4654},{},[4655],{"type":23,"value":4656},"메모리 주소가 'a1', 'a2'가 있다고 할게\n그리고 코드는 let str = \"string\"이야 자바스크립트 엔진은 런타임 이전에 'a1'이나 'a2'중에 메모리 공간을 확보해 (여기서는 'a1'을 확보 했다고 할게\n그리고 식별자 str을 메모리 주소 'a1'에 연결을 한다? (이 문장이 맞는지 모르겠어)\n그리고 런타임시 a1에 \"string\"을 저장한다\n이게 맞을까?",{"type":18,"tag":19,"props":4658,"children":4659},{},[4660,4662,4671],{"type":23,"value":4661},"네, 맞습니다. JavaScript에서 ",{"type":18,"tag":265,"props":4663,"children":4664},{},[4665],{"type":18,"tag":77,"props":4666,"children":4668},{"className":4667},[],[4669],{"type":23,"value":4670},"let str = \"string\";",{"type":23,"value":4672}," 코드에 대한 처리를 단순화하여 설명하면 다음과 같습니다:",{"type":18,"tag":208,"props":4674,"children":4675},{},[4676,4694,4718],{"type":18,"tag":212,"props":4677,"children":4678},{},[4679,4684,4686,4692],{"type":18,"tag":265,"props":4680,"children":4681},{},[4682],{"type":23,"value":4683},"메모리 공간 확보",{"type":23,"value":4685},": JavaScript 엔진은 변수 **",{"type":18,"tag":77,"props":4687,"children":4689},{"className":4688},[],[4690],{"type":23,"value":4691},"str",{"type":23,"value":4693},"**에 대한 메모리 공간을 확보합니다. 이를 위해 메모리 주소 'a1'을 할당한다고 가정할 수 있습니다.",{"type":18,"tag":212,"props":4695,"children":4696},{},[4697,4702,4704,4709,4711,4716],{"type":18,"tag":265,"props":4698,"children":4699},{},[4700],{"type":23,"value":4701},"식별자와 메모리 주소 연결",{"type":23,"value":4703},": 식별자 **",{"type":18,"tag":77,"props":4705,"children":4707},{"className":4706},[],[4708],{"type":23,"value":4691},{"type":23,"value":4710},"**은 이 메모리 주소 'a1'에 연결됩니다. 이는 **",{"type":18,"tag":77,"props":4712,"children":4714},{"className":4713},[],[4715],{"type":23,"value":4691},{"type":23,"value":4717},"**이라는 이름을 사용할 때, JavaScript 엔진이 메모리 주소 'a1'을 참조하도록 합니다.",{"type":18,"tag":212,"props":4719,"children":4720},{},[4721,4726,4728,4734,4736,4741],{"type":18,"tag":265,"props":4722,"children":4723},{},[4724],{"type":23,"value":4725},"런타임 시 값 저장",{"type":23,"value":4727},": 코드가 런타임에 실행될 때, 문자열 **",{"type":18,"tag":77,"props":4729,"children":4731},{"className":4730},[],[4732],{"type":23,"value":4733},"\"string\"",{"type":23,"value":4735},"**은 메모리 주소 'a1'에 저장됩니다. 이 경우, **",{"type":18,"tag":77,"props":4737,"children":4739},{"className":4738},[],[4740],{"type":23,"value":4691},{"type":23,"value":4742},"**은 이 문자열 값을 직접적으로 가리키게 됩니다.",{"type":18,"tag":19,"props":4744,"children":4745},{},[4746,4748,4753,4755,4763,4765,4770],{"type":23,"value":4747},"이 과정에서 중요한 점은 문자열 **",{"type":18,"tag":77,"props":4749,"children":4751},{"className":4750},[],[4752],{"type":23,"value":4733},{"type":23,"value":4754},"**이 원시 타입의 값으로 취급된다는 것입니다. JavaScript에서 문자열은 불변의 원시 타입으로, 변수에 직접 저장됩니다 (복잡한 내부 최적화나 문자열 인터닝을 고려하지 않을 때). 따라서 ",{"type":18,"tag":265,"props":4756,"children":4757},{},[4758],{"type":18,"tag":77,"props":4759,"children":4761},{"className":4760},[],[4762],{"type":23,"value":4691},{"type":23,"value":4764}," 변수는 문자열 **",{"type":18,"tag":77,"props":4766,"children":4768},{"className":4767},[],[4769],{"type":23,"value":4733},{"type":23,"value":4771},"**을 직접적으로 가지고 있으며, 이 값은 메모리 주소 'a1'에 위치하게 됩니다.",{"type":18,"tag":19,"props":4773,"children":4774},{},[4775],{"type":23,"value":4776},"이 설명은 JavaScript 엔진의 메모리 할당과 관리를 단순화한 것이며, 실제 엔진의 구현은 이보다 훨씬 복잡할 수 있습니다. 하지만 기본적인 개념은 위와 같습니다.",{"type":18,"tag":1945,"props":4778,"children":4779},{},[4780,4785,4800,4869,4881],{"type":18,"tag":1949,"props":4781,"children":4782},{},[4783],{"type":23,"value":4784},"식별자 `str`은 이 메모리 주소 'a1'에 연결됩니다. 이 문장에서\n이 때 str은 메모리에 어디 있는걸까? 내가 이상하게 생각하고 있는건가?",{"type":18,"tag":19,"props":4786,"children":4787},{},[4788,4790,4798],{"type":23,"value":4789},"JavaScript에서 ",{"type":18,"tag":265,"props":4791,"children":4792},{},[4793],{"type":18,"tag":77,"props":4794,"children":4796},{"className":4795},[],[4797],{"type":23,"value":4670},{"type":23,"value":4799}," 코드의 처리 과정에 대해 질문하셨군요. 이 과정을 단계별로 살펴보겠습니다:",{"type":18,"tag":208,"props":4801,"children":4802},{},[4803,4820,4844],{"type":18,"tag":212,"props":4804,"children":4805},{},[4806,4811,4813,4818],{"type":18,"tag":265,"props":4807,"children":4808},{},[4809],{"type":23,"value":4810},"메모리 공간 할당",{"type":23,"value":4812},": JavaScript 엔진이 코드를 실행하기 전에, **",{"type":18,"tag":77,"props":4814,"children":4816},{"className":4815},[],[4817],{"type":23,"value":4691},{"type":23,"value":4819},"**이라는 변수를 위한 메모리 공간을 확보합니다. 이 공간을 메모리 주소 'a1'이라고 가정해 봅시다.",{"type":18,"tag":212,"props":4821,"children":4822},{},[4823,4828,4830,4835,4837,4842],{"type":18,"tag":265,"props":4824,"children":4825},{},[4826],{"type":23,"value":4827},"식별자 연결",{"type":23,"value":4829},": **",{"type":18,"tag":77,"props":4831,"children":4833},{"className":4832},[],[4834],{"type":23,"value":4691},{"type":23,"value":4836},"**이라는 식별자는 메모리 주소 'a1'에 연결됩니다. 즉, **",{"type":18,"tag":77,"props":4838,"children":4840},{"className":4839},[],[4841],{"type":23,"value":4691},{"type":23,"value":4843},"**이라는 이름을 사용할 때 JavaScript 엔진은 'a1'이라는 메모리 주소를 참조하게 됩니다.",{"type":18,"tag":212,"props":4845,"children":4846},{},[4847,4852,4854,4860,4862,4867],{"type":18,"tag":265,"props":4848,"children":4849},{},[4850],{"type":23,"value":4851},"런타임시 값 할당",{"type":23,"value":4853},": 런타임에 이르러 **",{"type":18,"tag":77,"props":4855,"children":4857},{"className":4856},[],[4858],{"type":23,"value":4859},"str = \"string\";",{"type":23,"value":4861},"**이 실행되면, 문자열 **",{"type":18,"tag":77,"props":4863,"children":4865},{"className":4864},[],[4866],{"type":23,"value":4733},{"type":23,"value":4868},"**은 메모리 주소 'a1'에 저장됩니다.",{"type":18,"tag":19,"props":4870,"children":4871},{},[4872,4874,4879],{"type":23,"value":4873},"이 과정에서 **",{"type":18,"tag":77,"props":4875,"children":4877},{"className":4876},[],[4878],{"type":23,"value":4691},{"type":23,"value":4880},"**이라는 식별자는 실행 컨텍스트의 환경 레코드에 있습니다. 이 환경 레코드는 메모리의 어떤 부분에 있으며, JavaScript 엔진이 변수 이름과 해당 메모리 주소를 매핑하는 데 사용합니다. 환경 레코드의 정확한 저장 위치는 JavaScript 엔진의 구현 세부 사항에 따라 다르며, 개발자가 직접적으로 접근하거나 확인할 수 있는 부분은 아닙니다.",{"type":18,"tag":19,"props":4882,"children":4883},{},[4884,4886,4891,4893,4898],{"type":23,"value":4885},"즉, **",{"type":18,"tag":77,"props":4887,"children":4889},{"className":4888},[],[4890],{"type":23,"value":4691},{"type":23,"value":4892},"**이라는 식별자는 메모리상의 특정 위치에 있으나, 이 위치는 엔진 내부의 구현에 의존적이며, 식별자는 메모리 주소 'a1'을 참조하여 실제 값 **",{"type":18,"tag":77,"props":4894,"children":4896},{"className":4895},[],[4897],{"type":23,"value":4733},{"type":23,"value":4899},"**에 접근할 수 있게 됩니다.",{"type":18,"tag":19,"props":4901,"children":4902},{},[4903],{"type":23,"value":28},{"type":18,"tag":19,"props":4905,"children":4906},{},[4907],{"type":23,"value":4908},"아~ 뒤에 실행컨텍스트, 환경 레코드…",{"type":18,"tag":1008,"props":4910,"children":4912},{"id":4911},"원시-값",[4913],{"type":23,"value":4914},"원시 값",{"type":18,"tag":19,"props":4916,"children":4917},{},[4918],{"type":23,"value":4919},"원시 타입의 값, 즉 원시 값은 변경 불가능한 값",{"type":18,"tag":70,"props":4921,"children":4924},{"className":4922,"code":4923,"language":12,"meta":8},[73],"var score;\nscore = 80;\nscore = 90;\n",[4925],{"type":18,"tag":77,"props":4926,"children":4927},{"__ignoreMap":8},[4928],{"type":23,"value":4923},{"type":18,"tag":19,"props":4930,"children":4931},{},[4932],{"type":23,"value":4933},"undefined가 80으로 바뀌고 80이 90으로 바뀌는게 아니라",{"type":18,"tag":19,"props":4935,"children":4936},{},[4937],{"type":23,"value":4938},"값은 새로운 메모리 공간을 확보하고 값을 저장한 후, 변수는 원시 값을 가리킨다.",{"type":18,"tag":96,"props":4940,"children":4942},{"src":4941},"/blog/images/99b7aa7f-5d3e-44f3-aaaf-95d469391e84.png",[],{"type":18,"tag":19,"props":4944,"children":4945},{},[4946],{"type":23,"value":4947},"불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.",{"type":18,"tag":19,"props":4949,"children":4950},{},[4951],{"type":23,"value":28},{"type":18,"tag":1666,"props":4953,"children":4955},{"id":4954},"값에-의한-전달",[4956],{"type":23,"value":4957},"값에 의한 전달",{"type":18,"tag":70,"props":4959,"children":4962},{"className":4960,"code":4961,"language":12,"meta":8},[73],"var score = 80;\n\n// copy 변수에는 score 변수의 값 80이 복사되어 할당된다.\nvar copy = score;\n\nconsole.log(score, copy); // 80 80\nconsole.log(score === copy); // true\n",[4963],{"type":18,"tag":77,"props":4964,"children":4965},{"__ignoreMap":8},[4966],{"type":23,"value":4961},{"type":18,"tag":19,"props":4968,"children":4969},{},[4970],{"type":18,"tag":265,"props":4971,"children":4972},{},[4973],{"type":23,"value":4974},"score 변수와 copy 변수의 값 80은 다른 메모리 공간에 저장된 별개의 값이다.",{"type":18,"tag":19,"props":4976,"children":4977},{},[4978],{"type":23,"value":28},{"type":18,"tag":70,"props":4980,"children":4983},{"className":4981,"code":4982,"language":12,"meta":8},[73],"score = 100;\nconsole.log(score, copy); // 100 80\nconsole.log(score === copy); // false\n",[4984],{"type":18,"tag":77,"props":4985,"children":4986},{"__ignoreMap":8},[4987],{"type":23,"value":4982},{"type":18,"tag":19,"props":4989,"children":4990},{},[4991],{"type":23,"value":28},{"type":18,"tag":1666,"props":4993,"children":4995},{"id":4994},"원시-값인-문자열은-다른-원시-값과-비교할-때-독특한-특징이-있음",[4996],{"type":23,"value":4997},"원시 값인 문자열은 다른 원시 값과 비교할 때 독특한 특징이 있음",{"type":18,"tag":19,"props":4999,"children":5000},{},[5001],{"type":23,"value":5002},"문자열은 유사 배열 객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있다.",{"type":18,"tag":70,"props":5004,"children":5007},{"className":5005,"code":5006,"language":12,"meta":8},[73],"var str = 'string';\n\n// 배열처럼 인덱스를 사용해 각 문자에 접근할 수 있다.\nconsole.log(str[0]); // s\n\n// 원시 값인 문자열이 객체처럼 동작한다.\nconsole.log(str.length);\nconsole.log(str.toUpperCase());\n",[5008],{"type":18,"tag":77,"props":5009,"children":5010},{"__ignoreMap":8},[5011],{"type":23,"value":5006},{"type":18,"tag":19,"props":5013,"children":5014},{},[5015,5017,5021],{"type":23,"value":5016},"어떻게 원시 값이 객체처럼 동작할까? 그 이유는 원시 값을 감싸는 ",{"type":18,"tag":265,"props":5018,"children":5019},{},[5020],{"type":23,"value":1410},{"type":23,"value":5022},"로 자동 변환되기 때문이다. 자세한건 이후에",{"type":18,"tag":19,"props":5024,"children":5025},{},[5026],{"type":23,"value":28},{"type":18,"tag":19,"props":5028,"children":5029},{},[5030],{"type":23,"value":5031},"여기서 퀴즈!",{"type":18,"tag":70,"props":5033,"children":5036},{"className":5034,"code":5035,"language":12,"meta":8},[73],"var arr = [1, 2, 3];\narr[0] = 4;\nconsole.log(arr) // ??\n\nvar str = 'string';\nstr[0] = 'S';\nconsole.log(str); // ??\n",[5037],{"type":18,"tag":77,"props":5038,"children":5039},{"__ignoreMap":8},[5040],{"type":23,"value":5035},{"type":18,"tag":19,"props":5042,"children":5043},{},[5044],{"type":23,"value":28},{"type":18,"tag":1008,"props":5046,"children":5047},{"id":2972},[5048],{"type":23,"value":2972},{"type":18,"tag":19,"props":5050,"children":5051},{},[5052],{"type":23,"value":5053},"객체 타입의 값, 즉 객체는 변경 가능한 값이다.",{"type":18,"tag":19,"props":5055,"children":5056},{},[5057],{"type":23,"value":28},{"type":18,"tag":19,"props":5059,"children":5060},{},[5061],{"type":23,"value":5062},"용어정리",{"type":18,"tag":1334,"props":5064,"children":5065},{},[5066,5071],{"type":18,"tag":212,"props":5067,"children":5068},{},[5069],{"type":23,"value":5070},"일반적으로 원시 값을 할당한 경우 “변수는 O값을 갖는다” 또는 “변수의 값은 O다”라고 표현하고",{"type":18,"tag":212,"props":5072,"children":5073},{},[5074],{"type":23,"value":5075},"객체를 할당한 변수의 경우 “변수는 객체를 참조하고 있다” 또는 “변수는 객체를 가리키고 있다”라고 표현",{"type":18,"tag":1666,"props":5077,"children":5079},{"id":5078},"참조에-의한-전달",[5080],{"type":23,"value":5081},"참조에 의한 전달",{"type":18,"tag":70,"props":5083,"children":5086},{"className":5084,"code":5085,"language":12,"meta":8},[73],"var person = {\n    name: 'Lee'\n}\n\nvar copy = person;\n\ncopy.name = 'kim';\n\nconsole.log(person.name); // kim;\nconsole.log(copy.name); // kim;\n",[5087],{"type":18,"tag":77,"props":5088,"children":5089},{"__ignoreMap":8},[5090],{"type":23,"value":5085},{"type":18,"tag":19,"props":5092,"children":5093},{},[5094],{"type":23,"value":28},{"type":18,"tag":19,"props":5096,"children":5097},{},[5098],{"type":23,"value":5099},"정확한 용어는 존재하지 않지만 전달되는 값의 종류에 원시 값인지 참조 값인지 구별해서 강조하는 의미에서 “값에 의한 전달”, “참조에 의한 전달”로 구분하여 부르기 함.",{"type":18,"tag":19,"props":5101,"children":5102},{},[5103],{"type":23,"value":28},{"type":18,"tag":1844,"props":5105,"children":5106},{},[],{"type":18,"tag":1008,"props":5108,"children":5110},{"id":5109},"참고",[5111],{"type":18,"tag":265,"props":5112,"children":5113},{},[5114],{"type":23,"value":5109},{"type":18,"tag":1334,"props":5116,"children":5117},{},[5118],{"type":18,"tag":212,"props":5119,"children":5120},{},[5121],{"type":18,"tag":265,"props":5122,"children":5123},{},[5124],{"type":23,"value":5125},"이웅모, 「모던 자바스크립트 Deep Dive」, 위키북스, 2020",{"title":8,"searchDepth":429,"depth":429,"links":5127},[5128,5132,5135],{"id":4911,"depth":429,"text":4914,"children":5129},[5130,5131],{"id":4954,"depth":2349,"text":4957},{"id":4994,"depth":2349,"text":4997},{"id":2972,"depth":429,"text":2972,"children":5133},[5134],{"id":5078,"depth":2349,"text":5081},{"id":5109,"depth":429,"text":5109},"content:posts:8285cee9-dfcd-4a53-8b73-3ae542a267a9.md","posts/8285cee9-dfcd-4a53-8b73-3ae542a267a9.md",{"_path":5139,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":5140,"description":5141,"tags":5142,"date":5143,"body":5144,"_type":431,"_id":5287,"_source":433,"_file":5288,"_extension":435},"/posts/8a8bd47c-ecd1-42d9-b1ee-efbff20134e8","자바스크립트 - 7. 객체 리터럴","자바스크립트는 객체 기반의 프로그래밍 언어이다!",[12],"2024-02-14T00:00:00.000Z",{"type":15,"children":5145,"toc":5283},[5146,5150,5161,5167,5176,5188,5192,5197,5201,5206,5232,5241,5245,5250,5259,5263,5266,5273],{"type":18,"tag":19,"props":5147,"children":5148},{},[5149],{"type":23,"value":5141},{"type":18,"tag":19,"props":5151,"children":5152},{},[5153,5155,5159],{"type":23,"value":5154},"원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 ",{"type":18,"tag":265,"props":5156,"children":5157},{},[5158],{"type":23,"value":2972},{"type":23,"value":5160},"다",{"type":18,"tag":1008,"props":5162,"children":5164},{"id":5163},"객체-리터럴에-의한-객체-생성",[5165],{"type":23,"value":5166},"객체 리터럴에 의한 객체 생성",{"type":18,"tag":70,"props":5168,"children":5171},{"className":5169,"code":5170,"language":12,"meta":8},[73],"var person = {\n    name: 'Lee',\n    sayHello: function() {\n        console.log(`Hello! My name is ${this.name}`);\n    }\n};\n",[5172],{"type":18,"tag":77,"props":5173,"children":5174},{"__ignoreMap":8},[5175],{"type":23,"value":5170},{"type":18,"tag":19,"props":5177,"children":5178},{},[5179,5181,5186],{"type":23,"value":5180},"객체 리터럴의 중괄호는 코드 블록을 의미하지 않는다. 코드 블록의 닫는 중괄호 뒤에는 세미콜론을 붙이지 않는다. 하지만 객체 리터럴은 ",{"type":18,"tag":265,"props":5182,"children":5183},{},[5184],{"type":23,"value":5185},"값으로 평가되는 표현식",{"type":23,"value":5187},"이다. 따라서 뒤에 세미콜론을 붙인다.",{"type":18,"tag":19,"props":5189,"children":5190},{},[5191],{"type":23,"value":28},{"type":18,"tag":19,"props":5193,"children":5194},{},[5195],{"type":23,"value":5196},"객체 리터럴 외의 객체 생성 방식은 모두 함수를 사용해 객체를 생선한다. (뒤에 함수에서 자세히)",{"type":18,"tag":19,"props":5198,"children":5199},{},[5200],{"type":23,"value":28},{"type":18,"tag":19,"props":5202,"children":5203},{},[5204],{"type":23,"value":5205},"용어 정리",{"type":18,"tag":1334,"props":5207,"children":5208},{},[5209,5227],{"type":18,"tag":212,"props":5210,"children":5211},{},[5212,5214],{"type":23,"value":5213},"프로퍼티\n",{"type":18,"tag":1334,"props":5215,"children":5216},{},[5217,5222],{"type":18,"tag":212,"props":5218,"children":5219},{},[5220],{"type":23,"value":5221},"프로퍼티 키",{"type":18,"tag":212,"props":5223,"children":5224},{},[5225],{"type":23,"value":5226},"프로퍼티 값",{"type":18,"tag":212,"props":5228,"children":5229},{},[5230],{"type":23,"value":5231},"메서드: 객체에 묶여 있는 함수 (일반 함수와 구분하기 위해 메서드라 부른다.)",{"type":18,"tag":70,"props":5233,"children":5236},{"className":5234,"code":5235,"language":12,"meta":8},[73],"var circle = {\n    radius: 5, // \u003C- 프로퍼티: radious(프로퍼티 키), 5(프로퍼티 값)\n    getDiameter: function () { // \u003C- 메서드\n        return 2 * this.radius; \n    }\n}\n",[5237],{"type":18,"tag":77,"props":5238,"children":5239},{"__ignoreMap":8},[5240],{"type":23,"value":5235},{"type":18,"tag":19,"props":5242,"children":5243},{},[5244],{"type":23,"value":28},{"type":18,"tag":19,"props":5246,"children":5247},{},[5248],{"type":23,"value":5249},"객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환하다. 이때 ReferenceError가 발생하지 않는데 주의",{"type":18,"tag":70,"props":5251,"children":5254},{"className":5252,"code":5253,"language":12,"meta":8},[73],"circle.name; // undefined\n",[5255],{"type":18,"tag":77,"props":5256,"children":5257},{"__ignoreMap":8},[5258],{"type":23,"value":5253},{"type":18,"tag":19,"props":5260,"children":5261},{},[5262],{"type":23,"value":28},{"type":18,"tag":1844,"props":5264,"children":5265},{},[],{"type":18,"tag":1008,"props":5267,"children":5268},{"id":5109},[5269],{"type":18,"tag":265,"props":5270,"children":5271},{},[5272],{"type":23,"value":5109},{"type":18,"tag":1334,"props":5274,"children":5275},{},[5276],{"type":18,"tag":212,"props":5277,"children":5278},{},[5279],{"type":18,"tag":265,"props":5280,"children":5281},{},[5282],{"type":23,"value":5125},{"title":8,"searchDepth":429,"depth":429,"links":5284},[5285,5286],{"id":5163,"depth":429,"text":5166},{"id":5109,"depth":429,"text":5109},"content:posts:8a8bd47c-ecd1-42d9-b1ee-efbff20134e8.md","posts/8a8bd47c-ecd1-42d9-b1ee-efbff20134e8.md",{"_path":5290,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":5291,"description":8,"tags":5292,"date":5293,"body":5294,"_type":431,"_id":5569,"_source":433,"_file":5570,"_extension":435},"/posts/22bcd32f-2a8d-404b-a78c-914d58c369bb","자바스크립트 - 6. 타입 변환과 단축 평가",[12],"2024-02-13T00:00:00.000Z",{"type":15,"children":5295,"toc":5558},[5296,5302,5310,5319,5327,5336,5340,5361,5365,5371,5379,5388,5392,5398,5407,5411,5417,5449,5453,5458,5463,5472,5476,5481,5490,5494,5500,5505,5514,5520,5525,5534,5538,5541,5548],{"type":18,"tag":1008,"props":5297,"children":5299},{"id":5298},"타입-변환",[5300],{"type":23,"value":5301},"타입 변환",{"type":18,"tag":1334,"props":5303,"children":5304},{},[5305],{"type":18,"tag":212,"props":5306,"children":5307},{},[5308],{"type":23,"value":5309},"명시적 타입 변환(explicit coercion), 타입 캐스팅(type casting)",{"type":18,"tag":70,"props":5311,"children":5314},{"className":5312,"code":5313,"language":12,"meta":8},[73],"var x = 10;\nvar str = x.toString() // \u003C- 명시적\n",[5315],{"type":18,"tag":77,"props":5316,"children":5317},{"__ignoreMap":8},[5318],{"type":23,"value":5313},{"type":18,"tag":1334,"props":5320,"children":5321},{},[5322],{"type":18,"tag":212,"props":5323,"children":5324},{},[5325],{"type":23,"value":5326},"암묵적 타입 변환(implicit coercion), 타입 강제 변환(type coercion)",{"type":18,"tag":70,"props":5328,"children":5331},{"className":5329,"code":5330,"language":12,"meta":8},[73],"var x = 10;\nvar str = x + ''; // \u003C- 암묵적\n",[5332],{"type":18,"tag":77,"props":5333,"children":5334},{"__ignoreMap":8},[5335],{"type":23,"value":5330},{"type":18,"tag":19,"props":5337,"children":5338},{},[5339],{"type":23,"value":28},{"type":18,"tag":1449,"props":5341,"children":5342},{},[5343,5348],{"type":18,"tag":19,"props":5344,"children":5345},{},[5346],{"type":23,"value":5347},"둘다 기존 원시 값을 직접 변경하는 것은 아님",{"type":18,"tag":1334,"props":5349,"children":5350},{},[5351],{"type":18,"tag":212,"props":5352,"children":5353},{},[5354,5356,5359],{"type":23,"value":5355},"원시값은 변경 불가능한 값(immutable value)",{"type":18,"tag":571,"props":5357,"children":5358},{},[],{"type":23,"value":5360},"\n타입 변환이란 기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성",{"type":18,"tag":19,"props":5362,"children":5363},{},[5364],{"type":23,"value":28},{"type":18,"tag":1666,"props":5366,"children":5368},{"id":5367},"는-문자열-연결-연산자-산술-연산자-두-연산-역할을-함",[5369],{"type":23,"value":5370},"+는 문자열 연결 연산자, 산술 연산자 두 연산 역할을 함",{"type":18,"tag":1334,"props":5372,"children":5373},{},[5374],{"type":18,"tag":212,"props":5375,"children":5376},{},[5377],{"type":23,"value":5378},"피 연산자중 하나 이상이 문자열이면 문자열 연결 연산자로 동작",{"type":18,"tag":70,"props":5380,"children":5383},{"className":5381,"code":5382,"language":12,"meta":8},[73],"1 + '10' // 110 (string)\n'10' + 2 // 102 (string)\n[10, 20] + '' // 10,20\n",[5384],{"type":18,"tag":77,"props":5385,"children":5386},{"__ignoreMap":8},[5387],{"type":23,"value":5382},{"type":18,"tag":19,"props":5389,"children":5390},{},[5391],{"type":23,"value":28},{"type":18,"tag":1666,"props":5393,"children":5395},{"id":5394},"단항-연산자는-피연산자가-숫자-타입의-값이-아니면-숫자-타입의-값으로-암묵적-타입-변환을-수행",[5396],{"type":23,"value":5397},"+단항 연산자는 피연산자가 숫자 타입의 값이 아니면 숫자 타입의 값으로 암묵적 타입 변환을 수행",{"type":18,"tag":70,"props":5399,"children":5402},{"className":5400,"code":5401,"language":12,"meta":8},[73],"+'' // -> 0\n+'0' // -> 0\n+'1' // 1\n",[5403],{"type":18,"tag":77,"props":5404,"children":5405},{"__ignoreMap":8},[5406],{"type":23,"value":5401},{"type":18,"tag":19,"props":5408,"children":5409},{},[5410],{"type":23,"value":28},{"type":18,"tag":1008,"props":5412,"children":5414},{"id":5413},"falsy-값",[5415],{"type":23,"value":5416},"Falsy 값",{"type":18,"tag":1334,"props":5418,"children":5419},{},[5420,5425,5429,5434,5439,5444],{"type":18,"tag":212,"props":5421,"children":5422},{},[5423],{"type":23,"value":5424},"false",{"type":18,"tag":212,"props":5426,"children":5427},{},[5428],{"type":23,"value":1778},{"type":18,"tag":212,"props":5430,"children":5431},{},[5432],{"type":23,"value":5433},"null",{"type":18,"tag":212,"props":5435,"children":5436},{},[5437],{"type":23,"value":5438},"0, -0",{"type":18,"tag":212,"props":5440,"children":5441},{},[5442],{"type":23,"value":5443},"NaN",{"type":18,"tag":212,"props":5445,"children":5446},{},[5447],{"type":23,"value":5448},"‘’(빈 문자열)",{"type":18,"tag":19,"props":5450,"children":5451},{},[5452],{"type":23,"value":28},{"type":18,"tag":1008,"props":5454,"children":5456},{"id":5455},"단축평가",[5457],{"type":23,"value":5455},{"type":18,"tag":19,"props":5459,"children":5460},{},[5461],{"type":23,"value":5462},"&&: 앞이 true여야 뒤를 평가, 아니면 앞을 평가",{"type":18,"tag":70,"props":5464,"children":5467},{"className":5465,"code":5466,"language":12,"meta":8},[73],"false && 'DOG' // false\ntrue && 'DOG' // true\n",[5468],{"type":18,"tag":77,"props":5469,"children":5470},{"__ignoreMap":8},[5471],{"type":23,"value":5466},{"type":18,"tag":19,"props":5473,"children":5474},{},[5475],{"type":23,"value":28},{"type":18,"tag":19,"props":5477,"children":5478},{},[5479],{"type":23,"value":5480},"||: 앞이 true이면 앞을 평가, 앞이 false이면 뒤를평가",{"type":18,"tag":70,"props":5482,"children":5485},{"className":5483,"code":5484,"language":12,"meta":8},[73],"'Cat' || true // 'Cat'\nfalse || 'Cat' // 'Cat'\n",[5486],{"type":18,"tag":77,"props":5487,"children":5488},{"__ignoreMap":8},[5489],{"type":23,"value":5484},{"type":18,"tag":19,"props":5491,"children":5492},{},[5493],{"type":23,"value":28},{"type":18,"tag":1008,"props":5495,"children":5497},{"id":5496},"옵셔널-체이닝-연산자",[5498],{"type":23,"value":5499},"옵셔널 체이닝 연산자(?.)",{"type":18,"tag":19,"props":5501,"children":5502},{},[5503],{"type":23,"value":5504},"좌항의 피연산자가 null 또는 undeinfed인 경우 undefined를 반환, 그렇지 않으면 우항의 프로퍼티 참조",{"type":18,"tag":70,"props":5506,"children":5509},{"className":5507,"code":5508,"language":12,"meta":8},[73],"var elem = null;\n\nvar value = elem?.value;\nconsole.log(valule); // undefined\n",[5510],{"type":18,"tag":77,"props":5511,"children":5512},{"__ignoreMap":8},[5513],{"type":23,"value":5508},{"type":18,"tag":1008,"props":5515,"children":5517},{"id":5516},"null-병합-연산자",[5518],{"type":23,"value":5519},"null 병합 연산자(??)",{"type":18,"tag":19,"props":5521,"children":5522},{},[5523],{"type":23,"value":5524},"좌항의 피연산자가 null 또는 undefined인 경우 우항의 피 연산자를 반환, 그렇지 않으면 좌항의 피연산자를 반환",{"type":18,"tag":70,"props":5526,"children":5529},{"className":5527,"code":5528,"language":12,"meta":8},[73],"var foo = null ?? 'default string';\nconsole.log(foo); // 'default string';\n",[5530],{"type":18,"tag":77,"props":5531,"children":5532},{"__ignoreMap":8},[5533],{"type":23,"value":5528},{"type":18,"tag":19,"props":5535,"children":5536},{},[5537],{"type":23,"value":28},{"type":18,"tag":1844,"props":5539,"children":5540},{},[],{"type":18,"tag":1008,"props":5542,"children":5543},{"id":5109},[5544],{"type":18,"tag":265,"props":5545,"children":5546},{},[5547],{"type":23,"value":5109},{"type":18,"tag":1334,"props":5549,"children":5550},{},[5551],{"type":18,"tag":212,"props":5552,"children":5553},{},[5554],{"type":18,"tag":265,"props":5555,"children":5556},{},[5557],{"type":23,"value":5125},{"title":8,"searchDepth":429,"depth":429,"links":5559},[5560,5564,5565,5566,5567,5568],{"id":5298,"depth":429,"text":5301,"children":5561},[5562,5563],{"id":5367,"depth":2349,"text":5370},{"id":5394,"depth":2349,"text":5397},{"id":5413,"depth":429,"text":5416},{"id":5455,"depth":429,"text":5455},{"id":5496,"depth":429,"text":5499},{"id":5516,"depth":429,"text":5519},{"id":5109,"depth":429,"text":5109},"content:posts:22bcd32f-2a8d-404b-a78c-914d58c369bb.md","posts/22bcd32f-2a8d-404b-a78c-914d58c369bb.md",{"_path":5572,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":5573,"description":28,"tags":5574,"date":5575,"body":5576,"_type":431,"_id":5668,"_source":433,"_file":5669,"_extension":435},"/posts/a853b817-57ee-4f1d-99a6-81eb4cade7c4","자바스크립트 - 5. 제어문",[12],"2024-02-12T00:00:00.000Z",{"type":15,"children":5577,"toc":5664},[5578,5582,5587,5592,5596,5601,5605,5613,5622,5626,5635,5640,5644,5647,5654],{"type":18,"tag":19,"props":5579,"children":5580},{},[5581],{"type":23,"value":28},{"type":18,"tag":1008,"props":5583,"children":5585},{"id":5584},"break문",[5586],{"type":23,"value":5584},{"type":18,"tag":19,"props":5588,"children":5589},{},[5590],{"type":23,"value":5591},"레이블 문, 반복문, switch 문의 코드 블록을 탈출한다.",{"type":18,"tag":19,"props":5593,"children":5594},{},[5595],{"type":23,"value":28},{"type":18,"tag":19,"props":5597,"children":5598},{},[5599],{"type":23,"value":5600},"그외에 사용하면 SyntaxError",{"type":18,"tag":19,"props":5602,"children":5603},{},[5604],{"type":23,"value":28},{"type":18,"tag":1449,"props":5606,"children":5607},{},[5608],{"type":18,"tag":19,"props":5609,"children":5610},{},[5611],{"type":23,"value":5612},"레이블 문이란 식별자가 붙은 문",{"type":18,"tag":70,"props":5614,"children":5617},{"className":5615,"code":5616,"language":12,"meta":8},[73],"foo: console.log('foo');\n",[5618],{"type":18,"tag":77,"props":5619,"children":5620},{"__ignoreMap":8},[5621],{"type":23,"value":5616},{"type":18,"tag":19,"props":5623,"children":5624},{},[5625],{"type":23,"value":28},{"type":18,"tag":70,"props":5627,"children":5630},{"className":5628,"code":5629,"language":12,"meta":8},[73],"outer: for (var i = 0; i \u003C 3; i++) {\n  for (var j = 0; j \u003C 3; j++) {\n    if (i + j === 3) break outer;\n    console.log(`inner [${i}, ${j}]`)\n  }\n}\n",[5631],{"type":18,"tag":77,"props":5632,"children":5633},{"__ignoreMap":8},[5634],{"type":23,"value":5629},{"type":18,"tag":19,"props":5636,"children":5637},{},[5638],{"type":23,"value":5639},"레이블 문은 중첩된 for 문 외부로 탈출할 때 유용, 그 밖의 경우에는 일반적으로 권장하지 않음",{"type":18,"tag":19,"props":5641,"children":5642},{},[5643],{"type":23,"value":28},{"type":18,"tag":1844,"props":5645,"children":5646},{},[],{"type":18,"tag":1008,"props":5648,"children":5649},{"id":5109},[5650],{"type":18,"tag":265,"props":5651,"children":5652},{},[5653],{"type":23,"value":5109},{"type":18,"tag":1334,"props":5655,"children":5656},{},[5657],{"type":18,"tag":212,"props":5658,"children":5659},{},[5660],{"type":18,"tag":265,"props":5661,"children":5662},{},[5663],{"type":23,"value":5125},{"title":8,"searchDepth":429,"depth":429,"links":5665},[5666,5667],{"id":5584,"depth":429,"text":5584},{"id":5109,"depth":429,"text":5109},"content:posts:a853b817-57ee-4f1d-99a6-81eb4cade7c4.md","posts/a853b817-57ee-4f1d-99a6-81eb4cade7c4.md",{"_path":5671,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":5672,"description":8,"tags":5673,"date":5674,"body":5675,"_type":431,"_id":5831,"_source":433,"_file":5832,"_extension":435},"/posts/a588f6bc-0a00-4de2-b05b-f7d7d37bc029","자바스크립트 - 4. 연산자",[12],"2024-02-10T00:00:00.000Z",{"type":15,"children":5676,"toc":5825},[5677,5686,5690,5696,5701,5706,5715,5721,5726,5735,5741,5746,5751,5755,5760,5769,5774,5783,5787,5792,5801,5805,5808,5815],{"type":18,"tag":70,"props":5678,"children":5681},{"className":5679,"code":5680,"language":12,"meta":8},[73],"// 산술 연산자\n5 * 4 \n\n// 문자열 연결 연산자\n'My name is ' + 'kim'\n\n// 할당 연산자\ncolor = 'red'\n\n// 비교 연산자\n3 > 5\n\n// 논리 연산자\ntrue && false\n\n// 타입 연산자\ntypeof 'hi'\n",[5682],{"type":18,"tag":77,"props":5683,"children":5684},{"__ignoreMap":8},[5685],{"type":23,"value":5680},{"type":18,"tag":19,"props":5687,"children":5688},{},[5689],{"type":23,"value":28},{"type":18,"tag":1008,"props":5691,"children":5693},{"id":5692},"산술-연산자",[5694],{"type":23,"value":5695},"산술 연산자",{"type":18,"tag":19,"props":5697,"children":5698},{},[5699],{"type":23,"value":5700},"전위 증가/감소 연산자(++x)",{"type":18,"tag":19,"props":5702,"children":5703},{},[5704],{"type":23,"value":5705},"후위 증가/감소 연산자(x++);",{"type":18,"tag":70,"props":5707,"children":5710},{"className":5708,"code":5709,"language":12,"meta":8},[73],"var x = 1;\nvar result = ++x; // 산술 연산 후 할당 연산 실행\n\nresult = x++; // 할당 연산 후 산술 연산 실행\n",[5711],{"type":18,"tag":77,"props":5712,"children":5713},{"__ignoreMap":8},[5714],{"type":23,"value":5709},{"type":18,"tag":1008,"props":5716,"children":5718},{"id":5717},"할당-연산자",[5719],{"type":23,"value":5720},"할당 연산자",{"type":18,"tag":19,"props":5722,"children":5723},{},[5724],{"type":23,"value":5725},"할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다.",{"type":18,"tag":70,"props":5727,"children":5730},{"className":5728,"code":5729,"language":12,"meta":8},[73],"var a, b, c;\na = b = c = 0;\n\nconsole.log(a, b, c);\n",[5731],{"type":18,"tag":77,"props":5732,"children":5733},{"__ignoreMap":8},[5734],{"type":23,"value":5729},{"type":18,"tag":1008,"props":5736,"children":5738},{"id":5737},"비교-연산자",[5739],{"type":23,"value":5740},"비교 연산자",{"type":18,"tag":19,"props":5742,"children":5743},{},[5744],{"type":23,"value":5745},"== : 값을 비교",{"type":18,"tag":19,"props":5747,"children":5748},{},[5749],{"type":23,"value":5750},"===: 값과 타입을 비교",{"type":18,"tag":19,"props":5752,"children":5753},{},[5754],{"type":23,"value":28},{"type":18,"tag":19,"props":5756,"children":5757},{},[5758],{"type":23,"value":5759},"비교 연산자에서 주의할것은 NaN",{"type":18,"tag":70,"props":5761,"children":5764},{"className":5762,"code":5763,"language":12,"meta":8},[73],"NaN === NaN // false\n\nisNaN(NaN); // true\n",[5765],{"type":18,"tag":77,"props":5766,"children":5767},{"__ignoreMap":8},[5768],{"type":23,"value":5763},{"type":18,"tag":19,"props":5770,"children":5771},{},[5772],{"type":23,"value":5773},"숫자 0도 주의",{"type":18,"tag":70,"props":5775,"children":5778},{"className":5776,"code":5777,"language":12,"meta":8},[73],"-0 === +0 // true\n",[5779],{"type":18,"tag":77,"props":5780,"children":5781},{"__ignoreMap":8},[5782],{"type":23,"value":5777},{"type":18,"tag":19,"props":5784,"children":5785},{},[5786],{"type":23,"value":28},{"type":18,"tag":19,"props":5788,"children":5789},{},[5790],{"type":23,"value":5791},"가장 베스트는 ES6에 도입된 Object.is 사용하면 됨",{"type":18,"tag":70,"props":5793,"children":5796},{"className":5794,"code":5795,"language":12,"meta":8},[73],"Object.is(NaN, NaN); // true\nObject.is(-0, +0); // true\n",[5797],{"type":18,"tag":77,"props":5798,"children":5799},{"__ignoreMap":8},[5800],{"type":23,"value":5795},{"type":18,"tag":19,"props":5802,"children":5803},{},[5804],{"type":23,"value":28},{"type":18,"tag":1844,"props":5806,"children":5807},{},[],{"type":18,"tag":1008,"props":5809,"children":5810},{"id":5109},[5811],{"type":18,"tag":265,"props":5812,"children":5813},{},[5814],{"type":23,"value":5109},{"type":18,"tag":1334,"props":5816,"children":5817},{},[5818],{"type":18,"tag":212,"props":5819,"children":5820},{},[5821],{"type":18,"tag":265,"props":5822,"children":5823},{},[5824],{"type":23,"value":5125},{"title":8,"searchDepth":429,"depth":429,"links":5826},[5827,5828,5829,5830],{"id":5692,"depth":429,"text":5695},{"id":5717,"depth":429,"text":5720},{"id":5737,"depth":429,"text":5740},{"id":5109,"depth":429,"text":5109},"content:posts:a588f6bc-0a00-4de2-b05b-f7d7d37bc029.md","posts/a588f6bc-0a00-4de2-b05b-f7d7d37bc029.md",{"_path":5834,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":5835,"description":5836,"tags":5837,"date":5838,"body":5839,"_type":431,"_id":6003,"_source":433,"_file":6004,"_extension":435},"/posts/c9451712-95a0-44ad-b31e-dc36c9d5bec3","자바스크립트 - 3. 데이터 타입","데이터 타입: 값의 종류",[12],"2024-02-08T00:00:00.000Z",{"type":15,"children":5840,"toc":5996},[5841,5845,5850,5854,5859,5865,5870,5875,5880,5885,5890,5895,5901,5906,5910,5915,5920,5925,5929,5935,5948,5952,5958,5963,5967,5972,5976,5979,5986],{"type":18,"tag":19,"props":5842,"children":5843},{},[5844],{"type":23,"value":5836},{"type":18,"tag":19,"props":5846,"children":5847},{},[5848],{"type":23,"value":5849},"자바스크립트의 모든 값은 데이터 타입을 갖는다.",{"type":18,"tag":19,"props":5851,"children":5852},{},[5853],{"type":23,"value":28},{"type":18,"tag":19,"props":5855,"children":5856},{},[5857],{"type":23,"value":5858},"ES6는 7개의 데이터 타입을 제공",{"type":18,"tag":1008,"props":5860,"children":5862},{"id":5861},"원시-타입primitive-type",[5863],{"type":23,"value":5864},"원시 타입(primitive type)",{"type":18,"tag":19,"props":5866,"children":5867},{},[5868],{"type":23,"value":5869},"숫자(number) 타입",{"type":18,"tag":19,"props":5871,"children":5872},{},[5873],{"type":23,"value":5874},"문자열(string) 타입",{"type":18,"tag":19,"props":5876,"children":5877},{},[5878],{"type":23,"value":5879},"불리언(boolean) 타입",{"type":18,"tag":19,"props":5881,"children":5882},{},[5883],{"type":23,"value":5884},"undefined 타입",{"type":18,"tag":19,"props":5886,"children":5887},{},[5888],{"type":23,"value":5889},"null 타입",{"type":18,"tag":19,"props":5891,"children":5892},{},[5893],{"type":23,"value":5894},"심벌(symbol) 타입",{"type":18,"tag":1008,"props":5896,"children":5898},{"id":5897},"객체-타입objectreference-type",[5899],{"type":23,"value":5900},"객체 타입(object/reference type)",{"type":18,"tag":19,"props":5902,"children":5903},{},[5904],{"type":23,"value":5905},"객체, 함수, 배열 등",{"type":18,"tag":19,"props":5907,"children":5908},{},[5909],{"type":23,"value":28},{"type":18,"tag":19,"props":5911,"children":5912},{},[5913],{"type":23,"value":5914},"var 키워드는 선언한 변수는 암묵적으로 undefined로 초기화된다.",{"type":18,"tag":19,"props":5916,"children":5917},{},[5918],{"type":23,"value":5919},"undefined가 반환된다면 참조한 변수가 선언 이후 값이 할당된적이 없는, 즉 초기화되지 않은 변수라는 것을 간파할 수 있다.",{"type":18,"tag":19,"props":5921,"children":5922},{},[5923],{"type":23,"value":5924},"tip: undefined를 의도적으로 할당하지말자! null을 쓰자",{"type":18,"tag":19,"props":5926,"children":5927},{},[5928],{"type":23,"value":28},{"type":18,"tag":1008,"props":5930,"children":5932},{"id":5931},"데이터-타입의-필요성",[5933],{"type":23,"value":5934},"데이터 타입의 필요성",{"type":18,"tag":1334,"props":5936,"children":5937},{},[5938,5943],{"type":18,"tag":212,"props":5939,"children":5940},{},[5941],{"type":23,"value":5942},"값을 저장하거나 참조할 때 메모리 공간의 크기를 결정",{"type":18,"tag":212,"props":5944,"children":5945},{},[5946],{"type":23,"value":5947},"2진수를 어떻게 해석할지 결정",{"type":18,"tag":19,"props":5949,"children":5950},{},[5951],{"type":23,"value":28},{"type":18,"tag":1008,"props":5953,"children":5955},{"id":5954},"자바스크립트는-동적-타입-언어",[5956],{"type":23,"value":5957},"자바스크립트는 동적 타입 언어",{"type":18,"tag":19,"props":5959,"children":5960},{},[5961],{"type":23,"value":5962},"자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론type interface)된다.\n그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다. 이러한 특징을 동적 타이핑이라 한다.",{"type":18,"tag":19,"props":5964,"children":5965},{},[5966],{"type":23,"value":28},{"type":18,"tag":19,"props":5968,"children":5969},{},[5970],{"type":23,"value":5971},"그래서 정적타입을 지원하는 typescript를 사용하는게 추세이다.",{"type":18,"tag":19,"props":5973,"children":5974},{},[5975],{"type":23,"value":28},{"type":18,"tag":1844,"props":5977,"children":5978},{},[],{"type":18,"tag":1008,"props":5980,"children":5981},{"id":5109},[5982],{"type":18,"tag":265,"props":5983,"children":5984},{},[5985],{"type":23,"value":5109},{"type":18,"tag":1334,"props":5987,"children":5988},{},[5989],{"type":18,"tag":212,"props":5990,"children":5991},{},[5992],{"type":18,"tag":265,"props":5993,"children":5994},{},[5995],{"type":23,"value":5125},{"title":8,"searchDepth":429,"depth":429,"links":5997},[5998,5999,6000,6001,6002],{"id":5861,"depth":429,"text":5864},{"id":5897,"depth":429,"text":5900},{"id":5931,"depth":429,"text":5934},{"id":5954,"depth":429,"text":5957},{"id":5109,"depth":429,"text":5109},"content:posts:c9451712-95a0-44ad-b31e-dc36c9d5bec3.md","posts/c9451712-95a0-44ad-b31e-dc36c9d5bec3.md",{"_path":6006,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":6007,"description":8,"tags":6008,"date":6009,"body":6010,"_type":431,"_id":6211,"_source":433,"_file":6212,"_extension":435},"/posts/1c1fa102-7f33-48ab-8077-31865e9dd7bc","자바스크립트 - 2. 표현식과 문",[12],"2024-01-31T00:00:00.000Z",{"type":15,"children":6011,"toc":6203},[6012,6016,6020,6025,6030,6035,6044,6056,6061,6072,6077,6082,6087,6096,6101,6106,6111,6116,6120,6126,6147,6151,6156,6165,6169,6174,6183,6186,6193],{"type":18,"tag":58,"props":6013,"children":6014},{"id":5062},[6015],{"type":23,"value":5062},{"type":18,"tag":1008,"props":6017,"children":6018},{"id":4630},[6019],{"type":23,"value":4630},{"type":18,"tag":19,"props":6021,"children":6022},{},[6023],{"type":23,"value":6024},"값은 식(표현식expression)이 평가(evaluate)되어 생성된 결과.",{"type":18,"tag":19,"props":6026,"children":6027},{},[6028],{"type":23,"value":6029},"평가란 식을 해석해서 값을 생성하거나 참조하는 것을 의미.",{"type":18,"tag":19,"props":6031,"children":6032},{},[6033],{"type":23,"value":6034},"그냥 쉽게 메모리에 저장되는 값이라고 생각",{"type":18,"tag":70,"props":6036,"children":6039},{"className":6037,"code":6038,"language":12,"meta":8},[73],"var sum = 10 + 20;\n\n// sum에 10 + 20이 할당되는게 아닌 30이 할당되는것이다. \n// 따라서 10 + 20은 할당 이전에 평가(30)되어 값을 생성해야 한다.\n\n\n5 * 5\n// 5*5가 평가되어 메모리에 25가 저장 (but.이 값은 어느 변수에도 할당이 안되어 있기 때문에 가비지 컬렉터에 의해서 지워짐)\n",[6040],{"type":18,"tag":77,"props":6041,"children":6042},{"__ignoreMap":8},[6043],{"type":23,"value":6038},{"type":18,"tag":19,"props":6045,"children":6046},{},[6047,6049,6054],{"type":23,"value":6048},"변수는 ",{"type":18,"tag":265,"props":6050,"children":6051},{},[6052],{"type":23,"value":6053},"하나의 값",{"type":23,"value":6055},"을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이라고 했다. 따라서 변수에 할당되는 것은 값이다.",{"type":18,"tag":1008,"props":6057,"children":6059},{"id":6058},"리터럴",[6060],{"type":23,"value":6058},{"type":18,"tag":19,"props":6062,"children":6063},{},[6064,6066,6070],{"type":23,"value":6065},"리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 ",{"type":18,"tag":265,"props":6067,"children":6068},{},[6069],{"type":23,"value":4630},{"type":23,"value":6071},"을 생성하는 표기법(notation)",{"type":18,"tag":19,"props":6073,"children":6074},{},[6075],{"type":23,"value":6076},"자바스크립트 엔진은 코드가 실행되는 시점인 런타임에 리터럴을 평가해 값을 생성한다. 즉, 리터럴은 값을 생성하기 위해 미리 약속한 표기법이라고 할 수 있다.",{"type":18,"tag":1008,"props":6078,"children":6080},{"id":6079},"표현식",[6081],{"type":23,"value":6079},{"type":18,"tag":19,"props":6083,"children":6084},{},[6085],{"type":23,"value":6086},"표현식은 값으로 평가될 수 있는 문이다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조.",{"type":18,"tag":70,"props":6088,"children":6091},{"className":6089,"code":6090,"language":12,"meta":8},[73],"var score = 50 + 50;\n// 50 + 50은 평가되어 100을 생성 (메모리에 기억)하였으므로 표현식이다.\n\nscore; // 식별자 참조는 값을 생성하지는 않지만 메모리에서 불러와 값으로 평가되므로 표현식이다.\n",[6092],{"type":18,"tag":77,"props":6093,"children":6094},{"__ignoreMap":8},[6095],{"type":23,"value":6090},{"type":18,"tag":1008,"props":6097,"children":6099},{"id":6098},"문",[6100],{"type":23,"value":6098},{"type":18,"tag":19,"props":6102,"children":6103},{},[6104],{"type":23,"value":6105},"프로그램을 구성하는 기본 단위이자 최소 실행 단위.",{"type":18,"tag":19,"props":6107,"children":6108},{},[6109],{"type":23,"value":6110},"문을 명령문이라고도 부른다. 즉 문은 컴퓨터에 내리는 명령이다.",{"type":18,"tag":19,"props":6112,"children":6113},{},[6114],{"type":23,"value":6115},"문은 선언문, 할당문, 조건문, 반복문 등으로 구분",{"type":18,"tag":19,"props":6117,"children":6118},{},[6119],{"type":23,"value":28},{"type":18,"tag":1008,"props":6121,"children":6123},{"id":6122},"표현식인-문과-표현식이-아닌-문",[6124],{"type":23,"value":6125},"표현식인 문과 표현식이 아닌 문",{"type":18,"tag":19,"props":6127,"children":6128},{},[6129,6131,6137,6139,6145],{"type":23,"value":6130},"문에는 ",{"type":18,"tag":77,"props":6132,"children":6134},{"className":6133},[],[6135],{"type":23,"value":6136},"표현식인 문",{"type":23,"value":6138}," 과 ",{"type":18,"tag":77,"props":6140,"children":6142},{"className":6141},[],[6143],{"type":23,"value":6144},"표현식이 아닌문",{"type":23,"value":6146}," 이 있다.",{"type":18,"tag":19,"props":6148,"children":6149},{},[6150],{"type":23,"value":28},{"type":18,"tag":19,"props":6152,"children":6153},{},[6154],{"type":23,"value":6155},"할당문은 그 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인 문이다.",{"type":18,"tag":70,"props":6157,"children":6160},{"className":6158,"code":6159,"language":12,"meta":8},[73],"var x; // 선언문은 표현식이 아닌 문\n\nx = 100; // 할당문은 표현식인 문\n",[6161],{"type":18,"tag":77,"props":6162,"children":6163},{"__ignoreMap":8},[6164],{"type":23,"value":6159},{"type":18,"tag":19,"props":6166,"children":6167},{},[6168],{"type":23,"value":28},{"type":18,"tag":19,"props":6170,"children":6171},{},[6172],{"type":23,"value":6173},"표현식인 문은 변수에 할당 가능하지만 표현식이 아닌 문은 변수에 할당이 불가하다.",{"type":18,"tag":70,"props":6175,"children":6178},{"className":6176,"code":6177,"language":12,"meta":8},[73],"var x = 100; // 가능\n\nvar x = var foo; // 불가능\n",[6179],{"type":18,"tag":77,"props":6180,"children":6181},{"__ignoreMap":8},[6182],{"type":23,"value":6177},{"type":18,"tag":1844,"props":6184,"children":6185},{},[],{"type":18,"tag":1008,"props":6187,"children":6188},{"id":5109},[6189],{"type":18,"tag":265,"props":6190,"children":6191},{},[6192],{"type":23,"value":5109},{"type":18,"tag":1334,"props":6194,"children":6195},{},[6196],{"type":18,"tag":212,"props":6197,"children":6198},{},[6199],{"type":18,"tag":265,"props":6200,"children":6201},{},[6202],{"type":23,"value":5125},{"title":8,"searchDepth":429,"depth":429,"links":6204},[6205,6206,6207,6208,6209,6210],{"id":4630,"depth":429,"text":4630},{"id":6058,"depth":429,"text":6058},{"id":6079,"depth":429,"text":6079},{"id":6098,"depth":429,"text":6098},{"id":6122,"depth":429,"text":6125},{"id":5109,"depth":429,"text":5109},"content:posts:1c1fa102-7f33-48ab-8077-31865e9dd7bc.md","posts/1c1fa102-7f33-48ab-8077-31865e9dd7bc.md",{"_path":6214,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":6215,"description":6216,"tags":6217,"date":6218,"body":6219,"_type":431,"_id":6601,"_source":433,"_file":6602,"_extension":435},"/posts/cbbee657-7850-46ab-b52b-43341e800d37","자바스크립트 - 1. 변수","사상누각이라고 토대나 기초가 튼튼하지 않으면 금방 무너지게 되어 있다. 이번에 쉬면서 javascript 기본부터 토대를 다져야겠다.",[12],"2024-01-26T00:00:00.000Z",{"type":15,"children":6220,"toc":6592},[6221,6225,6231,6240,6245,6250,6254,6259,6263,6268,6272,6277,6282,6287,6299,6310,6314,6318,6322,6327,6344,6352,6356,6362,6367,6372,6378,6382,6387,6400,6404,6409,6418,6422,6428,6437,6441,6446,6451,6459,6463,6474,6478,6484,6493,6502,6510,6518,6522,6528,6533,6542,6550,6554,6559,6564,6568,6571,6578,6588],{"type":18,"tag":19,"props":6222,"children":6223},{},[6224],{"type":23,"value":6216},{"type":18,"tag":1008,"props":6226,"children":6228},{"id":6227},"변수란",[6229],{"type":23,"value":6230},"변수란?",{"type":18,"tag":70,"props":6232,"children":6235},{"code":6233,"language":12,"meta":8,"className":6234},"10 + 20\n",[73],[6236],{"type":18,"tag":77,"props":6237,"children":6238},{"__ignoreMap":8},[6239],{"type":23,"value":6233},{"type":18,"tag":19,"props":6241,"children":6242},{},[6243],{"type":23,"value":6244},"위 코드는 javascript에서 어떻게 동작할까? 우선 각 임의의 메모리 셀에 10, 20으로 저장(기억) 되고 CPU는 이 값을 읽어들여 연산을 수행한다. 임의의 메모리 셀에 30으로 저장(기억)된다.",{"type":18,"tag":19,"props":6246,"children":6247},{},[6248],{"type":23,"value":6249},"이때 우리는 10 + 20의 결과를 재사용 하고 싶다면 메모리 주소에 직접 접근하는 것외에는 방법이 없다. 하지만 메모리 주소를 통해 직접 접근하는 것은 치명적 오류를 발생시킬 가능성이 높다. 자바스크립트는 개발자가 직접적으로 메모리 제어를 허용하지 않는다.",{"type":18,"tag":19,"props":6251,"children":6252},{},[6253],{"type":23,"value":28},{"type":18,"tag":19,"props":6255,"children":6256},{},[6257],{"type":23,"value":6258},"이때 프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 변수라는 메커니즘을 제공한다.",{"type":18,"tag":19,"props":6260,"children":6261},{},[6262],{"type":23,"value":28},{"type":18,"tag":19,"props":6264,"children":6265},{},[6266],{"type":23,"value":6267},"변수는 메모리에 접근하기 위해 사용되는 식별자다.",{"type":18,"tag":19,"props":6269,"children":6270},{},[6271],{"type":23,"value":28},{"type":18,"tag":19,"props":6273,"children":6274},{},[6275],{"type":23,"value":6276},"변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.",{"type":18,"tag":19,"props":6278,"children":6279},{},[6280],{"type":23,"value":6281},"값의 위치를 가리키는 상징적인 이름",{"type":18,"tag":19,"props":6283,"children":6284},{},[6285],{"type":23,"value":6286},"메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름을 **변수 이름(또는 변수명)**이라하고",{"type":18,"tag":19,"props":6288,"children":6289},{},[6290,6292,6297],{"type":23,"value":6291},"변수에 저장된 값을 ",{"type":18,"tag":265,"props":6293,"children":6294},{},[6295],{"type":23,"value":6296},"변수 값",{"type":23,"value":6298},"이라고 한다.",{"type":18,"tag":19,"props":6300,"children":6301},{},[6302,6304,6309],{"type":23,"value":6303},"변수에 값을 저장하는 것을 **할당(대입, 저장)**이라고 하고, 변수에 저장된 값을 읽어 들이는 것을 ",{"type":18,"tag":265,"props":6305,"children":6306},{},[6307],{"type":23,"value":6308},"참조",{"type":23,"value":1412},{"type":18,"tag":96,"props":6311,"children":6313},{"src":6312},"/blog/images/b8bbf4ed-f702-4d06-ae23-f27a3ade83d5.png",[],{"type":18,"tag":96,"props":6315,"children":6317},{"src":6316},"/blog/images/99cdc814-d990-4b94-8d13-ae9dac674922.png",[],{"type":18,"tag":19,"props":6319,"children":6320},{},[6321],{"type":23,"value":28},{"type":18,"tag":1008,"props":6323,"children":6325},{"id":6324},"식별자",[6326],{"type":23,"value":6324},{"type":18,"tag":19,"props":6328,"children":6329},{},[6330,6332,6336,6338,6342],{"type":23,"value":6331},"변수 이름을 ",{"type":18,"tag":265,"props":6333,"children":6334},{},[6335],{"type":23,"value":6324},{"type":23,"value":6337},"라고도 한다. ",{"type":18,"tag":265,"props":6339,"children":6340},{},[6341],{"type":23,"value":6324},{"type":23,"value":6343},"는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.",{"type":18,"tag":1449,"props":6345,"children":6346},{},[6347],{"type":18,"tag":19,"props":6348,"children":6349},{},[6350],{"type":23,"value":6351},"식별자라는 용어는 변수 이름에만 국한해서 사용하지 않음. 예를 들어, 변수, 함수, 클래스 등의 이름은 모두 식별자",{"type":18,"tag":19,"props":6353,"children":6354},{},[6355],{"type":23,"value":28},{"type":18,"tag":1008,"props":6357,"children":6359},{"id":6358},"변수-선언",[6360],{"type":23,"value":6361},"변수 선언",{"type":18,"tag":19,"props":6363,"children":6364},{},[6365],{"type":23,"value":6366},"변수를 생성하는 것을 말함. 더 자세히는 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비. 변수 선언에 의해 확보된 메모리 공간은 누구도 확보된 메모리 공간을 사용할 수 없도록 보호 됨.",{"type":18,"tag":19,"props":6368,"children":6369},{},[6370],{"type":23,"value":6371},"변수 선언은 var, let ,const 키워드를 사용",{"type":18,"tag":1776,"props":6373,"children":6375},{"emogi":6374,"color":1779},"⛔",[6376],{"type":23,"value":6377},"var 키워드는 여러 단점이 있음. 대표적으로 블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프를 지원한다는 것. 때문에 의도치 않게 전역 변수로 선언이 되어 심각한 부작용이 발생하기도 함.",{"type":18,"tag":19,"props":6379,"children":6380},{},[6381],{"type":23,"value":28},{"type":18,"tag":19,"props":6383,"children":6384},{},[6385],{"type":23,"value":6386},"자바스크립트 엔진은 변수 선언을 다음과 같은 2단계에 거쳐 수행",{"type":18,"tag":1334,"props":6388,"children":6389},{},[6390,6395],{"type":18,"tag":212,"props":6391,"children":6392},{},[6393],{"type":23,"value":6394},"선언 단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.",{"type":18,"tag":212,"props":6396,"children":6397},{},[6398],{"type":23,"value":6399},"초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.",{"type":18,"tag":19,"props":6401,"children":6402},{},[6403],{"type":23,"value":28},{"type":18,"tag":19,"props":6405,"children":6406},{},[6407],{"type":23,"value":6408},"var 키워드는 선언 단계와 초기화 단계가 동시에 진행 됨.",{"type":18,"tag":70,"props":6410,"children":6413},{"code":6411,"language":12,"meta":8,"className":6412},"var score;\n// 선언 단계를 통해 변수 이름 score를 등록하고 (메모리 공간을 확보하고)\n// 초기화 단계를 통해 암묵적으로 undefined를 할당해 초기화\n",[73],[6414],{"type":18,"tag":77,"props":6415,"children":6416},{"__ignoreMap":8},[6417],{"type":23,"value":6411},{"type":18,"tag":19,"props":6419,"children":6420},{},[6421],{"type":23,"value":28},{"type":18,"tag":1008,"props":6423,"children":6425},{"id":6424},"변수-선언의-실행-시점과-변수-호이스팅",[6426],{"type":23,"value":6427},"변수 선언의 실행 시점과 변수 호이스팅",{"type":18,"tag":70,"props":6429,"children":6432},{"code":6430,"language":12,"meta":8,"className":6431},"console.log(score); // undefined\nvar score = 1;\n",[73],[6433],{"type":18,"tag":77,"props":6434,"children":6435},{"__ignoreMap":8},[6436],{"type":23,"value":6430},{"type":18,"tag":19,"props":6438,"children":6439},{},[6440],{"type":23,"value":28},{"type":18,"tag":19,"props":6442,"children":6443},{},[6444],{"type":23,"value":6445},"참조 에러가 발생해야 하는데 undefined가 출력이 된다.",{"type":18,"tag":19,"props":6447,"children":6448},{},[6449],{"type":23,"value":6450},"자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서 먼저 소스코드의 평가 과정을 거친다. 이 과정에서 var 키워드는 선언 단계와 초기화 단계가 동시에 진행되기 때문에 undefined가 할당이 된다.",{"type":18,"tag":1449,"props":6452,"children":6453},{},[6454],{"type":18,"tag":19,"props":6455,"children":6456},{},[6457],{"type":23,"value":6458},"변수 선언(선언 단계와 초기화 단계)이 소스코드가 순차적으로 실행되는 런타임 이전 단계에서 먼저 실행된다는 증거다.",{"type":18,"tag":19,"props":6460,"children":6461},{},[6462],{"type":23,"value":28},{"type":18,"tag":19,"props":6464,"children":6465},{},[6466,6468,6473],{"type":23,"value":6467},"변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 ",{"type":18,"tag":265,"props":6469,"children":6470},{},[6471],{"type":23,"value":6472},"변수 호이스팅",{"type":23,"value":3698},{"type":18,"tag":19,"props":6475,"children":6476},{},[6477],{"type":23,"value":28},{"type":18,"tag":1008,"props":6479,"children":6481},{"id":6480},"값의-할당",[6482],{"type":23,"value":6483},"값의 할당",{"type":18,"tag":70,"props":6485,"children":6488},{"code":6486,"language":12,"meta":8,"className":6487},"var score; // 변수 선언\nscore = 80; // 값의 할당\n",[73],[6489],{"type":18,"tag":77,"props":6490,"children":6491},{"__ignoreMap":8},[6492],{"type":23,"value":6486},{"type":18,"tag":70,"props":6494,"children":6497},{"code":6495,"language":12,"meta":8,"className":6496},"var score = 80; // 변수 선언과 값의 할당 \n\n// 자바스크립트 엔진은 \nvar score;\nscore = 80; // 으로 해석\n",[73],[6498],{"type":18,"tag":77,"props":6499,"children":6500},{"__ignoreMap":8},[6501],{"type":23,"value":6495},{"type":18,"tag":1449,"props":6503,"children":6504},{},[6505],{"type":18,"tag":19,"props":6506,"children":6507},{},[6508],{"type":23,"value":6509},"주의할 점: 변수 선언과 값의 할당의 실행 시점은 다르다.",{"type":18,"tag":70,"props":6511,"children":6513},{"code":6512},"- 런타임: 소스코드가 순차적으로 실행되는 시점\n\n**변수 선언**은 런타임 이전\n**값의 할당**은 런타임에 실행\n",[6514],{"type":18,"tag":77,"props":6515,"children":6516},{"__ignoreMap":8},[6517],{"type":23,"value":6512},{"type":18,"tag":96,"props":6519,"children":6521},{"src":6520},"/blog/images/07ab7d69-4c2c-406f-9484-ed7f09f0e99c.png",[],{"type":18,"tag":1008,"props":6523,"children":6525},{"id":6524},"값의-재할당",[6526],{"type":23,"value":6527},"값의 재할당",{"type":18,"tag":19,"props":6529,"children":6530},{},[6531],{"type":23,"value":6532},"이미 할당되어 있는 변수에 새로운 값을 또다시 할당",{"type":18,"tag":70,"props":6534,"children":6537},{"code":6535,"language":12,"meta":8,"className":6536},"var score = 80; // 변수 선언과 값의 할당\nscore = 90; // 값의 재할당\n",[73],[6538],{"type":18,"tag":77,"props":6539,"children":6540},{"__ignoreMap":8},[6541],{"type":23,"value":6535},{"type":18,"tag":1449,"props":6543,"children":6544},{},[6545],{"type":18,"tag":19,"props":6546,"children":6547},{},[6548],{"type":23,"value":6549},"var 키워드로 선언한 변수는 선언과 동시에 undefined로 초기화되기 때문에 엄밀히 말하자면 재할당이다.",{"type":18,"tag":96,"props":6551,"children":6553},{"src":6552},"/blog/images/693b4198-7d85-4b01-af9c-251b8df876c3.png",[],{"type":18,"tag":19,"props":6555,"children":6556},{},[6557],{"type":23,"value":6558},"undefined와 80은 어떤 식별자와도 연결 되어 있지 않기 때문에 가비지 콜렉터에 의해 메모리에서 자동 해제된다.",{"type":18,"tag":1776,"props":6560,"children":6561},{"emogi":1778,"color":1779},[6562],{"type":23,"value":6563},"위 var result = 10 + 20 에서 10과 20도 가비지 콜렉터에 의해 메모리에서 자동 해제 된다.",{"type":18,"tag":19,"props":6565,"children":6566},{},[6567],{"type":23,"value":28},{"type":18,"tag":1844,"props":6569,"children":6570},{},[],{"type":18,"tag":1008,"props":6572,"children":6573},{"id":5109},[6574],{"type":18,"tag":265,"props":6575,"children":6576},{},[6577],{"type":23,"value":5109},{"type":18,"tag":1334,"props":6579,"children":6580},{},[6581],{"type":18,"tag":212,"props":6582,"children":6583},{},[6584],{"type":18,"tag":265,"props":6585,"children":6586},{},[6587],{"type":23,"value":5125},{"type":18,"tag":19,"props":6589,"children":6590},{},[6591],{"type":23,"value":28},{"title":8,"searchDepth":429,"depth":429,"links":6593},[6594,6595,6596,6597,6598,6599,6600],{"id":6227,"depth":429,"text":6230},{"id":6324,"depth":429,"text":6324},{"id":6358,"depth":429,"text":6361},{"id":6424,"depth":429,"text":6427},{"id":6480,"depth":429,"text":6483},{"id":6524,"depth":429,"text":6527},{"id":5109,"depth":429,"text":5109},"content:posts:cbbee657-7850-46ab-b52b-43341e800d37.md","posts/cbbee657-7850-46ab-b52b-43341e800d37.md",{"_path":6604,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":6605,"description":6606,"tags":6607,"date":6608,"body":6609,"_type":431,"_id":6649,"_source":433,"_file":6650,"_extension":435},"/posts/79fae84a-5e7f-4cb1-a14f-6f6db7629ec0","javascript this","자신이 속한 객체 또는 자신이 생성할 인스턴스를 가르키는 자기 참조 변수(self-referencing variable)다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.",[12],"2024-01-23T00:00:00.000Z",{"type":15,"children":6610,"toc":6647},[6611,6615,6619,6624,6633,6638],{"type":18,"tag":19,"props":6612,"children":6613},{},[6614],{"type":23,"value":6606},{"type":18,"tag":19,"props":6616,"children":6617},{},[6618],{"type":23,"value":28},{"type":18,"tag":19,"props":6620,"children":6621},{},[6622],{"type":23,"value":6623},"this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.",{"type":18,"tag":70,"props":6625,"children":6628},{"className":6626,"code":6627,"language":12,"meta":8},[73],"// 객체 리터럴\nconst circle = {\n    redius: 5,\n    getDiameter() {\n        // this는 메서드를 호출한 객체를 가리킨다.\n        return 2 * this.radius\n    }\n}\nconsole.log(circle.getDiameter()); // 10\n\n\n// 생성자 함수\nfunction Circle(radius) {\n    // this는 생성자 함수가 생성할 인스턴스를 가르킨다.\n    this.radius = radius;\n}\nCircle.prototype.getDiameter = function() {\n    //this는 생성자 함수가 생성할 인스턴스를 가르킨다.\n    return 2 * this.radius;\n}\n\n\n// 인스턴스 생성\nconst circle = new Circe(5);\nconsole.log(circle.getDiameter());\n",[6629],{"type":18,"tag":77,"props":6630,"children":6631},{"__ignoreMap":8},[6632],{"type":23,"value":6627},{"type":18,"tag":19,"props":6634,"children":6635},{},[6636],{"type":23,"value":6637},"클래스 기반 언어에서는 this는 언제나 클래스가 생성하는 인스턴스를 가리킨다. 하지만 자바스크립트의 this는 함수가 호출되는 방식에 따라 동적으로 결정된다.",{"type":18,"tag":70,"props":6639,"children":6642},{"className":6640,"code":6641,"language":12,"meta":8},[73],"// this는 함수 호출 방식에 따라 동적으로 결정 됨.\nconst foo = function() {\n    console.log(this);\n}\n\n// 1. 일반 함수 호출\nfoo() // window\n\n\n// 2. 메서드 호출\nconst obj = { foo };\nobj.foo(); // obj\n\n// 3. 생성자 함수 호출\nnew foo(); // foo {}\n\n// 4. apply/call/bind 메서드에 의한 간접 호출\nconst bar = {name: 'bar'};\nfoo.call(bar); // bar\nfoo.apply(bar); //bar\nfoo.bind(bar)(); //bar\n",[6643],{"type":18,"tag":77,"props":6644,"children":6645},{"__ignoreMap":8},[6646],{"type":23,"value":6641},{"title":8,"searchDepth":429,"depth":429,"links":6648},[],"content:posts:79fae84a-5e7f-4cb1-a14f-6f6db7629ec0.md","posts/79fae84a-5e7f-4cb1-a14f-6f6db7629ec0.md",{"_path":6652,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":6653,"description":6654,"tags":6655,"date":6656,"body":6657,"_type":431,"_id":6730,"_source":433,"_file":6731,"_extension":435},"/posts/7516dc85-4ccc-4f99-afc1-22f8115737df","Call, Apply, Bind","Call, Apply, Bind는 this와 관련이 있다. this를 특정 객체에 명시적으로 바인딩 시키는 메소드이다.",[12],"2024-01-15T00:00:00.000Z",{"type":15,"children":6658,"toc":6726},[6659,6672,6678,6687,6692,6696,6701,6707,6712,6717],{"type":18,"tag":19,"props":6660,"children":6661},{},[6662,6664,6670],{"type":23,"value":6663},"Call, Apply, Bind는 this와 관련이 있다. this를 특정 객체에 ",{"type":18,"tag":77,"props":6665,"children":6667},{"className":6666},[],[6668],{"type":23,"value":6669},"명시적으로 바인딩",{"type":23,"value":6671}," 시키는 메소드이다.",{"type":18,"tag":1666,"props":6673,"children":6675},{"id":6674},"먼저-call-apply를-코드로-살펴-보자",[6676],{"type":23,"value":6677},"먼저 Call, Apply를 코드로 살펴 보자",{"type":18,"tag":70,"props":6679,"children":6682},{"className":6680,"code":6681,"language":12,"meta":8},[73],"const seungyoon = {\n  name: 'seungyoon',\n}\n\nfunction greeting(city, hobby) {\n  console.log(`Hello my name is ${this.name}, I live in ${city}. my hobby is ${hobby}.`);\n}\n\ngreeting('seoul', 'listening to music'); // Hello my name is , I live in seoul. my hobby is listening to music.\ngreeting.apply(seungyoon, ['seoul', 'listening to music']); // Hello my name is seungyoon, I live in seoul. my hobby is listening to music.\ngreeting.call(seungyoon, 'seoul', 'listening to music'); // Hello my name is seungyoon, I live in seoul. my hobby is listening to music\n\n",[6683],{"type":18,"tag":77,"props":6684,"children":6685},{"__ignoreMap":8},[6686],{"type":23,"value":6681},{"type":18,"tag":19,"props":6688,"children":6689},{},[6690],{"type":23,"value":6691},"이렇게 this 특정 객체에 명시적으로 바인딩 시키고 싶을 때 call, apply를 사용하면 된다.",{"type":18,"tag":96,"props":6693,"children":6695},{"src":6694},"/blog/images/7e9926bc-71ef-4e1e-a5c6-c35f921b1475.png",[],{"type":18,"tag":19,"props":6697,"children":6698},{},[6699],{"type":23,"value":6700},"(여기서 call과 apply는 기능은 같지만 넘겨받는 인자의 형식만 다르다. call과 다르게 apply는 인자를 배열 형태로 받는다.)",{"type":18,"tag":1666,"props":6702,"children":6704},{"id":6703},"나머지-bind-함수를-살펴보자",[6705],{"type":23,"value":6706},"나머지 bind 함수를 살펴보자.",{"type":18,"tag":19,"props":6708,"children":6709},{},[6710],{"type":23,"value":6711},"이 함수는 call apply와 다르게 함수를 즉시 실행하지 않는다.",{"type":18,"tag":19,"props":6713,"children":6714},{},[6715],{"type":23,"value":6716},"아래 코드와 같이 변수에 담아 호출 할 수가 있다.",{"type":18,"tag":70,"props":6718,"children":6721},{"className":6719,"code":6720,"language":12,"meta":8},[73],"const seungyoon = {\n  name: 'seungyoon',\n}\n\nfunction greeting(city, hobby) {\n  console.log(`Hello my name is ${this.name}, I live in ${city}. my hobby is ${hobby}.`);\n}\n\nconst seungyoonGreeting = greeting.bind(seungyoon);\nseungyoonGreeting('seuol', 'listening to music'); // Hello my name is seungyoon, I live in seuol. my hobby is listening to music.\n\n",[6722],{"type":18,"tag":77,"props":6723,"children":6724},{"__ignoreMap":8},[6725],{"type":23,"value":6720},{"title":8,"searchDepth":429,"depth":429,"links":6727},[6728,6729],{"id":6674,"depth":2349,"text":6677},{"id":6703,"depth":2349,"text":6706},"content:posts:7516dc85-4ccc-4f99-afc1-22f8115737df.md","posts/7516dc85-4ccc-4f99-afc1-22f8115737df.md",1710325141883]