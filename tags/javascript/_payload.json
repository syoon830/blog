[{"data":1,"prerenderedAt":152},["Reactive",2],{"content-query-y68BiRpcNm":3},[4,68],{"_path":5,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":9,"description":10,"tags":11,"date":13,"body":14,"_type":63,"_id":64,"_source":65,"_file":66,"_extension":67},"/posts/79fae84a-5e7f-4cb1-a14f-6f6db7629ec0","posts",false,"","javascript this","자신이 속한 객체 또는 자신이 생성할 인스턴스를 가르키는 자기 참조 변수(self-referencing variable)다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.",[12],"javascript","2024-01-23T00:00:00.000Z",{"type":15,"children":16,"toc":60},"root",[17,24,29,34,46,51],{"type":18,"tag":19,"props":20,"children":21},"element","p",{},[22],{"type":23,"value":10},"text",{"type":18,"tag":19,"props":25,"children":26},{},[27],{"type":23,"value":28},"\\n",{"type":18,"tag":19,"props":30,"children":31},{},[32],{"type":23,"value":33},"this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.",{"type":18,"tag":35,"props":36,"children":40},"pre",{"className":37,"code":39,"language":12,"meta":8},[38],"language-javascript","// 객체 리터럴\nconst circle = {\n    redius: 5,\n    getDiameter() {\n        // this는 메서드를 호출한 객체를 가리킨다.\n        return 2 * this.radius\n    }\n}\nconsole.log(circle.getDiameter()); // 10\n\n\n// 생성자 함수\nfunction Circle(radius) {\n    // this는 생성자 함수가 생성할 인스턴스를 가르킨다.\n    this.radius = radius;\n}\nCircle.prototype.getDiameter = function() {\n    //this는 생성자 함수가 생성할 인스턴스를 가르킨다.\n    return 2 * this.radius;\n}\n\n\n// 인스턴스 생성\nconst circle = new Circe(5);\nconsole.log(circle.getDiameter());\n",[41],{"type":18,"tag":42,"props":43,"children":44},"code",{"__ignoreMap":8},[45],{"type":23,"value":39},{"type":18,"tag":19,"props":47,"children":48},{},[49],{"type":23,"value":50},"클래스 기반 언어에서는 this는 언제나 클래스가 생성하는 인스턴스를 가리킨다. 하지만 자바스크립트의 this는 함수가 호출되는 방식에 따라 동적으로 결정된다.",{"type":18,"tag":35,"props":52,"children":55},{"className":53,"code":54,"language":12,"meta":8},[38],"// this는 함수 호출 방식에 따라 동적으로 결정 됨.\nconst foo = function() {\n    console.log(this);\n}\n\n// 1. 일반 함수 호출\nfoo() // window\n\n\n// 2. 메서드 호출\nconst obj = { foo };\nobj.foo(); // obj\n\n// 3. 생성자 함수 호출\nnew foo(); // foo {}\n\n// 4. apply/call/bind 메서드에 의한 간접 호출\nconst bar = {name: 'bar'};\nfoo.call(bar); // bar\nfoo.apply(bar); //bar\nfoo.bind(bar)(); //bar\n",[56],{"type":18,"tag":42,"props":57,"children":58},{"__ignoreMap":8},[59],{"type":23,"value":54},{"title":8,"searchDepth":61,"depth":61,"links":62},2,[],"markdown","content:posts:79fae84a-5e7f-4cb1-a14f-6f6db7629ec0.md","content","posts/79fae84a-5e7f-4cb1-a14f-6f6db7629ec0.md","md",{"_path":69,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":70,"description":71,"tags":72,"date":73,"body":74,"_type":63,"_id":150,"_source":65,"_file":151,"_extension":67},"/posts/7516dc85-4ccc-4f99-afc1-22f8115737df","Call, Apply, Bind","Call, Apply, Bind는 this와 관련이 있다. this를 특정 객체에 명시적으로 바인딩 시키는 메소드이다.",[12],"2024-01-15T00:00:00.000Z",{"type":15,"children":75,"toc":145},[76,89,96,105,110,115,120,126,131,136],{"type":18,"tag":19,"props":77,"children":78},{},[79,81,87],{"type":23,"value":80},"Call, Apply, Bind는 this와 관련이 있다. this를 특정 객체에 ",{"type":18,"tag":42,"props":82,"children":84},{"className":83},[],[85],{"type":23,"value":86},"명시적으로 바인딩",{"type":23,"value":88}," 시키는 메소드이다.",{"type":18,"tag":90,"props":91,"children":93},"h3",{"id":92},"먼저-call-apply를-코드로-살펴-보자",[94],{"type":23,"value":95},"먼저 Call, Apply를 코드로 살펴 보자",{"type":18,"tag":35,"props":97,"children":100},{"className":98,"code":99,"language":12,"meta":8},[38],"const seungyoon = {\n  name: 'seungyoon',\n}\n\nfunction greeting(city, hobby) {\n  console.log(`Hello my name is ${this.name}, I live in ${city}. my hobby is ${hobby}.`);\n}\n\ngreeting('seoul', 'listening to music'); // Hello my name is , I live in seoul. my hobby is listening to music.\ngreeting.apply(seungyoon, ['seoul', 'listening to music']); // Hello my name is seungyoon, I live in seoul. my hobby is listening to music.\ngreeting.call(seungyoon, 'seoul', 'listening to music'); // Hello my name is seungyoon, I live in seoul. my hobby is listening to music\n\n",[101],{"type":18,"tag":42,"props":102,"children":103},{"__ignoreMap":8},[104],{"type":23,"value":99},{"type":18,"tag":19,"props":106,"children":107},{},[108],{"type":23,"value":109},"이렇게 this 특정 객체에 명시적으로 바인딩 시키고 싶을 때 call, apply를 사용하면 된다.",{"type":18,"tag":111,"props":112,"children":114},"img",{"src":113},"/images/bfaf5344-f31c-497d-9a65-3e2d8e52aaa6.png",[],{"type":18,"tag":19,"props":116,"children":117},{},[118],{"type":23,"value":119},"(여기서 call과 apply는 기능은 같지만 넘겨받는 인자의 형식만 다르다. call과 다르게 apply는 인자를 배열 형태로 받는다.)",{"type":18,"tag":90,"props":121,"children":123},{"id":122},"나머지-bind-함수를-살펴보자",[124],{"type":23,"value":125},"나머지 bind 함수를 살펴보자.",{"type":18,"tag":19,"props":127,"children":128},{},[129],{"type":23,"value":130},"이 함수는 call apply와 다르게 함수를 즉시 실행하지 않는다.",{"type":18,"tag":19,"props":132,"children":133},{},[134],{"type":23,"value":135},"아래 코드와 같이 변수에 담아 호출 할 수가 있다.",{"type":18,"tag":35,"props":137,"children":140},{"className":138,"code":139,"language":12,"meta":8},[38],"const seungyoon = {\n  name: 'seungyoon',\n}\n\nfunction greeting(city, hobby) {\n  console.log(`Hello my name is ${this.name}, I live in ${city}. my hobby is ${hobby}.`);\n}\n\nconst seungyoonGreeting = greeting.bind(seungyoon);\nseungyoonGreeting('seuol', 'listening to music'); // Hello my name is seungyoon, I live in seuol. my hobby is listening to music.\n\n",[141],{"type":18,"tag":42,"props":142,"children":143},{"__ignoreMap":8},[144],{"type":23,"value":139},{"title":8,"searchDepth":61,"depth":61,"links":146},[147,149],{"id":92,"depth":148,"text":95},3,{"id":122,"depth":148,"text":125},"content:posts:7516dc85-4ccc-4f99-afc1-22f8115737df.md","posts/7516dc85-4ccc-4f99-afc1-22f8115737df.md",1706169827468]