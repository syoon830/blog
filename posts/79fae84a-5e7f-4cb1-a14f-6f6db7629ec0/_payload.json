[{"data":1,"prerenderedAt":67},["Reactive",2],{"content-query-vRgVFS3bfY":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"tags":10,"date":12,"body":13,"_type":62,"_id":63,"_source":64,"_file":65,"_extension":66},"/posts/79fae84a-5e7f-4cb1-a14f-6f6db7629ec0","posts",false,"","javascript this","자신이 속한 객체 또는 자신이 생성할 인스턴스를 가르키는 자기 참조 변수(self-referencing variable)다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.",[11],"javascript","2024-01-23T00:00:00.000Z",{"type":14,"children":15,"toc":59},"root",[16,23,28,33,45,50],{"type":17,"tag":18,"props":19,"children":20},"element","p",{},[21],{"type":22,"value":9},"text",{"type":17,"tag":18,"props":24,"children":25},{},[26],{"type":22,"value":27},"\\n",{"type":17,"tag":18,"props":29,"children":30},{},[31],{"type":22,"value":32},"this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.",{"type":17,"tag":34,"props":35,"children":39},"pre",{"className":36,"code":38,"language":11,"meta":7},[37],"language-javascript","// 객체 리터럴\nconst circle = {\n    redius: 5,\n    getDiameter() {\n        // this는 메서드를 호출한 객체를 가리킨다.\n        return 2 * this.radius\n    }\n}\nconsole.log(circle.getDiameter()); // 10\n\n\n// 생성자 함수\nfunction Circle(radius) {\n    // this는 생성자 함수가 생성할 인스턴스를 가르킨다.\n    this.radius = radius;\n}\nCircle.prototype.getDiameter = function() {\n    //this는 생성자 함수가 생성할 인스턴스를 가르킨다.\n    return 2 * this.radius;\n}\n\n\n// 인스턴스 생성\nconst circle = new Circe(5);\nconsole.log(circle.getDiameter());\n",[40],{"type":17,"tag":41,"props":42,"children":43},"code",{"__ignoreMap":7},[44],{"type":22,"value":38},{"type":17,"tag":18,"props":46,"children":47},{},[48],{"type":22,"value":49},"클래스 기반 언어에서는 this는 언제나 클래스가 생성하는 인스턴스를 가리킨다. 하지만 자바스크립트의 this는 함수가 호출되는 방식에 따라 동적으로 결정된다.",{"type":17,"tag":34,"props":51,"children":54},{"className":52,"code":53,"language":11,"meta":7},[37],"// this는 함수 호출 방식에 따라 동적으로 결정 됨.\nconst foo = function() {\n    console.log(this);\n}\n\n// 1. 일반 함수 호출\nfoo() // window\n\n\n// 2. 메서드 호출\nconst obj = { foo };\nobj.foo(); // obj\n\n// 3. 생성자 함수 호출\nnew foo(); // foo {}\n\n// 4. apply/call/bind 메서드에 의한 간접 호출\nconst bar = {name: 'bar'};\nfoo.call(bar); // bar\nfoo.apply(bar); //bar\nfoo.bind(bar)(); //bar\n",[55],{"type":17,"tag":41,"props":56,"children":57},{"__ignoreMap":7},[58],{"type":22,"value":53},{"title":7,"searchDepth":60,"depth":60,"links":61},2,[],"markdown","content:posts:79fae84a-5e7f-4cb1-a14f-6f6db7629ec0.md","content","posts/79fae84a-5e7f-4cb1-a14f-6f6db7629ec0.md","md",1710325141889]