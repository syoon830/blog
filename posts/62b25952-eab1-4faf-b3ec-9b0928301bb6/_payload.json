[{"data":1,"prerenderedAt":385},["Reactive",2],{"content-query-E6NQ1we8Fc":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"tags":10,"date":12,"body":13,"_type":380,"_id":381,"_source":382,"_file":383,"_extension":384},"/posts/62b25952-eab1-4faf-b3ec-9b0928301bb6","posts",false,"","자바스크립트 - 18. this","this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수(self-referencing variable)다.",[11],"javascript","2024-02-26T00:00:00.000Z",{"type":14,"children":15,"toc":373},"root",[16,23,28,35,40,56,63,68,73,85,89,94,103,107,112,121,125,130,139,148,156,165,173,182,188,193,202,207,212,216,221,230,234,239,248,252,258,263,272,278,287,291,296,300,305,314,318,323,332,336,341,350,355,364],{"type":17,"tag":18,"props":19,"children":20},"element","p",{},[21],{"type":22,"value":9},"text",{"type":17,"tag":18,"props":24,"children":25},{},[26],{"type":22,"value":27},"자바스크립트 this는 함수가 호출되는 방식에 따라 this에 바인딩될 값, 즉 this 바인딩이 동적으로 결정된다.",{"type":17,"tag":29,"props":30,"children":32},"h1",{"id":31},"함수-호출-방식과-this-바인딩",[33],{"type":22,"value":34},"함수 호출 방식과 this 바인딩",{"type":17,"tag":18,"props":36,"children":37},{},[38],{"type":22,"value":39},"렉시컬 스코프와 this 바인딩은 결정 시기가 다르다.",{"type":17,"tag":41,"props":42,"children":43},"ul",{},[44],{"type":17,"tag":45,"props":46,"children":47},"li",{},[48,50,54],{"type":22,"value":49},"함수의 상위 스코프를 결정하는 방식인 렉시컬 스코프는 함수 정의가 평가되어 함수 객체가 생성되는 시점에 상위 스코프를 결정한다. 하지만 this 바인딩은 함수 호출 시점에 결정된다.",{"type":17,"tag":51,"props":52,"children":53},"br",{},[],{"type":22,"value":55},"\\n",{"type":17,"tag":57,"props":58,"children":60},"h2",{"id":59},"일반-함수-호출",[61],{"type":22,"value":62},"일반 함수 호출",{"type":17,"tag":18,"props":64,"children":65},{},[66],{"type":22,"value":67},"기본적으로 this에는 전역 객체(global object)가 바인딩된다.",{"type":17,"tag":18,"props":69,"children":70},{},[71],{"type":22,"value":72},"전역 함수는 물론이고 중첩 함수를 일반 함수로 호출하면 함수 내부의 this에는 전역 객체가 바인딩된다.",{"type":17,"tag":74,"props":75,"children":79},"pre",{"className":76,"code":78,"language":11,"meta":7},[77],"language-javascript","function foo() {\n    console.log(\"foo's this: \", this); // window\n    function bar() {\n        console.log(\"bar's this: \", this); // window\n    }\n    bar();\n}\nfoo();\n",[80],{"type":17,"tag":81,"props":82,"children":83},"code",{"__ignoreMap":7},[84],{"type":22,"value":78},{"type":17,"tag":18,"props":86,"children":87},{},[88],{"type":22,"value":55},{"type":17,"tag":18,"props":90,"children":91},{},[92],{"type":22,"value":93},"메서드(객체 안에 함수) 내에서 정의한 중첩 함수도 일반 함수로 호출되면 중첩 함수 내부의 this에는 전역 객체가 바인딩된다.",{"type":17,"tag":74,"props":95,"children":98},{"className":96,"code":97,"language":11,"meta":7},[77],"var value = 1;\n\nconst obj = {\n    value: 100,\n    foo() {\n        console.log(this); // {value: 100, foo: f}\n        consoel.log(this.value); // 100\n\n        function bar() {\n            console.log(this); // window\n            console.log(this.value); // 1\n        }\n        bar();\n    }\n}\n",[99],{"type":17,"tag":81,"props":100,"children":101},{"__ignoreMap":7},[102],{"type":22,"value":97},{"type":17,"tag":18,"props":104,"children":105},{},[106],{"type":22,"value":55},{"type":17,"tag":18,"props":108,"children":109},{},[110],{"type":22,"value":111},"콜백 함수가 일반 함수로 호출된다면 콜백 함수 내부의 this에도 전역 객체가 바인딩된다. 어떠한 함수라도 일반 함수로 호출되면 this에 전역 객체가 바인딩된다.",{"type":17,"tag":74,"props":113,"children":116},{"className":114,"code":115,"language":11,"meta":7},[77],"var value = 1;\n\nconst obj = {\n    value: 100,\n    foo() {\n        console.log(this); // {value: 100, foo: f}\n        setTimeout(function() {\n            console.log(this.value); // 1\n        })\n    }\n}\n",[117],{"type":17,"tag":81,"props":118,"children":119},{"__ignoreMap":7},[120],{"type":22,"value":115},{"type":17,"tag":18,"props":122,"children":123},{},[124],{"type":22,"value":55},{"type":17,"tag":18,"props":126,"children":127},{},[128],{"type":22,"value":129},"메서드 내부의 중첩 함수나 콜백 함수의 this 바인딩을 메서드의 this 바인딩과 일치시키기 위한 방법",{"type":17,"tag":131,"props":132,"children":133},"ol",{},[134],{"type":17,"tag":45,"props":135,"children":136},{},[137],{"type":22,"value":138},"this를 변수에 할당",{"type":17,"tag":74,"props":140,"children":143},{"className":141,"code":142,"language":11,"meta":7},[77],"var value = 1;\n\nconst obj = {\n    value: 100,\n    foo() {\n        var that = this;\n        setTimeout(function() {\n            console.log(that.value); // 100\n        })\n    }\n}\n",[144],{"type":17,"tag":81,"props":145,"children":146},{"__ignoreMap":7},[147],{"type":22,"value":142},{"type":17,"tag":131,"props":149,"children":150},{},[151],{"type":17,"tag":45,"props":152,"children":153},{},[154],{"type":22,"value":155},"apply, call, bind",{"type":17,"tag":74,"props":157,"children":160},{"className":158,"code":159,"language":11,"meta":7},[77],"var value = 1;\n\nconst obj = {\n    value: 100,\n    foo() {\n        setTimeout(function() {\n            console.log(this.value); // 100\n        }.bind(this))\n    }\n}\n",[161],{"type":17,"tag":81,"props":162,"children":163},{"__ignoreMap":7},[164],{"type":22,"value":159},{"type":17,"tag":131,"props":166,"children":167},{},[168],{"type":17,"tag":45,"props":169,"children":170},{},[171],{"type":22,"value":172},"화살표 함수",{"type":17,"tag":74,"props":174,"children":177},{"className":175,"code":176,"language":11,"meta":7},[77],"var value = 1;\n\nconst obj = {\n    value: 100,\n    foo() {\n        setTimeout(() => {\n            console.log(this.value); // 100\n        })\n    }\n}\n",[178],{"type":17,"tag":81,"props":179,"children":180},{"__ignoreMap":7},[181],{"type":22,"value":176},{"type":17,"tag":57,"props":183,"children":185},{"id":184},"메서드-호출",[186],{"type":22,"value":187},"메서드 호출",{"type":17,"tag":18,"props":189,"children":190},{},[191],{"type":22,"value":192},"메서드 내부의 this에는 메서드를 호출한 객체, 즉 메서드를 호출할 때 메서드 이름 앞의 마침표(.) 연산자 앞에 기술한 객체가 바인딩된다. 주의할 것은 메서드 내부의 this는 메서드를 소유한 객체가 아닌 메서드를 호출한 객체에 바인딩된다는 것이다.",{"type":17,"tag":74,"props":194,"children":197},{"className":195,"code":196,"language":11,"meta":7},[77],"const person = {\n    name: 'Lee',\n    getName() {\n        return this.name;\n    }\n}\nconsole.log(person.getName());\n",[198],{"type":17,"tag":81,"props":199,"children":200},{"__ignoreMap":7},[201],{"type":22,"value":196},{"type":17,"tag":18,"props":203,"children":204},{},[205],{"type":22,"value":206},"오해하면 안되는게 getName의 함수 객체는 person의 포함된게 아니라 독립적으로 존재하는 별도의 객체(메모리에 별도로)다. getName 프로퍼티가 함수 객체를 가리키고 있을 뿐이다.",{"type":17,"tag":208,"props":209,"children":211},"img",{"src":210},"/blog/images/cb4e4952-aafd-4800-aead-6b2d8cc4fccd.png",[],{"type":17,"tag":18,"props":213,"children":214},{},[215],{"type":22,"value":55},{"type":17,"tag":18,"props":217,"children":218},{},[219],{"type":22,"value":220},"따라서 getName 프로퍼티가 가리키는 함수 객체, 즉 getName 메서드는 다른 객체의 프로퍼티에 할당하는 것으로 다른 객체의 메서드가 될 수도 있고 일반 변수에 할당하여 일반 함수로 호출될 수도 있다.",{"type":17,"tag":74,"props":222,"children":225},{"className":223,"code":224,"language":11,"meta":7},[77],"const person = {\n  name: 'Lee',\n  getName() {\n    return this.name;\n  }\n}\nconst annotherPerson = {\n  name: 'kim'\n}\nannotherPerson.getName = person.getName;\nconsole.log(annotherPerson.getName()); // kim\n\nlet getName = person.getName;\nconsole.log(getName()); // ''\n",[226],{"type":17,"tag":81,"props":227,"children":228},{"__ignoreMap":7},[229],{"type":22,"value":224},{"type":17,"tag":18,"props":231,"children":232},{},[233],{"type":22,"value":55},{"type":17,"tag":18,"props":235,"children":236},{},[237],{"type":22,"value":238},"프로토타입 메서드 내부에서 사용된 this도 일반 메서드와 마찬가지로 해당 메서드를 호출한 객체에 바인딩된다.",{"type":17,"tag":74,"props":240,"children":243},{"className":241,"code":242,"language":11,"meta":7},[77],"function Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.getName = funciton() {\n    return this.name;\n};\n\nconst me = new Person('Lee');\n\nconsole.log(me.getName()); // Lee\n\nPerson.prototype.name = \"kim\";\nconsole.log(person.prototype.getName()); // kim\n",[244],{"type":17,"tag":81,"props":245,"children":246},{"__ignoreMap":7},[247],{"type":22,"value":242},{"type":17,"tag":18,"props":249,"children":250},{},[251],{"type":22,"value":55},{"type":17,"tag":57,"props":253,"children":255},{"id":254},"생성자-함수-호출",[256],{"type":22,"value":257},"생성자 함수 호출",{"type":17,"tag":18,"props":259,"children":260},{},[261],{"type":22,"value":262},"생성자 함수 내부의 this에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩된다.",{"type":17,"tag":74,"props":264,"children":267},{"className":265,"code":266,"language":11,"meta":7},[77],"function Circle(radius) {\n    this.radius = radius;\n    this.getDiameter = function() {\n        return 2 * this.radius;\n    }\n}\n\nconst circle1 = new Circle(5);\n\n// 만약 new 연산자와 함께 호출하지 않으면 생성자 함수로 동작하지 않는다. 일반적인 함수의 호출이다.\nconst circle2 = Circle(15); // 이때 this는 window이므로 window.radius = 15가 된다.\nconsole.log(radius); // 15\n",[268],{"type":17,"tag":81,"props":269,"children":270},{"__ignoreMap":7},[271],{"type":22,"value":266},{"type":17,"tag":57,"props":273,"children":275},{"id":274},"funcitonprototypeapplycallbind-메서드에-의한-간접-호출",[276],{"type":22,"value":277},"Funciton.prototype.apply/call/bind 메서드에 의한 간접 호출",{"type":17,"tag":74,"props":279,"children":282},{"className":280,"code":281,"language":11,"meta":7},[77],"function getThisBinding() {\n    return this;\n}\nconst thisArg = { a: 1 };\n\nconsole.log(getThisBinding()); // window\n\nconsole.log(getThisBinding.call(thisArg)); // {a: 1};\nconsole.log(getThisBinding.apply(thisArg)); // {a: 1};\n",[283],{"type":17,"tag":81,"props":284,"children":285},{"__ignoreMap":7},[286],{"type":22,"value":281},{"type":17,"tag":18,"props":288,"children":289},{},[290],{"type":22,"value":55},{"type":17,"tag":18,"props":292,"children":293},{},[294],{"type":22,"value":295},"apply와 call 메서드의 본질적인 기능은 함수를 호출하는 것이다. apply와 call 메서드는 함수를 호출하면서 첫 번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩한다.",{"type":17,"tag":18,"props":297,"children":298},{},[299],{"type":22,"value":55},{"type":17,"tag":18,"props":301,"children":302},{},[303],{"type":22,"value":304},"apply와 call은 인수를 전달하는 방식만 다를뿐 동일하게 동작한다.",{"type":17,"tag":74,"props":306,"children":309},{"className":307,"code":308,"language":11,"meta":7},[77],"function getThisBinding() {\n    console.log(arguments);\n    return this;\n}\n\nconst thisArg = {a: 1};\n\nconsole.log(getThisBinding.apply(thisArg, [1, 2, 3]);\nconsole.log(getThisBinding.call(thisArg, 1, 2, 3);\n",[310],{"type":17,"tag":81,"props":311,"children":312},{"__ignoreMap":7},[313],{"type":22,"value":308},{"type":17,"tag":18,"props":315,"children":316},{},[317],{"type":22,"value":55},{"type":17,"tag":18,"props":319,"children":320},{},[321],{"type":22,"value":322},"대표적인 용도는 arguments 객체와 같은 유사 배열 객체에 배열 메서드를 사용하는 경우다. arguments 객체는 배열이 아니기 때문에 Array.prototype.slice 같은 배열의 메서드를 사용할 수 없으나 apply와 call 메서드를 이용하면 가능하다.",{"type":17,"tag":74,"props":324,"children":327},{"className":325,"code":326,"language":11,"meta":7},[77],"function convertArgsToArray() {\n    const arr = Array.prototype.slice.call(arguments);\n\n    return arr;\n}\n",[328],{"type":17,"tag":81,"props":329,"children":330},{"__ignoreMap":7},[331],{"type":22,"value":326},{"type":17,"tag":18,"props":333,"children":334},{},[335],{"type":22,"value":55},{"type":17,"tag":18,"props":337,"children":338},{},[339],{"type":22,"value":340},"bind 메서드는 apply와 call 메서드와 달리 함수를 호출하지 않고 this로 사용할 객체만 전달한다.",{"type":17,"tag":74,"props":342,"children":345},{"className":343,"code":344,"language":11,"meta":7},[77],"function getThisBinding() {\n    return this;\n}\n\nconst thisArg = {a:1};\n\nconsole.log(getThisBinding.bind(thisArg)); // getThisBinding\nconsole.log(getThisBidning.bind(thisArg)()); // {a:1}\n",[346],{"type":17,"tag":81,"props":347,"children":348},{"__ignoreMap":7},[349],{"type":22,"value":344},{"type":17,"tag":18,"props":351,"children":352},{},[353],{"type":22,"value":354},"bind 메서드는 메서드의 this와 메서드 내부의 중첩 함수 또는 콜백 함수의 this가 불일치하는 문제를 해결하기 위해 유용하게 사용된다.",{"type":17,"tag":74,"props":356,"children":359},{"className":357,"code":358,"language":11,"meta":7},[77],"const person = {\n    name: 'Lee',\n    foo(callback) {\n        setTimeout(callback, 100);\n    }\n}\nperson.foo(function () {\n    console.log(this); // window\n})\n",[360],{"type":17,"tag":81,"props":361,"children":362},{"__ignoreMap":7},[363],{"type":22,"value":358},{"type":17,"tag":74,"props":365,"children":368},{"className":366,"code":367,"language":11,"meta":7},[77],"const person = {\n    name: 'Lee',\n    foo(callback) {\n        // callback 함수의 this는 여기 this야\n        // bind는 apply와 call과 달리 호출을 하지 않기 때문에 가능\n        setTimeout(callback.bind(this), 100);\n    }\n}\nperson.foo(function () {\n    console.log(this); // {name: 'Lee', foo: f}\n})\n",[369],{"type":17,"tag":81,"props":370,"children":371},{"__ignoreMap":7},[372],{"type":22,"value":367},{"title":7,"searchDepth":374,"depth":374,"links":375},2,[376,377,378,379],{"id":59,"depth":374,"text":62},{"id":184,"depth":374,"text":187},{"id":254,"depth":374,"text":257},{"id":274,"depth":374,"text":277},"markdown","content:posts:62b25952-eab1-4faf-b3ec-9b0928301bb6.md","content","posts/62b25952-eab1-4faf-b3ec-9b0928301bb6.md","md",1718176956648]