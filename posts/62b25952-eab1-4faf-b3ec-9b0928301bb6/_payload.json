[{"data":1,"prerenderedAt":365},["Reactive",2],{"content-query-E6NQ1we8Fc":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"tags":10,"date":12,"body":13,"_type":360,"_id":361,"_source":362,"_file":363,"_extension":364},"/posts/62b25952-eab1-4faf-b3ec-9b0928301bb6","posts",false,"","자바스크립트 - 18. this","this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수(self-referencing variable)다.",[11],"javascript","2024-02-26T00:00:00.000Z",{"type":14,"children":15,"toc":353},"root",[16,23,28,35,40,47,52,57,69,74,79,88,92,97,106,110,115,162,168,173,182,187,192,196,201,210,214,219,228,232,238,243,252,258,267,271,276,280,285,294,298,303,312,316,321,330,335,344],{"type":17,"tag":18,"props":19,"children":20},"element","p",{},[21],{"type":22,"value":9},"text",{"type":17,"tag":18,"props":24,"children":25},{},[26],{"type":22,"value":27},"자바스크립트 this는 함수가 호출되는 방식에 따라 this에 바인딩될 값, 즉 this 바인딩이 동적으로 결정된다.",{"type":17,"tag":29,"props":30,"children":32},"h1",{"id":31},"함수-호출-방식과-this-바인딩",[33],{"type":22,"value":34},"함수 호출 방식과 this 바인딩",{"type":17,"tag":18,"props":36,"children":37},{},[38],{"type":22,"value":39},"렉시컬 스코프와 this 바인딩은 결정 시기가 다르다.",{"type":17,"tag":41,"props":42,"children":44},"h2",{"id":43},"일반-함수-호출",[45],{"type":22,"value":46},"일반 함수 호출",{"type":17,"tag":18,"props":48,"children":49},{},[50],{"type":22,"value":51},"기본적으로 this에는 전역 객체(global object)가 바인딩된다.",{"type":17,"tag":18,"props":53,"children":54},{},[55],{"type":22,"value":56},"전역 함수는 물론이고 중첩 함수를 일반 함수로 호출하면 함수 내부의 this에는 전역 객체가 바인딩된다.",{"type":17,"tag":58,"props":59,"children":63},"pre",{"className":60,"code":62,"language":11,"meta":7},[61],"language-javascript","function foo() {\n    console.log(\"foo's this: \", this); // window\n    function bar() {\n        console.log(\"bar's this: \", this); // window\n    }\n    bar();\n}\nfoo();\n",[64],{"type":17,"tag":65,"props":66,"children":67},"code",{"__ignoreMap":7},[68],{"type":22,"value":62},{"type":17,"tag":18,"props":70,"children":71},{},[72],{"type":22,"value":73},"\\n",{"type":17,"tag":18,"props":75,"children":76},{},[77],{"type":22,"value":78},"메서드(객체 안에 함수) 내에서 정의한 중첩 함수도 일반 함수로 호출되면 중첩 함수 내부의 this에는 전역 객체가 바인딩된다.",{"type":17,"tag":58,"props":80,"children":83},{"className":81,"code":82,"language":11,"meta":7},[61],"var value = 1;\n\nconst obj = {\n    value: 100,\n    foo() {\n        console.log(this); // {value: 100, foo: f}\n        consoel.log(this.value); // 100\n\n        function bar() {\n            console.log(this); // window\n            console.log(this.value); // 1\n        }\n        bar();\n    }\n}\n",[84],{"type":17,"tag":65,"props":85,"children":86},{"__ignoreMap":7},[87],{"type":22,"value":82},{"type":17,"tag":18,"props":89,"children":90},{},[91],{"type":22,"value":73},{"type":17,"tag":18,"props":93,"children":94},{},[95],{"type":22,"value":96},"콜백 함수가 일반 함수로 호출된다면 콜백 함수 내부의 this에도 전역 객체가 바인딩된다. 어떠한 함수라도 일반 함수로 호출되면 this에 전역 객체가 바인딩된다.",{"type":17,"tag":58,"props":98,"children":101},{"className":99,"code":100,"language":11,"meta":7},[61],"var value = 1;\n\nconst obj = {\n    value: 100,\n    foo() {\n        console.log(this); // {value: 100, foo: f}\n        setTimeout(function() {\n            console.log(this.value); // 1\n        })\n    }\n}\n",[102],{"type":17,"tag":65,"props":103,"children":104},{"__ignoreMap":7},[105],{"type":22,"value":100},{"type":17,"tag":18,"props":107,"children":108},{},[109],{"type":22,"value":73},{"type":17,"tag":18,"props":111,"children":112},{},[113],{"type":22,"value":114},"메서드 내부의 중첩 함수나 콜백 함수의 this 바인딩을 메서드의 this 바인딩과 일치시키기 위한 방법",{"type":17,"tag":116,"props":117,"children":118},"ol",{},[119,134,148],{"type":17,"tag":120,"props":121,"children":122},"li",{},[123,125],{"type":22,"value":124},"this를 변수에 할당",{"type":17,"tag":58,"props":126,"children":129},{"className":127,"code":128,"language":11,"meta":7},[61],"var value = 1;\n\nconst obj = {\n    value: 100,\n    foo() {\n        var that = this;\n        setTimeout(function() {\n            console.log(that.value); // 100\n        })\n    }\n}\n",[130],{"type":17,"tag":65,"props":131,"children":132},{"__ignoreMap":7},[133],{"type":22,"value":128},{"type":17,"tag":120,"props":135,"children":136},{},[137,139],{"type":22,"value":138},"apply, call, bind",{"type":17,"tag":58,"props":140,"children":143},{"className":141,"code":142,"language":11,"meta":7},[61],"var value = 1;\n\nconst obj = {\n    value: 100,\n    foo() {\n        setTimeout(function() {\n            console.log(this.value); // 100\n        }.bind(this))\n    }\n}\n",[144],{"type":17,"tag":65,"props":145,"children":146},{"__ignoreMap":7},[147],{"type":22,"value":142},{"type":17,"tag":120,"props":149,"children":150},{},[151,153],{"type":22,"value":152},"화살표 함수",{"type":17,"tag":58,"props":154,"children":157},{"className":155,"code":156,"language":11,"meta":7},[61],"var value = 1;\n\nconst obj = {\n    value: 100,\n    foo() {\n        setTimeout(() => {\n            console.log(this.value); // 100\n        })\n    }\n}\n",[158],{"type":17,"tag":65,"props":159,"children":160},{"__ignoreMap":7},[161],{"type":22,"value":156},{"type":17,"tag":41,"props":163,"children":165},{"id":164},"메서드-호출",[166],{"type":22,"value":167},"메서드 호출",{"type":17,"tag":18,"props":169,"children":170},{},[171],{"type":22,"value":172},"메서드 내부의 this에는 메서드를 호출한 객체, 즉 메서드를 호출할 때 메서드 이름 앞의 마침표(.) 연산자 앞에 기술한 객체가 바인딩된다. 주의할 것은 메서드 내부의 this는 메서드를 소유한 객체가 아닌 메서드를 호출한 객체에 바인딩된다는 것이다.",{"type":17,"tag":58,"props":174,"children":177},{"className":175,"code":176,"language":11,"meta":7},[61],"const person = {\n    name: 'Lee',\n    getName() {\n        return this.name;\n    }\n}\nconsole.log(person.getName());\n",[178],{"type":17,"tag":65,"props":179,"children":180},{"__ignoreMap":7},[181],{"type":22,"value":176},{"type":17,"tag":18,"props":183,"children":184},{},[185],{"type":22,"value":186},"오해하면 안되는게 getName의 함수 객체는 person의 포함된게 아니라 독립적으로 존재하는 별도의 객체(메모리에 별도로)다. getName 프로퍼티가 함수 객체를 가리키고 있을 뿐이다.",{"type":17,"tag":188,"props":189,"children":191},"img",{"src":190},"/blog/images/4d07cbfb-5696-49de-baab-938cabed5271.png",[],{"type":17,"tag":18,"props":193,"children":194},{},[195],{"type":22,"value":73},{"type":17,"tag":18,"props":197,"children":198},{},[199],{"type":22,"value":200},"따라서 getName 프로퍼티가 가리키는 함수 객체, 즉 getName 메서드는 다른 객체의 프로퍼티에 할당하는 것으로 다른 객체의 메서드가 될 수도 있고 일반 변수에 할당하여 일반 함수로 호출될 수도 있다.",{"type":17,"tag":58,"props":202,"children":205},{"className":203,"code":204,"language":11,"meta":7},[61],"const person = {\n  name: 'Lee',\n  getName() {\n    return this.name;\n  }\n}\nconst annotherPerson = {\n  name: 'kim'\n}\nannotherPerson.getName = person.getName;\nconsole.log(annotherPerson.getName()); // kim\n\nlet getName = person.getName;\nconsole.log(getName()); // ''\n",[206],{"type":17,"tag":65,"props":207,"children":208},{"__ignoreMap":7},[209],{"type":22,"value":204},{"type":17,"tag":18,"props":211,"children":212},{},[213],{"type":22,"value":73},{"type":17,"tag":18,"props":215,"children":216},{},[217],{"type":22,"value":218},"프로토타입 메서드 내부에서 사용된 this도 일반 메서드와 마찬가지로 해당 메서드를 호출한 객체에 바인딩된다.",{"type":17,"tag":58,"props":220,"children":223},{"className":221,"code":222,"language":11,"meta":7},[61],"function Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.getName = funciton() {\n    return this.name;\n};\n\nconst me = new Person('Lee');\n\nconsole.log(me.getName()); // Lee\n\nPerson.prototype.name = \"kim\";\nconsole.log(person.prototype.getName()); // kim\n",[224],{"type":17,"tag":65,"props":225,"children":226},{"__ignoreMap":7},[227],{"type":22,"value":222},{"type":17,"tag":18,"props":229,"children":230},{},[231],{"type":22,"value":73},{"type":17,"tag":41,"props":233,"children":235},{"id":234},"생성자-함수-호출",[236],{"type":22,"value":237},"생성자 함수 호출",{"type":17,"tag":18,"props":239,"children":240},{},[241],{"type":22,"value":242},"생성자 함수 내부의 this에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩된다.",{"type":17,"tag":58,"props":244,"children":247},{"className":245,"code":246,"language":11,"meta":7},[61],"function Circle(radius) {\n    this.radius = radius;\n    this.getDiameter = function() {\n        return 2 * this.radius;\n    }\n}\n\nconst circle1 = new Circle(5);\n\n// 만약 new 연산자와 함께 호출하지 않으면 생성자 함수로 동작하지 않는다. 일반적인 함수의 호출이다.\nconst circle2 = Circle(15); // 이때 this는 window이므로 window.radius = 15가 된다.\nconsole.log(radius); // 15\n",[248],{"type":17,"tag":65,"props":249,"children":250},{"__ignoreMap":7},[251],{"type":22,"value":246},{"type":17,"tag":41,"props":253,"children":255},{"id":254},"funcitonprototypeapplycallbind-메서드에-의한-간접-호출",[256],{"type":22,"value":257},"Funciton.prototype.apply/call/bind 메서드에 의한 간접 호출",{"type":17,"tag":58,"props":259,"children":262},{"className":260,"code":261,"language":11,"meta":7},[61],"function getThisBinding() {\n    return this;\n}\nconst thisArg = { a: 1 };\n\nconsole.log(getThisBinding()); // window\n\nconsole.log(getThisBinding.call(thisArg)); // {a: 1};\nconsole.log(getThisBinding.apply(thisArg)); // {a: 1};\n",[263],{"type":17,"tag":65,"props":264,"children":265},{"__ignoreMap":7},[266],{"type":22,"value":261},{"type":17,"tag":18,"props":268,"children":269},{},[270],{"type":22,"value":73},{"type":17,"tag":18,"props":272,"children":273},{},[274],{"type":22,"value":275},"apply와 call 메서드의 본질적인 기능은 함수를 호출하는 것이다. apply와 call 메서드는 함수를 호출하면서 첫 번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩한다.",{"type":17,"tag":18,"props":277,"children":278},{},[279],{"type":22,"value":73},{"type":17,"tag":18,"props":281,"children":282},{},[283],{"type":22,"value":284},"apply와 call은 인수를 전달하는 방식만 다를뿐 동일하게 동작한다.",{"type":17,"tag":58,"props":286,"children":289},{"className":287,"code":288,"language":11,"meta":7},[61],"function getThisBinding() {\n    console.log(arguments);\n    return this;\n}\n\nconst thisArg = {a: 1};\n\nconsole.log(getThisBinding.apply(thisArg, [1, 2, 3]);\nconsole.log(getThisBinding.call(thisArg, 1, 2, 3);\n",[290],{"type":17,"tag":65,"props":291,"children":292},{"__ignoreMap":7},[293],{"type":22,"value":288},{"type":17,"tag":18,"props":295,"children":296},{},[297],{"type":22,"value":73},{"type":17,"tag":18,"props":299,"children":300},{},[301],{"type":22,"value":302},"대표적인 용도는 arguments 객체와 같은 유사 배열 객체에 배열 메서드를 사용하는 경우다. arguments 객체는 배열이 아니기 때문에 Array.prototype.slice 같은 배열의 메서드를 사용할 수 없으나 apply와 call 메서드를 이용하면 가능하다.",{"type":17,"tag":58,"props":304,"children":307},{"className":305,"code":306,"language":11,"meta":7},[61],"function convertArgsToArray() {\n    const arr = Array.prototype.slice.call(arguments);\n\n    return arr;\n}\n",[308],{"type":17,"tag":65,"props":309,"children":310},{"__ignoreMap":7},[311],{"type":22,"value":306},{"type":17,"tag":18,"props":313,"children":314},{},[315],{"type":22,"value":73},{"type":17,"tag":18,"props":317,"children":318},{},[319],{"type":22,"value":320},"bind 메서드는 apply와 call 메서드와 달리 함수를 호출하지 않고 this로 사용할 객체만 전달한다.",{"type":17,"tag":58,"props":322,"children":325},{"className":323,"code":324,"language":11,"meta":7},[61],"function getThisBinding() {\n    return this;\n}\n\nconst thisArg = {a:1};\n\nconsole.log(getThisBinding.bind(thisArg)); // getThisBinding\nconsole.log(getThisBidning.bind(thisArg)()); // {a:1}\n",[326],{"type":17,"tag":65,"props":327,"children":328},{"__ignoreMap":7},[329],{"type":22,"value":324},{"type":17,"tag":18,"props":331,"children":332},{},[333],{"type":22,"value":334},"bind 메서드는 메서드의 this와 메서드 내부의 중첩 함수 또는 콜백 함수의 this가 불일치하는 문제를 해결하기 위해 유용하게 사용된다.",{"type":17,"tag":58,"props":336,"children":339},{"className":337,"code":338,"language":11,"meta":7},[61],"const person = {\n    name: 'Lee',\n    foo(callback) {\n        setTimeout(callback, 100);\n    }\n}\nperson.foo(function () {\n    console.log(this); // window\n})\n",[340],{"type":17,"tag":65,"props":341,"children":342},{"__ignoreMap":7},[343],{"type":22,"value":338},{"type":17,"tag":58,"props":345,"children":348},{"className":346,"code":347,"language":11,"meta":7},[61],"const person = {\n    name: 'Lee',\n    foo(callback) {\n        // callback 함수의 this는 여기 this야\n        // bind는 apply와 call과 달리 호출을 하지 않기 때문에 가능\n        setTimeout(callback.bind(this), 100);\n    }\n}\nperson.foo(function () {\n    console.log(this); // {name: 'Lee', foo: f}\n})\n",[349],{"type":17,"tag":65,"props":350,"children":351},{"__ignoreMap":7},[352],{"type":22,"value":347},{"title":7,"searchDepth":354,"depth":354,"links":355},2,[356,357,358,359],{"id":43,"depth":354,"text":46},{"id":164,"depth":354,"text":167},{"id":234,"depth":354,"text":237},{"id":254,"depth":354,"text":257},"markdown","content:posts:62b25952-eab1-4faf-b3ec-9b0928301bb6.md","content","posts/62b25952-eab1-4faf-b3ec-9b0928301bb6.md","md",1710325141886]