[{"data":1,"prerenderedAt":225},["Reactive",2],{"content-query-qQX0I8H0qo":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"tags":10,"date":12,"body":13,"_type":220,"_id":221,"_source":222,"_file":223,"_extension":224},"/posts/395ca83a-7b04-4f59-962a-1bc8cc05d1aa","posts",false,"","자바스크립트 - 15. 함수와 일급 객체","일급 객체 조건",[11],"javascript","2024-02-22T00:00:00.000Z",{"type":14,"children":15,"toc":207},"root",[16,23,48,53,65,69,74,78,85,90,97,102,111,117,122,128,133,139,144,149,155,160,166,171,176,181,185,189,194],{"type":17,"tag":18,"props":19,"children":20},"element","p",{},[21],{"type":22,"value":9},"text",{"type":17,"tag":24,"props":25,"children":26},"ol",{},[27,33,38,43],{"type":17,"tag":28,"props":29,"children":30},"li",{},[31],{"type":22,"value":32},"무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.",{"type":17,"tag":28,"props":34,"children":35},{},[36],{"type":22,"value":37},"변수나 자료구조(객체, 배열 등)에 저장할 수 있다.",{"type":17,"tag":28,"props":39,"children":40},{},[41],{"type":22,"value":42},"함수의 매개변수에 전달할 수 있다.",{"type":17,"tag":28,"props":44,"children":45},{},[46],{"type":22,"value":47},"함수의 반환값으로 사용할 수 있다.",{"type":17,"tag":18,"props":49,"children":50},{},[51],{"type":22,"value":52},"\\n",{"type":17,"tag":54,"props":55,"children":59},"pre",{"className":56,"code":58,"language":11,"meta":7},[57],"language-javascript","// 1. 함수는 무명의 리터럴로 생성할 수 있다.\n// 2. 함수는 변수에 저장할 수 있다.\n// 런타임(할당 단계)에 함수 리터럴이 평가되어 함수 객체가 생성되고 변수에 할당된다.\nconst increase = function (num) {\n    return ++num;\n}\n\nconst decrease = function (num) {\n    return --num;\n}\n\n// 2. 함수는 객체에 저장할 수 있다.\nconst predicates = {increase, decrease};\n\n// 3. 함수의 매개변수에 전달할 수 있다.\n// 4. 함수의 반환값으로 사용할 수 있다.\nfunction makeCount(predicate) {\n    let num = 0;\n    return funtion () {\n        num = predicate(num);\n        return num;\n    }\n}\n\n// 3. 함수는 매개변수에게 함수를 전달할 수 있따.\nconst increaser = makeCounter(predicates.increase);\nincreaser();\nincreaser();\n",[60],{"type":17,"tag":61,"props":62,"children":63},"code",{"__ignoreMap":7},[64],{"type":22,"value":58},{"type":17,"tag":18,"props":66,"children":67},{},[68],{"type":22,"value":52},{"type":17,"tag":18,"props":70,"children":71},{},[72],{"type":22,"value":73},"함수가 일급 객체라는 것은 함수를 객체와 동일하게 사용할 수 있다는 의미다. 객체는 값이므로 함수는 값과 동일하게 취급할 수 있다. 따라서 함수는 값을 사용할 수 있는 곳이라면 어디서든지 리터럴로 정의할 수 있으며 런타임에 함수 객체로 평가된다.",{"type":17,"tag":18,"props":75,"children":76},{},[77],{"type":22,"value":52},{"type":17,"tag":79,"props":80,"children":82},"h2",{"id":81},"함수-객체의-프로퍼티",[83],{"type":22,"value":84},"함수 객체의 프로퍼티",{"type":17,"tag":18,"props":86,"children":87},{},[88],{"type":22,"value":89},"함수는 객체다. 따라서 함수도 프로퍼티를 가질 수 있다.",{"type":17,"tag":91,"props":92,"children":94},"h3",{"id":93},"arguments-프로퍼티",[95],{"type":22,"value":96},"arguments 프로퍼티",{"type":17,"tag":18,"props":98,"children":99},{},[100],{"type":22,"value":101},"매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용",{"type":17,"tag":54,"props":103,"children":106},{"className":104,"code":105,"language":11,"meta":7},[57],"function sum() {\n    const array = Array.prototype.slice.call(arguments);\n    ...\n}\n\nsum(1,2);\nsum(1,2,3);\n\n// ES6에 rest 파라미터 사용하면 됨\nfunction sum(...args) {\n    return args.reduce...\n}\n",[107],{"type":17,"tag":61,"props":108,"children":109},{"__ignoreMap":7},[110],{"type":22,"value":105},{"type":17,"tag":91,"props":112,"children":114},{"id":113},"caller-프로퍼티",[115],{"type":22,"value":116},"caller 프로퍼티",{"type":17,"tag":18,"props":118,"children":119},{},[120],{"type":22,"value":121},"비표준 프로퍼티. 알 필요 없음",{"type":17,"tag":91,"props":123,"children":125},{"id":124},"length-프로퍼티",[126],{"type":22,"value":127},"length 프로퍼티",{"type":17,"tag":18,"props":129,"children":130},{},[131],{"type":22,"value":132},"매개변수 개수",{"type":17,"tag":91,"props":134,"children":136},{"id":135},"name-프로퍼티",[137],{"type":22,"value":138},"name 프로퍼티",{"type":17,"tag":18,"props":140,"children":141},{},[142],{"type":22,"value":143},"함수 이름",{"type":17,"tag":18,"props":145,"children":146},{},[147],{"type":22,"value":148},"ES6이전까지는 비표준 ES6에서 정식 표준",{"type":17,"tag":91,"props":150,"children":152},{"id":151},"__proto__접근자-프로퍼티",[153],{"type":22,"value":154},"__proto__접근자 프로퍼티",{"type":17,"tag":18,"props":156,"children":157},{},[158],{"type":22,"value":159},"[[Prototype]]이라는 내부 슬롯에 간접적으로 접근하기 위한 프로퍼티",{"type":17,"tag":91,"props":161,"children":163},{"id":162},"prototype-프로퍼티",[164],{"type":22,"value":165},"prototype 프로퍼티",{"type":17,"tag":18,"props":167,"children":168},{},[169],{"type":22,"value":170},"생성자 함수로 호출할 수 있는 함수 객체, 즉 constructor만이 소유하는 프로퍼티",{"type":17,"tag":18,"props":172,"children":173},{},[174],{"type":22,"value":175},"일반 객체와 생성자 함수로 호출할 수 없는 non-constructor에는 prototype 프로퍼티가 없다.",{"type":17,"tag":18,"props":177,"children":178},{},[179],{"type":22,"value":180},"(이전 14. 생성자 함수에 의한 객체 생성 참고)",{"type":17,"tag":18,"props":182,"children":183},{},[184],{"type":22,"value":52},{"type":17,"tag":186,"props":187,"children":188},"hr",{},[],{"type":17,"tag":79,"props":190,"children":192},{"id":191},"참고",[193],{"type":22,"value":191},{"type":17,"tag":195,"props":196,"children":197},"ul",{},[198],{"type":17,"tag":28,"props":199,"children":200},{},[201],{"type":17,"tag":202,"props":203,"children":204},"strong",{},[205],{"type":22,"value":206},"이웅모, 「모던 자바스크립트 Deep Dive」, 위키북스, 2020",{"title":7,"searchDepth":208,"depth":208,"links":209},2,[210,219],{"id":81,"depth":208,"text":84,"children":211},[212,214,215,216,217,218],{"id":93,"depth":213,"text":96},3,{"id":113,"depth":213,"text":116},{"id":124,"depth":213,"text":127},{"id":135,"depth":213,"text":138},{"id":151,"depth":213,"text":154},{"id":162,"depth":213,"text":165},{"id":191,"depth":208,"text":191},"markdown","content:posts:395ca83a-7b04-4f59-962a-1bc8cc05d1aa.md","content","posts/395ca83a-7b04-4f59-962a-1bc8cc05d1aa.md","md",1719041868614]