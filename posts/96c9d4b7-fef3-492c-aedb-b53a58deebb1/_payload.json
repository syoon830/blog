[{"data":1,"prerenderedAt":803},["Reactive",2],{"content-query-FwZEDdYpkf":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"tags":10,"date":12,"body":13,"_type":798,"_id":799,"_source":800,"_file":801,"_extension":802},"/posts/96c9d4b7-fef3-492c-aedb-b53a58deebb1","posts",false,"","자바스크립트 - 9. 함수","\\n",[11],"javascript","2024-02-16T00:00:00.000Z",{"type":14,"children":15,"toc":781},"root",[16,23,30,35,47,52,67,72,77,81,86,91,95,108,112,119,127,133,146,155,159,169,174,183,188,192,211,222,226,231,245,249,254,263,274,283,287,292,297,306,310,318,322,331,336,349,358,362,374,378,390,394,400,409,413,418,423,427,435,444,450,459,464,469,474,478,483,501,505,510,514,519,548,552,557,561,568,577,581,586,590,603,615,619,625,631,640,646,651,656,661,666,685,690,695,700,705,714,723,729,734,739,748,757,761,765,770],{"type":17,"tag":18,"props":19,"children":20},"element","p",{},[21],{"type":22,"value":9},"text",{"type":17,"tag":24,"props":25,"children":27},"h2",{"id":26},"함수-리터럴",[28],{"type":22,"value":29},"함수 리터럴",{"type":17,"tag":18,"props":31,"children":32},{},[33],{"type":22,"value":34},"함수 리터럴은 function 키워드, 함수 이름, 매개 변수 목록, 함수 몸체로 구성된다.",{"type":17,"tag":36,"props":37,"children":41},"pre",{"className":38,"code":40,"language":11,"meta":7},[39],"language-javascript","var f = function add(x, y) {\n    return x + y;\n}\n",[42],{"type":17,"tag":43,"props":44,"children":45},"code",{"__ignoreMap":7},[46],{"type":22,"value":40},{"type":17,"tag":18,"props":48,"children":49},{},[50],{"type":22,"value":51},"함수이름: add",{"type":17,"tag":53,"props":54,"children":55},"ul",{},[56,62],{"type":17,"tag":57,"props":58,"children":59},"li",{},[60],{"type":22,"value":61},"함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자 (중요!)",{"type":17,"tag":57,"props":63,"children":64},{},[65],{"type":22,"value":66},"함수 이름은 생략할 수 있다. 이름이 있는 함수를 기명 함수, 이름이 없는 함수를 무명/익명 함수라 한다.",{"type":17,"tag":18,"props":68,"children":69},{},[70],{"type":22,"value":71},"매개변수: x, y",{"type":17,"tag":18,"props":73,"children":74},{},[75],{"type":22,"value":76},"몸체: return x + y;",{"type":17,"tag":18,"props":78,"children":79},{},[80],{"type":22,"value":9},{"type":17,"tag":18,"props":82,"children":83},{},[84],{"type":22,"value":85},"리터럴: 사람이 이해할 수 있는 문자나 약속된 기호를 사용해 값을 생성하는 표기 방식, 즉 리터럴은 값을 생성하기 위한 표기법 (용어 계속 숙지)",{"type":17,"tag":18,"props":87,"children":88},{},[89],{"type":22,"value":90},"함수 리터럴도 평가되어 값을 생성하며, 이 값은 객체다.",{"type":17,"tag":18,"props":92,"children":93},{},[94],{"type":22,"value":9},{"type":17,"tag":18,"props":96,"children":97},{},[98,100,106],{"type":22,"value":99},"즉, ",{"type":17,"tag":101,"props":102,"children":103},"strong",{},[104],{"type":22,"value":105},"함수는 객체다!",{"type":22,"value":107}," (다른 프로그래밍 언어와 구별되는 자바스크립트의 중요한 특징)",{"type":17,"tag":18,"props":109,"children":110},{},[111],{"type":22,"value":9},{"type":17,"tag":113,"props":114,"children":116},"h1",{"id":115},"함수-정의",[117],{"type":22,"value":118},"함수 정의",{"type":17,"tag":120,"props":121,"children":124},"aside",{"emogi":122,"color":123},"✏️","purple",[125],{"type":22,"value":126},"변수 선언과 함수 정의\n변수는 선언(declaration)한다고 했지만 함수는 정의(definition)한다고 표현했다.\n함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다.\n따라서 ECMAScript 사양에서도 변수에는 선언(variable declration), 함수에는 정의(function definition)라고 표현한다.",{"type":17,"tag":24,"props":128,"children":130},{"id":129},"함수-선언문-표현식이-아닌-문",[131],{"type":22,"value":132},"함수 선언문 (표현식이 아닌 문)",{"type":17,"tag":53,"props":134,"children":135},{},[136,141],{"type":17,"tag":57,"props":137,"children":138},{},[139],{"type":22,"value":140},"함수 선언문은 함수리터럴과 형태가 동일하다.",{"type":17,"tag":57,"props":142,"children":143},{},[144],{"type":22,"value":145},"단, 함수 선언문은 함수 이름 생략 불가",{"type":17,"tag":36,"props":147,"children":150},{"className":148,"code":149,"language":11,"meta":7},[39],"// 함수 선언문\nfunction add(x, y) {\n    return x + y;\n}\n",[151],{"type":17,"tag":43,"props":152,"children":153},{"__ignoreMap":7},[154],{"type":22,"value":149},{"type":17,"tag":18,"props":156,"children":157},{},[158],{"type":22,"value":9},{"type":17,"tag":18,"props":160,"children":161},{},[162,164],{"type":22,"value":163},"함수 선언문은 ",{"type":17,"tag":101,"props":165,"children":166},{},[167],{"type":22,"value":168},"표현식이 아닌 문",{"type":17,"tag":18,"props":170,"children":171},{},[172],{"type":22,"value":173},"표현식이 아닌 문은 변수에 할당할 수 없다고 했는데",{"type":17,"tag":36,"props":175,"children":178},{"className":176,"code":177,"language":11,"meta":7},[39],"var add = function add(x, y) {\n    return x + y;\n}\n",[179],{"type":17,"tag":43,"props":180,"children":181},{"__ignoreMap":7},[182],{"type":22,"value":177},{"type":17,"tag":18,"props":184,"children":185},{},[186],{"type":22,"value":187},"하지만 위 코드를 보면 함수 선언문이 변수에 할당되는 것처럼 보인다.",{"type":17,"tag":18,"props":189,"children":190},{},[191],{"type":22,"value":9},{"type":17,"tag":18,"props":193,"children":194},{},[195,197,202,204,209],{"type":22,"value":196},"이는 자바스크립트 엔진이 코드의 문맥에 따라 ",{"type":17,"tag":43,"props":198,"children":199},{},[200],{"type":22,"value":201},"함수 선언문",{"type":22,"value":203},"으로 해석하거나 ",{"type":17,"tag":43,"props":205,"children":206},{},[207],{"type":22,"value":208},"함수 리터럴 표현식",{"type":22,"value":210},"으로 해석하는 경우가 있기 때문. 코드 문맥에 따라 해석이 달라짐",{"type":17,"tag":18,"props":212,"children":213},{},[214,216,220],{"type":22,"value":215},"위와 같은 경우는 표현식인 문인 ",{"type":17,"tag":43,"props":217,"children":218},{},[219],{"type":22,"value":208},{"type":22,"value":221},"으로 해석 되었기 때문에 가능",{"type":17,"tag":18,"props":223,"children":224},{},[225],{"type":22,"value":9},{"type":17,"tag":18,"props":227,"children":228},{},[229],{"type":22,"value":230},"기명 함수 리터럴은 중의적인 코드다.",{"type":17,"tag":232,"props":233,"children":234},"ol",{},[235,240],{"type":17,"tag":57,"props":236,"children":237},{},[238],{"type":22,"value":239},"단독으로 사용하면 함수 선언문으로 해석",{"type":17,"tag":57,"props":241,"children":242},{},[243],{"type":22,"value":244},"값으로 평가되어야 하는 문맥 (할당, 피연산자)에서는 함수 리터럴 표현식으로 해석",{"type":17,"tag":18,"props":246,"children":247},{},[248],{"type":22,"value":9},{"type":17,"tag":18,"props":250,"children":251},{},[252],{"type":22,"value":253},"아래 코드를 보자",{"type":17,"tag":36,"props":255,"children":258},{"className":256,"code":257,"language":11,"meta":7},[39],"**//** 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석\nfunction foo() {\n    console.log('foo');\n}\n\nfoo(); // foo\n\n// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석\n// 그룹연산자()안에 피연산자 함수 리터럴은 함수 리터럴 표현식으로 해석\n(function bar() { console.log('bar')});\nbar(); // RefefenceError: bar is not defined\n",[259],{"type":17,"tag":43,"props":260,"children":261},{"__ignoreMap":7},[262],{"type":22,"value":257},{"type":17,"tag":18,"props":264,"children":265},{},[266,268,272],{"type":22,"value":267},"bar()를 왜 호출을 못할까? 그 이유는 ",{"type":17,"tag":43,"props":269,"children":270},{},[271],{"type":22,"value":208},{"type":22,"value":273},"으로 해석되기 때문이다. 위 함수 리터럴에서 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자라고 했다. 그래서 함수 내부가 아닌 외부에서는 호출이 불가능한 것이다.",{"type":17,"tag":275,"props":276,"children":277},"blockquote",{},[278],{"type":17,"tag":18,"props":279,"children":280},{},[281],{"type":22,"value":282},"함수 리터럴과 함수 리터럴 표현식 헷갈리지 말기",{"type":17,"tag":18,"props":284,"children":285},{},[286],{"type":22,"value":9},{"type":17,"tag":18,"props":288,"children":289},{},[290],{"type":22,"value":291},"위 예제에서 함수 선언문으로 정의된 함수는 foo라는 이름으로 호출할 수 있었다. foo는 함수 몸체 내부에서만 유효한 식별자인데 그러면 foo()는 어떻게 호출이 가능한걸까? 그 이유는 자바스크립트 엔진이 암묵적으로 식별자를 생성하기 때문이다.",{"type":17,"tag":18,"props":293,"children":294},{},[295],{"type":22,"value":296},"즉 자바스크립트 엔진은 함수 선언문을 해석해 함수 객체를 생성한다.",{"type":17,"tag":36,"props":298,"children":301},{"className":299,"code":300,"language":11,"meta":7},[39],"function foo() {\n    console.log('foo');\n}\n\n// 자바스크립트 엔진이 암묵적으로 아래와 같이 생성한다. (아래와 같이 동작하는건 알수 없으나 식별자가 생성된다는 것을 보여주기 위한 예제)\nvar foo = function foo() {\n    console.log('foo');\n}\n\n// 그래서 함수 표현식은 함수 이름 생략이 불가능하구나?\n",[302],{"type":17,"tag":43,"props":303,"children":304},{"__ignoreMap":7},[305],{"type":22,"value":300},{"type":17,"tag":18,"props":307,"children":308},{},[309],{"type":22,"value":9},{"type":17,"tag":18,"props":311,"children":312},{},[313],{"type":17,"tag":101,"props":314,"children":315},{},[316],{"type":22,"value":317},"함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다!",{"type":17,"tag":18,"props":319,"children":320},{},[321],{"type":22,"value":9},{"type":17,"tag":36,"props":323,"children":326},{"className":324,"code":325,"language":11,"meta":7},[39],"var foo = function bar(n) {\n    bar(); // 함수이름은 함수 몸체 내에서만 사용 가능\n}\n",[327],{"type":17,"tag":43,"props":328,"children":329},{"__ignoreMap":7},[330],{"type":22,"value":325},{"type":17,"tag":18,"props":332,"children":333},{},[334],{"type":22,"value":335},"용어 구분",{"type":17,"tag":53,"props":337,"children":338},{},[339,344],{"type":17,"tag":57,"props":340,"children":341},{},[342],{"type":22,"value":343},"식별자: foo",{"type":17,"tag":57,"props":345,"children":346},{},[347],{"type":22,"value":348},"함수이름 bar",{"type":17,"tag":36,"props":350,"children":353},{"className":351,"code":352,"language":11,"meta":7},[39],"var foo = function () {}\n",[354],{"type":17,"tag":43,"props":355,"children":356},{"__ignoreMap":7},[357],{"type":22,"value":352},{"type":17,"tag":18,"props":359,"children":360},{},[361],{"type":22,"value":335},{"type":17,"tag":53,"props":363,"children":364},{},[365,369],{"type":17,"tag":57,"props":366,"children":367},{},[368],{"type":22,"value":343},{"type":17,"tag":57,"props":370,"children":371},{},[372],{"type":22,"value":373},"함수이름: 없음 (익명함수)",{"type":17,"tag":18,"props":375,"children":376},{},[377],{"type":22,"value":9},{"type":17,"tag":18,"props":379,"children":380},{},[381],{"type":17,"tag":382,"props":383,"children":387},"a",{"href":384,"rel":385},"https://chat.openai.com/share/512948d1-1316-4bba-afaf-42e41498d5c8",[386],"nofollow",[388],{"type":22,"value":389},"bookmark",{"type":17,"tag":18,"props":391,"children":392},{},[393],{"type":22,"value":9},{"type":17,"tag":24,"props":395,"children":397},{"id":396},"함수-표현식표현식인-문",[398],{"type":22,"value":399},"함수 표현식(표현식인 문)",{"type":17,"tag":36,"props":401,"children":404},{"className":402,"code":403,"language":11,"meta":7},[39],"var add = function(x, y) {\n    return x + y;\n}\n",[405],{"type":17,"tag":43,"props":406,"children":407},{"__ignoreMap":7},[408],{"type":22,"value":403},{"type":17,"tag":18,"props":410,"children":411},{},[412],{"type":22,"value":9},{"type":17,"tag":18,"props":414,"children":415},{},[416],{"type":22,"value":417},"자바스크립트는 함수는 일급 객체다.",{"type":17,"tag":18,"props":419,"children":420},{},[421],{"type":22,"value":422},"함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이러한 함수 정의 방식을 함수 표현식(function expression)이라 한다.",{"type":17,"tag":18,"props":424,"children":425},{},[426],{"type":22,"value":9},{"type":17,"tag":275,"props":428,"children":429},{},[430],{"type":17,"tag":18,"props":431,"children":432},{},[433],{"type":22,"value":434},"함수 선언문, 함수 표현식으로 선언한 함수는 Function 객체의 인스턴스다, Function은 Object 객체의 인스턴스다.",{"type":17,"tag":36,"props":436,"children":439},{"className":437,"code":438,"language":11,"meta":7},[39],"function testFunction() {\n}\nlet testInstance = new testFunction();\nconsole.log(testInstance instanceof testFunction);\nconsole.log(testFunction instanceof Function);\nconsole.log(Function instanceof Object);\n",[440],{"type":17,"tag":43,"props":441,"children":442},{"__ignoreMap":7},[443],{"type":22,"value":438},{"type":17,"tag":24,"props":445,"children":447},{"id":446},"함수-생성-시점과-함수-호이스팅",[448],{"type":22,"value":449},"함수 생성 시점과 함수 호이스팅",{"type":17,"tag":36,"props":451,"children":454},{"className":452,"code":453,"language":11,"meta":7},[39],"// 함수 참조\nconsole.log(add); // f add(a, b)\nconsole.log(sub); // undefined\n\n// 함수 호출\nconsole.log(add(2, 5)); // 7\nconsole.log(sub(2, 5)); // TypeError: sub is not a function\n\n// 함수 선언문\nfunction add(a, b) {\n    return a + b;\n}\n\n// 함수 표현식\nvar sub = function(a, b) {\n    return a - b;\n}\n\n",[455],{"type":17,"tag":43,"props":456,"children":457},{"__ignoreMap":7},[458],{"type":22,"value":453},{"type":17,"tag":18,"props":460,"children":461},{},[462],{"type":22,"value":463},"함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다.",{"type":17,"tag":18,"props":465,"children":466},{},[467],{"type":22,"value":468},"함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다.",{"type":17,"tag":18,"props":470,"children":471},{},[472],{"type":22,"value":473},"이는 각 함수의 생성 시점이 다르기 때문이다.",{"type":17,"tag":18,"props":475,"children":476},{},[477],{"type":22,"value":9},{"type":17,"tag":18,"props":479,"children":480},{},[481],{"type":22,"value":482},"함수선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행된다.",{"type":17,"tag":232,"props":484,"children":485},{},[486,491,496],{"type":17,"tag":57,"props":487,"children":488},{},[489],{"type":22,"value":490},"함수 객체 생성",{"type":17,"tag":57,"props":492,"children":493},{},[494],{"type":22,"value":495},"함수 이름과 동일한 이름의 식별자 생성",{"type":17,"tag":57,"props":497,"children":498},{},[499],{"type":22,"value":500},"함수 객체를 식별자에 할당",{"type":17,"tag":18,"props":502,"children":503},{},[504],{"type":22,"value":9},{"type":17,"tag":18,"props":506,"children":507},{},[508],{"type":22,"value":509},"이처럼 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅이라 한다.",{"type":17,"tag":18,"props":511,"children":512},{},[513],{"type":22,"value":9},{"type":17,"tag":18,"props":515,"children":516},{},[517],{"type":22,"value":518},"함수 호이스팅과 변수 호이스팅 차이",{"type":17,"tag":232,"props":520,"children":521},{},[522,535],{"type":17,"tag":57,"props":523,"children":524},{},[525,527],{"type":22,"value":526},"변수 호이스팅은 undefined로 초기화\n",{"type":17,"tag":232,"props":528,"children":529},{},[530],{"type":17,"tag":57,"props":531,"children":532},{},[533],{"type":22,"value":534},"변수 호이스팅은 선언 이전에 호출하면 undefined로 평가 됨",{"type":17,"tag":57,"props":536,"children":537},{},[538,540],{"type":22,"value":539},"함수 호이스팅은 함수 객체로 초기화\n",{"type":17,"tag":232,"props":541,"children":542},{},[543],{"type":17,"tag":57,"props":544,"children":545},{},[546],{"type":22,"value":547},"함수 호이스팅은 함수 선언문 이전에 호출하면 호출이 가능",{"type":17,"tag":18,"props":549,"children":550},{},[551],{"type":22,"value":9},{"type":17,"tag":18,"props":553,"children":554},{},[555],{"type":22,"value":556},"함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.",{"type":17,"tag":18,"props":558,"children":559},{},[560],{"type":22,"value":9},{"type":17,"tag":562,"props":563,"children":565},"h3",{"id":564},"참조에-의한-전달과-외부-상태의-변경",[566],{"type":22,"value":567},"참조에 의한 전달과 외부 상태의 변경",{"type":17,"tag":36,"props":569,"children":572},{"className":570,"code":571,"language":11,"meta":7},[39],"function test(primitive, obj) {\n    primitive += 100;\n    obj.name = 'kim';\n}\n\nvar num = 100;\nvar person = {\n    name: 'lee';\n};\n\nconsole.log(num); // 100;\nconsole.log(person.name); // lee;\n\ntest(num, person);\n\nconsole.log(num); // 100\nconsole.log(person.name); // kim\n",[573],{"type":17,"tag":43,"props":574,"children":575},{"__ignoreMap":7},[576],{"type":22,"value":571},{"type":17,"tag":18,"props":578,"children":579},{},[580],{"type":22,"value":9},{"type":17,"tag":18,"props":582,"children":583},{},[584],{"type":22,"value":585},"함수 외부에서 함수 몸체 내부로 전달한 참조 값에 의해 원본 객체가 변경되는 부수 효과가 발생",{"type":17,"tag":18,"props":587,"children":588},{},[589],{"type":22,"value":9},{"type":17,"tag":53,"props":591,"children":592},{},[593,598],{"type":17,"tag":57,"props":594,"children":595},{},[596],{"type":22,"value":597},"객체의 변경을 추적하려면 옵저버 패턴 등을 통해 객체를 참조를 공유하는 모든 이들에게 변경 사실을 통지하고 이에 대처하는 추가 대응이 필요",{"type":17,"tag":57,"props":599,"children":600},{},[601],{"type":22,"value":602},"객체를 불변 객체로 만들어 사용하는것도 하나의 방법",{"type":17,"tag":18,"props":604,"children":605},{},[606,608,613],{"type":22,"value":607},"외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수를 ",{"type":17,"tag":43,"props":609,"children":610},{},[611],{"type":22,"value":612},"순수 함수",{"type":22,"value":614}," 라 한다.",{"type":17,"tag":18,"props":616,"children":617},{},[618],{"type":22,"value":9},{"type":17,"tag":24,"props":620,"children":622},{"id":621},"다양한-함수의-형태",[623],{"type":22,"value":624},"다양한 함수의 형태",{"type":17,"tag":562,"props":626,"children":628},{"id":627},"즉시-실행-함수",[629],{"type":22,"value":630},"즉시 실행 함수",{"type":17,"tag":36,"props":632,"children":635},{"className":633,"code":634,"language":11,"meta":7},[39],"(function() {}());\n// 그룹 연산자()로 함수를 묶은 이유는 먼저 함수 리터럴을 평가해서 함수 객체를 생성하기 위해서다.\n\n// 따라서 먼저 함수 리터럴을 평가해서 함수 객체를 생성할 수 있다면 그룹 연산자 이외의 연산자를 사용해도 좋다.\n(function(){})();\n!function(){}()\n+function(){}()\n",[636],{"type":17,"tag":43,"props":637,"children":638},{"__ignoreMap":7},[639],{"type":22,"value":634},{"type":17,"tag":562,"props":641,"children":643},{"id":642},"중첩-함수",[644],{"type":22,"value":645},"중첩 함수",{"type":17,"tag":18,"props":647,"children":648},{},[649],{"type":22,"value":650},"함수 내부에 정의된 함수를 중첩 함수 또는 내부 함수라 한다.",{"type":17,"tag":18,"props":652,"children":653},{},[654],{"type":22,"value":655},"중첩 함수를 포함하는 함수를 외부 함수라 부른다.",{"type":17,"tag":18,"props":657,"children":658},{},[659],{"type":22,"value":660},"일반적으로 중첩 함수는 자신을 포함하는 외부 함수를 돕는 헬퍼 함수의 역할을 한다.",{"type":17,"tag":562,"props":662,"children":664},{"id":663},"콜백함수",[665],{"type":22,"value":663},{"type":17,"tag":18,"props":667,"children":668},{},[669,671,676,678,683],{"type":22,"value":670},"함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 ",{"type":17,"tag":101,"props":672,"children":673},{},[674],{"type":22,"value":675},"콜백 함수",{"type":22,"value":677},"라고 하며, 매개 변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 ",{"type":17,"tag":101,"props":679,"children":680},{},[681],{"type":22,"value":682},"고차 함수",{"type":22,"value":684},"라고 한다.",{"type":17,"tag":18,"props":686,"children":687},{},[688],{"type":22,"value":689},"콜백함수도 고차 함수에 전달되어 헬퍼 함수의 역할을 한다.",{"type":17,"tag":18,"props":691,"children":692},{},[693],{"type":22,"value":694},"고차 함수는 콜백 함수를 자신의 일부분으로 합성한다.",{"type":17,"tag":18,"props":696,"children":697},{},[698],{"type":22,"value":699},"고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다.",{"type":17,"tag":18,"props":701,"children":702},{},[703],{"type":22,"value":704},"콜백 함수는 고차 함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.",{"type":17,"tag":36,"props":706,"children":709},{"className":707,"code":708,"language":11,"meta":7},[39],"// 고차함수\nfunction repeat(n, f) {\n    for (var i = 0; i \u003C n; i++) {\n        // 콜백 함수\n        f(i);\n    }\n}\n\nvar logAll = function(i) {\n    console.log(i);\n}\n",[710],{"type":17,"tag":43,"props":711,"children":712},{"__ignoreMap":7},[713],{"type":22,"value":708},{"type":17,"tag":36,"props":715,"children":718},{"className":716,"code":717,"language":11,"meta":7},[39],"// 고차 함수 map\n[1, 2, 3].map(function (item) {});\n",[719],{"type":17,"tag":43,"props":720,"children":721},{"__ignoreMap":7},[722],{"type":22,"value":717},{"type":17,"tag":562,"props":724,"children":726},{"id":725},"순수-함수와-비순수-함수",[727],{"type":22,"value":728},"순수 함수와 비순수 함수",{"type":17,"tag":18,"props":730,"children":731},{},[732],{"type":22,"value":733},"어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수 효과가 없는 함수를 순수 함수라 하고",{"type":17,"tag":18,"props":735,"children":736},{},[737],{"type":22,"value":738},"외부 상태에 의존하거나 외부 상태를 변경하는, 즉 부수 효과가 있는 함수를 비순수 함수라고 한다.",{"type":17,"tag":36,"props":740,"children":743},{"className":741,"code":742,"language":11,"meta":7},[39],"var count = 0;\n\n// 순수 함수 increase는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.\nfunction increase(n) {\n    return ++n;\n}\n// 순수 함수가 반환한 결과값을 변수에 재할당해서 상태를 변경\ncount = increase(count);\nconsole.log(count); // 1;\n",[744],{"type":17,"tag":43,"props":745,"children":746},{"__ignoreMap":7},[747],{"type":22,"value":742},{"type":17,"tag":36,"props":749,"children":752},{"className":750,"code":751,"language":11,"meta":7},[39],"var count = 0;\n\n// 비순수 함수\nfunction increase() {\n    return ++count; // 외부 상태에 의존하며 외부 상태를 변경한다.\n}\n\n// 비순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려워진다.\nincrease(count);\nconsole.log(count); // 1;\n",[753],{"type":17,"tag":43,"props":754,"children":755},{"__ignoreMap":7},[756],{"type":22,"value":751},{"type":17,"tag":18,"props":758,"children":759},{},[760],{"type":22,"value":9},{"type":17,"tag":762,"props":763,"children":764},"hr",{},[],{"type":17,"tag":24,"props":766,"children":768},{"id":767},"참고",[769],{"type":22,"value":767},{"type":17,"tag":53,"props":771,"children":772},{},[773],{"type":17,"tag":57,"props":774,"children":775},{},[776],{"type":17,"tag":101,"props":777,"children":778},{},[779],{"type":22,"value":780},"이웅모, 「모던 자바스크립트 Deep Dive」, 위키북스, 2020",{"title":7,"searchDepth":782,"depth":782,"links":783},2,[784,785,786,787,791,797],{"id":26,"depth":782,"text":29},{"id":129,"depth":782,"text":132},{"id":396,"depth":782,"text":399},{"id":446,"depth":782,"text":449,"children":788},[789],{"id":564,"depth":790,"text":567},3,{"id":621,"depth":782,"text":624,"children":792},[793,794,795,796],{"id":627,"depth":790,"text":630},{"id":642,"depth":790,"text":645},{"id":663,"depth":790,"text":663},{"id":725,"depth":790,"text":728},{"id":767,"depth":782,"text":767},"markdown","content:posts:96c9d4b7-fef3-492c-aedb-b53a58deebb1.md","content","posts/96c9d4b7-fef3-492c-aedb-b53a58deebb1.md","md",1719041868615]