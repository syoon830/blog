[{"data":1,"prerenderedAt":769},["Reactive",2],{"content-query-FwZEDdYpkf":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":7,"tags":9,"date":11,"body":12,"_type":764,"_id":765,"_source":766,"_file":767,"_extension":768},"/posts/96c9d4b7-fef3-492c-aedb-b53a58deebb1","posts",false,"","자바스크립트 - 9. 함수",[10],"javascript","2024-02-16T00:00:00.000Z",{"type":13,"children":14,"toc":748},"root",[15,24,30,42,47,70,75,80,85,90,95,99,111,115,122,130,136,149,158,162,172,177,186,191,195,216,228,232,237,251,255,260,269,281,290,294,299,304,313,317,325,329,338,343,356,365,369,381,385,397,401,407,416,420,425,430,434,440,449,454,459,464,468,473,491,495,500,504,509,538,542,547,551,558,567,571,576,580,593,606,610,616,622,631,637,642,647,652,657,676,681,686,691,696,705,714,720,725,730,739],{"type":16,"tag":17,"props":18,"children":20},"element","h2",{"id":19},"함수-리터럴",[21],{"type":22,"value":23},"text","함수 리터럴",{"type":16,"tag":25,"props":26,"children":27},"p",{},[28],{"type":22,"value":29},"함수 리터럴은 function 키워드, 함수 이름, 매개 변수 목록, 함수 몸체로 구성된다.",{"type":16,"tag":31,"props":32,"children":36},"pre",{"className":33,"code":35,"language":10,"meta":7},[34],"language-javascript","var f = function add(x, y) {\n    return x + y;\n}\n",[37],{"type":16,"tag":38,"props":39,"children":40},"code",{"__ignoreMap":7},[41],{"type":22,"value":35},{"type":16,"tag":25,"props":43,"children":44},{},[45],{"type":22,"value":46},"함수이름: add",{"type":16,"tag":48,"props":49,"children":50},"ul",{},[51,65],{"type":16,"tag":52,"props":53,"children":54},"li",{},[55,57,63],{"type":22,"value":56},"함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자 (",{"type":16,"tag":58,"props":59,"children":60},"strong",{},[61],{"type":22,"value":62},"중요",{"type":22,"value":64},"!)",{"type":16,"tag":52,"props":66,"children":67},{},[68],{"type":22,"value":69},"함수 이름은 생략할 수 있다. 이름이 있는 함수를 기명 함수, 이름이 없는 함수를 무명/익명 함수라 한다.",{"type":16,"tag":25,"props":71,"children":72},{},[73],{"type":22,"value":74},"매개변수: x, y",{"type":16,"tag":25,"props":76,"children":77},{},[78],{"type":22,"value":79},"몸체: return x + y;",{"type":16,"tag":25,"props":81,"children":82},{},[83],{"type":22,"value":84},"\\n",{"type":16,"tag":25,"props":86,"children":87},{},[88],{"type":22,"value":89},"리터럴: 사람이 이해할 수 있는 문자나 약속된 기호를 사용해 값을 생성하는 표기 방식, 즉 리터럴은 값을 생성하기 위한 표기법 (용어 계속 숙지)",{"type":16,"tag":25,"props":91,"children":92},{},[93],{"type":22,"value":94},"함수 리터럴도 평가되어 값을 생성하며, 이 값은 객체다.",{"type":16,"tag":25,"props":96,"children":97},{},[98],{"type":22,"value":84},{"type":16,"tag":25,"props":100,"children":101},{},[102,104,109],{"type":22,"value":103},"즉, ",{"type":16,"tag":58,"props":105,"children":106},{},[107],{"type":22,"value":108},"함수는 객체다!",{"type":22,"value":110}," (다른 프로그래밍 언어와 구별되는 자바스크립트의 중요한 특징)",{"type":16,"tag":25,"props":112,"children":113},{},[114],{"type":22,"value":84},{"type":16,"tag":116,"props":117,"children":119},"h1",{"id":118},"함수-정의",[120],{"type":22,"value":121},"함수 정의",{"type":16,"tag":123,"props":124,"children":127},"aside",{"emogi":125,"color":126},"undefined","purple",[128],{"type":22,"value":129},"변수 선언과 함수 정의\n변수는 선언(declaration)한다고 했지만 함수는 정의(definition)한다고 표현했다.\n함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다.\n따라서 ECMAScript 사양에서도 변수에는 선언(variable declration), 함수에는 정의(function definition)라고 표현한다.",{"type":16,"tag":17,"props":131,"children":133},{"id":132},"함수-선언문-표현식이-아닌-문",[134],{"type":22,"value":135},"함수 선언문 (표현식이 아닌 문)",{"type":16,"tag":48,"props":137,"children":138},{},[139,144],{"type":16,"tag":52,"props":140,"children":141},{},[142],{"type":22,"value":143},"함수 선언문은 함수리터럴과 형태가 동일하다.",{"type":16,"tag":52,"props":145,"children":146},{},[147],{"type":22,"value":148},"단, 함수 선언문은 함수 이름 생략 불가",{"type":16,"tag":31,"props":150,"children":153},{"className":151,"code":152,"language":10,"meta":7},[34],"// 함수 선언문\nfunction add(x, y) {\n    return x + y;\n}\n",[154],{"type":16,"tag":38,"props":155,"children":156},{"__ignoreMap":7},[157],{"type":22,"value":152},{"type":16,"tag":25,"props":159,"children":160},{},[161],{"type":22,"value":84},{"type":16,"tag":25,"props":163,"children":164},{},[165,167],{"type":22,"value":166},"함수 선언문은 ",{"type":16,"tag":58,"props":168,"children":169},{},[170],{"type":22,"value":171},"표현식이 아닌 문",{"type":16,"tag":25,"props":173,"children":174},{},[175],{"type":22,"value":176},"표현식이 아닌 문은 변수에 할당할 수 없다고 했는데",{"type":16,"tag":31,"props":178,"children":181},{"className":179,"code":180,"language":10,"meta":7},[34],"var add = function add(x, y) {\n    return x + y;\n}\n",[182],{"type":16,"tag":38,"props":183,"children":184},{"__ignoreMap":7},[185],{"type":22,"value":180},{"type":16,"tag":25,"props":187,"children":188},{},[189],{"type":22,"value":190},"하지만 위 코드를 보면 함수 선언문이 변수에 할당되는 것처럼 보인다.",{"type":16,"tag":25,"props":192,"children":193},{},[194],{"type":22,"value":84},{"type":16,"tag":25,"props":196,"children":197},{},[198,200,206,208,214],{"type":22,"value":199},"이는 자바스크립트 엔진이 코드의 문맥에 따라 ",{"type":16,"tag":38,"props":201,"children":203},{"className":202},[],[204],{"type":22,"value":205},"함수 선언문",{"type":22,"value":207},"으로 해석하거나 ",{"type":16,"tag":38,"props":209,"children":211},{"className":210},[],[212],{"type":22,"value":213},"함수 리터럴 표현식",{"type":22,"value":215},"으로 해석하는 경우가 있기 때문. 코드 문맥에 따라 해석이 달라짐",{"type":16,"tag":25,"props":217,"children":218},{},[219,221,226],{"type":22,"value":220},"위와 같은 경우는 표현식인 문인 ",{"type":16,"tag":38,"props":222,"children":224},{"className":223},[],[225],{"type":22,"value":213},{"type":22,"value":227},"으로 해석 되었기 때문에 가능",{"type":16,"tag":25,"props":229,"children":230},{},[231],{"type":22,"value":84},{"type":16,"tag":25,"props":233,"children":234},{},[235],{"type":22,"value":236},"기명 함수 리터럴은 중의적인 코드다.",{"type":16,"tag":238,"props":239,"children":240},"ol",{},[241,246],{"type":16,"tag":52,"props":242,"children":243},{},[244],{"type":22,"value":245},"단독으로 사용하면 함수 선언문으로 해석",{"type":16,"tag":52,"props":247,"children":248},{},[249],{"type":22,"value":250},"값으로 평가되어야 하는 문맥 (할당, 피연산자)에서는 함수 리터럴 표현식으로 해석",{"type":16,"tag":25,"props":252,"children":253},{},[254],{"type":22,"value":84},{"type":16,"tag":25,"props":256,"children":257},{},[258],{"type":22,"value":259},"아래 코드를 보자",{"type":16,"tag":31,"props":261,"children":264},{"className":262,"code":263,"language":10,"meta":7},[34],"**//** 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석\nfunction foo() {\n    console.log('foo');\n}\n\nfoo(); // foo\n\n// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석\n// 그룹연산자()안에 피연산자 함수 리터럴은 함수 리터럴 표현식으로 해석\n(function bar() { console.log('bar')});\nbar(); // RefefenceError: bar is not defined\n",[265],{"type":16,"tag":38,"props":266,"children":267},{"__ignoreMap":7},[268],{"type":22,"value":263},{"type":16,"tag":25,"props":270,"children":271},{},[272,274,279],{"type":22,"value":273},"bar()를 왜 호출을 못할까? 그 이유는 ",{"type":16,"tag":38,"props":275,"children":277},{"className":276},[],[278],{"type":22,"value":213},{"type":22,"value":280},"으로 해석되기 때문이다. 위 함수 리터럴에서 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자라고 했다. 그래서 함수 내부가 아닌 외부에서는 호출이 불가능한 것이다.",{"type":16,"tag":282,"props":283,"children":284},"blockquote",{},[285],{"type":16,"tag":25,"props":286,"children":287},{},[288],{"type":22,"value":289},"함수 리터럴과 함수 리터럴 표현식 헷갈리지 말기",{"type":16,"tag":25,"props":291,"children":292},{},[293],{"type":22,"value":84},{"type":16,"tag":25,"props":295,"children":296},{},[297],{"type":22,"value":298},"위 예제에서 함수 선언문으로 정의된 함수는 foo라는 이름으로 호출할 수 있었다. foo는 함수 몸체 내부에서만 유효한 식별자인데 그러면 foo()는 어떻게 호출이 가능한걸까? 그 이유는 자바스크립트 엔진이 암묵적으로 식별자를 생성하기 때문이다.",{"type":16,"tag":25,"props":300,"children":301},{},[302],{"type":22,"value":303},"즉 자바스크립트 엔진은 함수 선언문을 해석해 함수 객체를 생성한다.",{"type":16,"tag":31,"props":305,"children":308},{"className":306,"code":307,"language":10,"meta":7},[34],"function foo() {\n    console.log('foo');\n}\n\n// 자바스크립트 엔진이 암묵적으로 아래와 같이 생성한다. (아래와 같이 동작하는건 알수 없으나 식별자가 생성된다는 것을 보여주기 위한 예제)\nvar foo = function foo() {\n    console.log('foo');\n}\n\n// 그래서 함수 표현식은 함수 이름 생략이 불가능하구나?\n",[309],{"type":16,"tag":38,"props":310,"children":311},{"__ignoreMap":7},[312],{"type":22,"value":307},{"type":16,"tag":25,"props":314,"children":315},{},[316],{"type":22,"value":84},{"type":16,"tag":25,"props":318,"children":319},{},[320],{"type":16,"tag":58,"props":321,"children":322},{},[323],{"type":22,"value":324},"함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다!",{"type":16,"tag":25,"props":326,"children":327},{},[328],{"type":22,"value":84},{"type":16,"tag":31,"props":330,"children":333},{"className":331,"code":332,"language":10,"meta":7},[34],"var foo = function bar(n) {\n    bar(); // 함수이름은 함수 몸체 내에서만 사용 가능\n}\n",[334],{"type":16,"tag":38,"props":335,"children":336},{"__ignoreMap":7},[337],{"type":22,"value":332},{"type":16,"tag":25,"props":339,"children":340},{},[341],{"type":22,"value":342},"용어 구분",{"type":16,"tag":48,"props":344,"children":345},{},[346,351],{"type":16,"tag":52,"props":347,"children":348},{},[349],{"type":22,"value":350},"식별자: foo",{"type":16,"tag":52,"props":352,"children":353},{},[354],{"type":22,"value":355},"함수이름 bar",{"type":16,"tag":31,"props":357,"children":360},{"className":358,"code":359,"language":10,"meta":7},[34],"var foo = function () {}\n",[361],{"type":16,"tag":38,"props":362,"children":363},{"__ignoreMap":7},[364],{"type":22,"value":359},{"type":16,"tag":25,"props":366,"children":367},{},[368],{"type":22,"value":342},{"type":16,"tag":48,"props":370,"children":371},{},[372,376],{"type":16,"tag":52,"props":373,"children":374},{},[375],{"type":22,"value":350},{"type":16,"tag":52,"props":377,"children":378},{},[379],{"type":22,"value":380},"함수이름: 없음 (익명함수)",{"type":16,"tag":25,"props":382,"children":383},{},[384],{"type":22,"value":84},{"type":16,"tag":25,"props":386,"children":387},{},[388],{"type":16,"tag":389,"props":390,"children":394},"a",{"href":391,"rel":392},"https://chat.openai.com/share/512948d1-1316-4bba-afaf-42e41498d5c8",[393],"nofollow",[395],{"type":22,"value":396},"bookmark",{"type":16,"tag":25,"props":398,"children":399},{},[400],{"type":22,"value":84},{"type":16,"tag":17,"props":402,"children":404},{"id":403},"함수-표현식표현식인-문",[405],{"type":22,"value":406},"함수 표현식(표현식인 문)",{"type":16,"tag":31,"props":408,"children":411},{"className":409,"code":410,"language":10,"meta":7},[34],"var add = function(x, y) {\n    return x + y;\n}\n",[412],{"type":16,"tag":38,"props":413,"children":414},{"__ignoreMap":7},[415],{"type":22,"value":410},{"type":16,"tag":25,"props":417,"children":418},{},[419],{"type":22,"value":84},{"type":16,"tag":25,"props":421,"children":422},{},[423],{"type":22,"value":424},"자바스크립트는 함수는 일급 객체다.",{"type":16,"tag":25,"props":426,"children":427},{},[428],{"type":22,"value":429},"함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이러한 함수 정의 방식을 함수 표현식(function expression)이라 한다.",{"type":16,"tag":25,"props":431,"children":432},{},[433],{"type":22,"value":84},{"type":16,"tag":17,"props":435,"children":437},{"id":436},"함수-생성-시점과-함수-호이스팅",[438],{"type":22,"value":439},"함수 생성 시점과 함수 호이스팅",{"type":16,"tag":31,"props":441,"children":444},{"className":442,"code":443,"language":10,"meta":7},[34],"// 함수 참조\nconsole.log(add); // f add(a, b)\nconsole.log(sub); // undefined\n\n// 함수 호출\nconsole.log(add(2, 5)); // 7\nconsole.log(sub(2, 5)); // TypeError: sub is not a function\n\n// 함수 선언문\nfunction add(a, b) {\n    return a + b;\n}\n\n// 함수 표현식\nvar sub = function(a, b) {\n    return a - b;\n}\n\n",[445],{"type":16,"tag":38,"props":446,"children":447},{"__ignoreMap":7},[448],{"type":22,"value":443},{"type":16,"tag":25,"props":450,"children":451},{},[452],{"type":22,"value":453},"함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다.",{"type":16,"tag":25,"props":455,"children":456},{},[457],{"type":22,"value":458},"함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다.",{"type":16,"tag":25,"props":460,"children":461},{},[462],{"type":22,"value":463},"이는 각 함수의 생성 시점이 다르기 때문이다.",{"type":16,"tag":25,"props":465,"children":466},{},[467],{"type":22,"value":84},{"type":16,"tag":25,"props":469,"children":470},{},[471],{"type":22,"value":472},"함수선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행된다.",{"type":16,"tag":238,"props":474,"children":475},{},[476,481,486],{"type":16,"tag":52,"props":477,"children":478},{},[479],{"type":22,"value":480},"함수 객체 생성",{"type":16,"tag":52,"props":482,"children":483},{},[484],{"type":22,"value":485},"함수 이름과 동일한 이름의 식별자 생성",{"type":16,"tag":52,"props":487,"children":488},{},[489],{"type":22,"value":490},"함수 객체를 식별자에 할당",{"type":16,"tag":25,"props":492,"children":493},{},[494],{"type":22,"value":84},{"type":16,"tag":25,"props":496,"children":497},{},[498],{"type":22,"value":499},"이처럼 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅이라 한다.",{"type":16,"tag":25,"props":501,"children":502},{},[503],{"type":22,"value":84},{"type":16,"tag":25,"props":505,"children":506},{},[507],{"type":22,"value":508},"함수 호이스팅과 변수 호이스팅 차이",{"type":16,"tag":238,"props":510,"children":511},{},[512,525],{"type":16,"tag":52,"props":513,"children":514},{},[515,517],{"type":22,"value":516},"변수 호이스팅은 undefined로 초기화\n",{"type":16,"tag":238,"props":518,"children":519},{},[520],{"type":16,"tag":52,"props":521,"children":522},{},[523],{"type":22,"value":524},"변수 호이스팅은 선언 이전에 호출하면 undefined로 평가 됨",{"type":16,"tag":52,"props":526,"children":527},{},[528,530],{"type":22,"value":529},"함수 호이스팅은 함수 객체로 초기화\n",{"type":16,"tag":238,"props":531,"children":532},{},[533],{"type":16,"tag":52,"props":534,"children":535},{},[536],{"type":22,"value":537},"함수 호이스팅은 함수 선언문 이전에 호출하면 호출이 가능",{"type":16,"tag":25,"props":539,"children":540},{},[541],{"type":22,"value":84},{"type":16,"tag":25,"props":543,"children":544},{},[545],{"type":22,"value":546},"함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.",{"type":16,"tag":25,"props":548,"children":549},{},[550],{"type":22,"value":84},{"type":16,"tag":552,"props":553,"children":555},"h3",{"id":554},"참조에-의한-전달과-외부-상태의-변경",[556],{"type":22,"value":557},"참조에 의한 전달과 외부 상태의 변경",{"type":16,"tag":31,"props":559,"children":562},{"className":560,"code":561,"language":10,"meta":7},[34],"function test(primitive, obj) {\n    primitive += 100;\n    obj.name = 'kim';\n}\n\nvar num = 100;\nvar person = {\n    name: 'lee';\n};\n\nconsole.log(num); // 100;\nconsole.log(person.name); // lee;\n\ntest(num, person);\n\nconsole.log(num); // 100\nconsole.log(person.name); // kim\n",[563],{"type":16,"tag":38,"props":564,"children":565},{"__ignoreMap":7},[566],{"type":22,"value":561},{"type":16,"tag":25,"props":568,"children":569},{},[570],{"type":22,"value":84},{"type":16,"tag":25,"props":572,"children":573},{},[574],{"type":22,"value":575},"함수 외부에서 함수 몸체 내부로 전달한 참조 값에 의해 원본 객체가 변경되는 부수 효과가 발생",{"type":16,"tag":25,"props":577,"children":578},{},[579],{"type":22,"value":84},{"type":16,"tag":48,"props":581,"children":582},{},[583,588],{"type":16,"tag":52,"props":584,"children":585},{},[586],{"type":22,"value":587},"객체의 변경을 추적하려면 옵저버 패턴 등을 통해 객체를 참조를 공유하는 모든 이들에게 변경 사실을 통지하고 이에 대처하는 추가 대응이 필요",{"type":16,"tag":52,"props":589,"children":590},{},[591],{"type":22,"value":592},"객체를 불변 객체로 만들어 사용하는것도 하나의 방법",{"type":16,"tag":25,"props":594,"children":595},{},[596,598,604],{"type":22,"value":597},"외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수를 ",{"type":16,"tag":38,"props":599,"children":601},{"className":600},[],[602],{"type":22,"value":603},"순수 함수",{"type":22,"value":605}," 라 한다.",{"type":16,"tag":25,"props":607,"children":608},{},[609],{"type":22,"value":84},{"type":16,"tag":17,"props":611,"children":613},{"id":612},"다양한-함수의-형태",[614],{"type":22,"value":615},"다양한 함수의 형태",{"type":16,"tag":552,"props":617,"children":619},{"id":618},"즉시-실행-함수",[620],{"type":22,"value":621},"즉시 실행 함수",{"type":16,"tag":31,"props":623,"children":626},{"className":624,"code":625,"language":10,"meta":7},[34],"(function() {}());\n// 그룹 연산자()로 함수를 묶은 이유는 먼저 함수 리터럴을 평가해서 함수 객체를 생성하기 위해서다.\n\n// 따라서 먼저 함수 리터럴을 평가해서 함수 객체를 생성할 수 있다면 그룹 연산자 이외의 연산자를 사용해도 좋다.\n(function(){})();\n!function(){}()\n+function(){}()\n",[627],{"type":16,"tag":38,"props":628,"children":629},{"__ignoreMap":7},[630],{"type":22,"value":625},{"type":16,"tag":552,"props":632,"children":634},{"id":633},"중첩-함수",[635],{"type":22,"value":636},"중첩 함수",{"type":16,"tag":25,"props":638,"children":639},{},[640],{"type":22,"value":641},"함수 내부에 정의된 함수를 중첩 함수 또는 내부 함수라 한다.",{"type":16,"tag":25,"props":643,"children":644},{},[645],{"type":22,"value":646},"중첩 함수를 포함하는 함수를 외부 함수라 부른다.",{"type":16,"tag":25,"props":648,"children":649},{},[650],{"type":22,"value":651},"일반적으로 중첩 함수는 자신을 포함하는 외부 함수를 돕는 헬퍼 함수의 역할을 한다.",{"type":16,"tag":552,"props":653,"children":655},{"id":654},"콜백함수",[656],{"type":22,"value":654},{"type":16,"tag":25,"props":658,"children":659},{},[660,662,667,669,674],{"type":22,"value":661},"함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 ",{"type":16,"tag":58,"props":663,"children":664},{},[665],{"type":22,"value":666},"콜백 함수",{"type":22,"value":668},"라고 하며, 매개 변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 ",{"type":16,"tag":58,"props":670,"children":671},{},[672],{"type":22,"value":673},"고차 함수",{"type":22,"value":675},"라고 한다.",{"type":16,"tag":25,"props":677,"children":678},{},[679],{"type":22,"value":680},"콜백함수도 고차 함수에 전달되어 헬퍼 함수의 역할을 한다.",{"type":16,"tag":25,"props":682,"children":683},{},[684],{"type":22,"value":685},"고차 함수는 콜백 함수를 자신의 일부분으로 합성한다.",{"type":16,"tag":25,"props":687,"children":688},{},[689],{"type":22,"value":690},"고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다.",{"type":16,"tag":25,"props":692,"children":693},{},[694],{"type":22,"value":695},"콜백 함수는 고차 함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.",{"type":16,"tag":31,"props":697,"children":700},{"className":698,"code":699,"language":10,"meta":7},[34],"// 고차함수\nfunction repeat(n, f) {\n    for (var i = 0; i \u003C n; i++) {\n        // 콜백 함수\n        f(i);\n    }\n}\n\nvar logAll = function(i) {\n    console.log(i);\n}\n",[701],{"type":16,"tag":38,"props":702,"children":703},{"__ignoreMap":7},[704],{"type":22,"value":699},{"type":16,"tag":31,"props":706,"children":709},{"className":707,"code":708,"language":10,"meta":7},[34],"// 고차 함수 map\n[1, 2, 3].map(function (item) {});\n",[710],{"type":16,"tag":38,"props":711,"children":712},{"__ignoreMap":7},[713],{"type":22,"value":708},{"type":16,"tag":552,"props":715,"children":717},{"id":716},"순수-함수와-비순수-함수",[718],{"type":22,"value":719},"순수 함수와 비순수 함수",{"type":16,"tag":25,"props":721,"children":722},{},[723],{"type":22,"value":724},"어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수 효과가 없는 함수를 순수 함수라 하고",{"type":16,"tag":25,"props":726,"children":727},{},[728],{"type":22,"value":729},"외부 상태에 의존하거나 외부 상태를 변경하는, 즉 부수 효과가 있는 함수를 비순수 함수라고 한다.",{"type":16,"tag":31,"props":731,"children":734},{"className":732,"code":733,"language":10,"meta":7},[34],"var count = 0;\n\n// 순수 함수 increase는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.\nfunction increase(n) {\n    return ++n;\n}\n// 순수 함수가 반환한 결과값을 변수에 재할당해서 상태를 변경\ncount = increase(count);\nconsole.log(count); // 1;\n",[735],{"type":16,"tag":38,"props":736,"children":737},{"__ignoreMap":7},[738],{"type":22,"value":733},{"type":16,"tag":31,"props":740,"children":743},{"className":741,"code":742,"language":10,"meta":7},[34],"var count = 0;\n\n// 비순수 함수\nfunction increase() {\n    return ++count; // 외부 상태에 의존하며 외부 상태를 변경한다.\n}\n\n// 비순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려워진다.\nincrease(count);\nconsole.log(count); // 1;\n",[744],{"type":16,"tag":38,"props":745,"children":746},{"__ignoreMap":7},[747],{"type":22,"value":742},{"title":7,"searchDepth":749,"depth":749,"links":750},2,[751,752,753,754,758],{"id":19,"depth":749,"text":23},{"id":132,"depth":749,"text":135},{"id":403,"depth":749,"text":406},{"id":436,"depth":749,"text":439,"children":755},[756],{"id":554,"depth":757,"text":557},3,{"id":612,"depth":749,"text":615,"children":759},[760,761,762,763],{"id":618,"depth":757,"text":621},{"id":633,"depth":757,"text":636},{"id":654,"depth":757,"text":654},{"id":716,"depth":757,"text":719},"markdown","content:posts:96c9d4b7-fef3-492c-aedb-b53a58deebb1.md","content","posts/96c9d4b7-fef3-492c-aedb-b53a58deebb1.md","md",1710325141888]